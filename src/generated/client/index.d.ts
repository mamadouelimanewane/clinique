
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model CompteComptable
 * 
 */
export type CompteComptable = $Result.DefaultSelection<Prisma.$CompteComptablePayload>
/**
 * Model Journal
 * 
 */
export type Journal = $Result.DefaultSelection<Prisma.$JournalPayload>
/**
 * Model ExerciceComptable
 * 
 */
export type ExerciceComptable = $Result.DefaultSelection<Prisma.$ExerciceComptablePayload>
/**
 * Model EcritureComptable
 * 
 */
export type EcritureComptable = $Result.DefaultSelection<Prisma.$EcritureComptablePayload>
/**
 * Model CentreAnalytique
 * 
 */
export type CentreAnalytique = $Result.DefaultSelection<Prisma.$CentreAnalytiquePayload>
/**
 * Model Budget
 * 
 */
export type Budget = $Result.DefaultSelection<Prisma.$BudgetPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Antecedent
 * 
 */
export type Antecedent = $Result.DefaultSelection<Prisma.$AntecedentPayload>
/**
 * Model Allergie
 * 
 */
export type Allergie = $Result.DefaultSelection<Prisma.$AllergiePayload>
/**
 * Model Vaccination
 * 
 */
export type Vaccination = $Result.DefaultSelection<Prisma.$VaccinationPayload>
/**
 * Model RendezVous
 * 
 */
export type RendezVous = $Result.DefaultSelection<Prisma.$RendezVousPayload>
/**
 * Model Consultation
 * 
 */
export type Consultation = $Result.DefaultSelection<Prisma.$ConsultationPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model NomenclatureActe
 * 
 */
export type NomenclatureActe = $Result.DefaultSelection<Prisma.$NomenclatureActePayload>
/**
 * Model ActeRealise
 * 
 */
export type ActeRealise = $Result.DefaultSelection<Prisma.$ActeRealisePayload>
/**
 * Model ResultatExamen
 * 
 */
export type ResultatExamen = $Result.DefaultSelection<Prisma.$ResultatExamenPayload>
/**
 * Model Medicament
 * 
 */
export type Medicament = $Result.DefaultSelection<Prisma.$MedicamentPayload>
/**
 * Model Fournisseur
 * 
 */
export type Fournisseur = $Result.DefaultSelection<Prisma.$FournisseurPayload>
/**
 * Model CommandePharmacie
 * 
 */
export type CommandePharmacie = $Result.DefaultSelection<Prisma.$CommandePharmaciePayload>
/**
 * Model LigneCommandePharmacie
 * 
 */
export type LigneCommandePharmacie = $Result.DefaultSelection<Prisma.$LigneCommandePharmaciePayload>
/**
 * Model Stock
 * 
 */
export type Stock = $Result.DefaultSelection<Prisma.$StockPayload>
/**
 * Model MouvementStock
 * 
 */
export type MouvementStock = $Result.DefaultSelection<Prisma.$MouvementStockPayload>
/**
 * Model Dispensation
 * 
 */
export type Dispensation = $Result.DefaultSelection<Prisma.$DispensationPayload>
/**
 * Model Facture
 * 
 */
export type Facture = $Result.DefaultSelection<Prisma.$FacturePayload>
/**
 * Model LigneFacture
 * 
 */
export type LigneFacture = $Result.DefaultSelection<Prisma.$LigneFacturePayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>
/**
 * Model Lit
 * 
 */
export type Lit = $Result.DefaultSelection<Prisma.$LitPayload>
/**
 * Model Hospitalisation
 * 
 */
export type Hospitalisation = $Result.DefaultSelection<Prisma.$HospitalisationPayload>
/**
 * Model ObservationInfirmier
 * 
 */
export type ObservationInfirmier = $Result.DefaultSelection<Prisma.$ObservationInfirmierPayload>
/**
 * Model Intervention
 * 
 */
export type Intervention = $Result.DefaultSelection<Prisma.$InterventionPayload>
/**
 * Model DossierMaternite
 * 
 */
export type DossierMaternite = $Result.DefaultSelection<Prisma.$DossierMaternitePayload>
/**
 * Model NouveauNe
 * 
 */
export type NouveauNe = $Result.DefaultSelection<Prisma.$NouveauNePayload>
/**
 * Model ArticleLogistique
 * 
 */
export type ArticleLogistique = $Result.DefaultSelection<Prisma.$ArticleLogistiquePayload>
/**
 * Model MouvementLogistique
 * 
 */
export type MouvementLogistique = $Result.DefaultSelection<Prisma.$MouvementLogistiquePayload>
/**
 * Model DocumentGED
 * 
 */
export type DocumentGED = $Result.DefaultSelection<Prisma.$DocumentGEDPayload>
/**
 * Model Employe
 * 
 */
export type Employe = $Result.DefaultSelection<Prisma.$EmployePayload>
/**
 * Model Conge
 * 
 */
export type Conge = $Result.DefaultSelection<Prisma.$CongePayload>
/**
 * Model BulletinPaie
 * 
 */
export type BulletinPaie = $Result.DefaultSelection<Prisma.$BulletinPaiePayload>
/**
 * Model LigneBulletin
 * 
 */
export type LigneBulletin = $Result.DefaultSelection<Prisma.$LigneBulletinPayload>
/**
 * Model Planning
 * 
 */
export type Planning = $Result.DefaultSelection<Prisma.$PlanningPayload>
/**
 * Model Equipement
 * 
 */
export type Equipement = $Result.DefaultSelection<Prisma.$EquipementPayload>
/**
 * Model TicketMaintenance
 * 
 */
export type TicketMaintenance = $Result.DefaultSelection<Prisma.$TicketMaintenancePayload>
/**
 * Model EvenementIndesirable
 * 
 */
export type EvenementIndesirable = $Result.DefaultSelection<Prisma.$EvenementIndesirablePayload>
/**
 * Model AuditQualite
 * 
 */
export type AuditQualite = $Result.DefaultSelection<Prisma.$AuditQualitePayload>
/**
 * Model Configuration
 * 
 */
export type Configuration = $Result.DefaultSelection<Prisma.$ConfigurationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compteComptable`: Exposes CRUD operations for the **CompteComptable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompteComptables
    * const compteComptables = await prisma.compteComptable.findMany()
    * ```
    */
  get compteComptable(): Prisma.CompteComptableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.journal`: Exposes CRUD operations for the **Journal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Journals
    * const journals = await prisma.journal.findMany()
    * ```
    */
  get journal(): Prisma.JournalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exerciceComptable`: Exposes CRUD operations for the **ExerciceComptable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciceComptables
    * const exerciceComptables = await prisma.exerciceComptable.findMany()
    * ```
    */
  get exerciceComptable(): Prisma.ExerciceComptableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ecritureComptable`: Exposes CRUD operations for the **EcritureComptable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EcritureComptables
    * const ecritureComptables = await prisma.ecritureComptable.findMany()
    * ```
    */
  get ecritureComptable(): Prisma.EcritureComptableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.centreAnalytique`: Exposes CRUD operations for the **CentreAnalytique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CentreAnalytiques
    * const centreAnalytiques = await prisma.centreAnalytique.findMany()
    * ```
    */
  get centreAnalytique(): Prisma.CentreAnalytiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.budget`: Exposes CRUD operations for the **Budget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Budgets
    * const budgets = await prisma.budget.findMany()
    * ```
    */
  get budget(): Prisma.BudgetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.antecedent`: Exposes CRUD operations for the **Antecedent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Antecedents
    * const antecedents = await prisma.antecedent.findMany()
    * ```
    */
  get antecedent(): Prisma.AntecedentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.allergie`: Exposes CRUD operations for the **Allergie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Allergies
    * const allergies = await prisma.allergie.findMany()
    * ```
    */
  get allergie(): Prisma.AllergieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccination`: Exposes CRUD operations for the **Vaccination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaccinations
    * const vaccinations = await prisma.vaccination.findMany()
    * ```
    */
  get vaccination(): Prisma.VaccinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rendezVous`: Exposes CRUD operations for the **RendezVous** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RendezVous
    * const rendezVous = await prisma.rendezVous.findMany()
    * ```
    */
  get rendezVous(): Prisma.RendezVousDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consultation`: Exposes CRUD operations for the **Consultation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consultations
    * const consultations = await prisma.consultation.findMany()
    * ```
    */
  get consultation(): Prisma.ConsultationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nomenclatureActe`: Exposes CRUD operations for the **NomenclatureActe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NomenclatureActes
    * const nomenclatureActes = await prisma.nomenclatureActe.findMany()
    * ```
    */
  get nomenclatureActe(): Prisma.NomenclatureActeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.acteRealise`: Exposes CRUD operations for the **ActeRealise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActeRealises
    * const acteRealises = await prisma.acteRealise.findMany()
    * ```
    */
  get acteRealise(): Prisma.ActeRealiseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resultatExamen`: Exposes CRUD operations for the **ResultatExamen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultatExamen
    * const resultatExamen = await prisma.resultatExamen.findMany()
    * ```
    */
  get resultatExamen(): Prisma.ResultatExamenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicament`: Exposes CRUD operations for the **Medicament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicaments
    * const medicaments = await prisma.medicament.findMany()
    * ```
    */
  get medicament(): Prisma.MedicamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fournisseur`: Exposes CRUD operations for the **Fournisseur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fournisseurs
    * const fournisseurs = await prisma.fournisseur.findMany()
    * ```
    */
  get fournisseur(): Prisma.FournisseurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commandePharmacie`: Exposes CRUD operations for the **CommandePharmacie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommandePharmacies
    * const commandePharmacies = await prisma.commandePharmacie.findMany()
    * ```
    */
  get commandePharmacie(): Prisma.CommandePharmacieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneCommandePharmacie`: Exposes CRUD operations for the **LigneCommandePharmacie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneCommandePharmacies
    * const ligneCommandePharmacies = await prisma.ligneCommandePharmacie.findMany()
    * ```
    */
  get ligneCommandePharmacie(): Prisma.LigneCommandePharmacieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stock`: Exposes CRUD operations for the **Stock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stocks
    * const stocks = await prisma.stock.findMany()
    * ```
    */
  get stock(): Prisma.StockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mouvementStock`: Exposes CRUD operations for the **MouvementStock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MouvementStocks
    * const mouvementStocks = await prisma.mouvementStock.findMany()
    * ```
    */
  get mouvementStock(): Prisma.MouvementStockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispensation`: Exposes CRUD operations for the **Dispensation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dispensations
    * const dispensations = await prisma.dispensation.findMany()
    * ```
    */
  get dispensation(): Prisma.DispensationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facture`: Exposes CRUD operations for the **Facture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Factures
    * const factures = await prisma.facture.findMany()
    * ```
    */
  get facture(): Prisma.FactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneFacture`: Exposes CRUD operations for the **LigneFacture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneFactures
    * const ligneFactures = await prisma.ligneFacture.findMany()
    * ```
    */
  get ligneFacture(): Prisma.LigneFactureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lit`: Exposes CRUD operations for the **Lit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lits
    * const lits = await prisma.lit.findMany()
    * ```
    */
  get lit(): Prisma.LitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hospitalisation`: Exposes CRUD operations for the **Hospitalisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hospitalisations
    * const hospitalisations = await prisma.hospitalisation.findMany()
    * ```
    */
  get hospitalisation(): Prisma.HospitalisationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.observationInfirmier`: Exposes CRUD operations for the **ObservationInfirmier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObservationInfirmiers
    * const observationInfirmiers = await prisma.observationInfirmier.findMany()
    * ```
    */
  get observationInfirmier(): Prisma.ObservationInfirmierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intervention`: Exposes CRUD operations for the **Intervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interventions
    * const interventions = await prisma.intervention.findMany()
    * ```
    */
  get intervention(): Prisma.InterventionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dossierMaternite`: Exposes CRUD operations for the **DossierMaternite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DossierMaternites
    * const dossierMaternites = await prisma.dossierMaternite.findMany()
    * ```
    */
  get dossierMaternite(): Prisma.DossierMaterniteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nouveauNe`: Exposes CRUD operations for the **NouveauNe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NouveauNes
    * const nouveauNes = await prisma.nouveauNe.findMany()
    * ```
    */
  get nouveauNe(): Prisma.NouveauNeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.articleLogistique`: Exposes CRUD operations for the **ArticleLogistique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleLogistiques
    * const articleLogistiques = await prisma.articleLogistique.findMany()
    * ```
    */
  get articleLogistique(): Prisma.ArticleLogistiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mouvementLogistique`: Exposes CRUD operations for the **MouvementLogistique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MouvementLogistiques
    * const mouvementLogistiques = await prisma.mouvementLogistique.findMany()
    * ```
    */
  get mouvementLogistique(): Prisma.MouvementLogistiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentGED`: Exposes CRUD operations for the **DocumentGED** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentGEDS
    * const documentGEDS = await prisma.documentGED.findMany()
    * ```
    */
  get documentGED(): Prisma.DocumentGEDDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employe`: Exposes CRUD operations for the **Employe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employes
    * const employes = await prisma.employe.findMany()
    * ```
    */
  get employe(): Prisma.EmployeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conge`: Exposes CRUD operations for the **Conge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conges
    * const conges = await prisma.conge.findMany()
    * ```
    */
  get conge(): Prisma.CongeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bulletinPaie`: Exposes CRUD operations for the **BulletinPaie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BulletinPaies
    * const bulletinPaies = await prisma.bulletinPaie.findMany()
    * ```
    */
  get bulletinPaie(): Prisma.BulletinPaieDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ligneBulletin`: Exposes CRUD operations for the **LigneBulletin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LigneBulletins
    * const ligneBulletins = await prisma.ligneBulletin.findMany()
    * ```
    */
  get ligneBulletin(): Prisma.LigneBulletinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planning`: Exposes CRUD operations for the **Planning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plannings
    * const plannings = await prisma.planning.findMany()
    * ```
    */
  get planning(): Prisma.PlanningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipement`: Exposes CRUD operations for the **Equipement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipements
    * const equipements = await prisma.equipement.findMany()
    * ```
    */
  get equipement(): Prisma.EquipementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketMaintenance`: Exposes CRUD operations for the **TicketMaintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketMaintenances
    * const ticketMaintenances = await prisma.ticketMaintenance.findMany()
    * ```
    */
  get ticketMaintenance(): Prisma.TicketMaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evenementIndesirable`: Exposes CRUD operations for the **EvenementIndesirable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvenementIndesirables
    * const evenementIndesirables = await prisma.evenementIndesirable.findMany()
    * ```
    */
  get evenementIndesirable(): Prisma.EvenementIndesirableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditQualite`: Exposes CRUD operations for the **AuditQualite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditQualites
    * const auditQualites = await prisma.auditQualite.findMany()
    * ```
    */
  get auditQualite(): Prisma.AuditQualiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configuration`: Exposes CRUD operations for the **Configuration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configurations
    * const configurations = await prisma.configuration.findMany()
    * ```
    */
  get configuration(): Prisma.ConfigurationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Role: 'Role',
    Permission: 'Permission',
    AuditLog: 'AuditLog',
    CompteComptable: 'CompteComptable',
    Journal: 'Journal',
    ExerciceComptable: 'ExerciceComptable',
    EcritureComptable: 'EcritureComptable',
    CentreAnalytique: 'CentreAnalytique',
    Budget: 'Budget',
    Patient: 'Patient',
    Antecedent: 'Antecedent',
    Allergie: 'Allergie',
    Vaccination: 'Vaccination',
    RendezVous: 'RendezVous',
    Consultation: 'Consultation',
    Prescription: 'Prescription',
    NomenclatureActe: 'NomenclatureActe',
    ActeRealise: 'ActeRealise',
    ResultatExamen: 'ResultatExamen',
    Medicament: 'Medicament',
    Fournisseur: 'Fournisseur',
    CommandePharmacie: 'CommandePharmacie',
    LigneCommandePharmacie: 'LigneCommandePharmacie',
    Stock: 'Stock',
    MouvementStock: 'MouvementStock',
    Dispensation: 'Dispensation',
    Facture: 'Facture',
    LigneFacture: 'LigneFacture',
    Paiement: 'Paiement',
    Lit: 'Lit',
    Hospitalisation: 'Hospitalisation',
    ObservationInfirmier: 'ObservationInfirmier',
    Intervention: 'Intervention',
    DossierMaternite: 'DossierMaternite',
    NouveauNe: 'NouveauNe',
    ArticleLogistique: 'ArticleLogistique',
    MouvementLogistique: 'MouvementLogistique',
    DocumentGED: 'DocumentGED',
    Employe: 'Employe',
    Conge: 'Conge',
    BulletinPaie: 'BulletinPaie',
    LigneBulletin: 'LigneBulletin',
    Planning: 'Planning',
    Equipement: 'Equipement',
    TicketMaintenance: 'TicketMaintenance',
    EvenementIndesirable: 'EvenementIndesirable',
    AuditQualite: 'AuditQualite',
    Configuration: 'Configuration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "role" | "permission" | "auditLog" | "compteComptable" | "journal" | "exerciceComptable" | "ecritureComptable" | "centreAnalytique" | "budget" | "patient" | "antecedent" | "allergie" | "vaccination" | "rendezVous" | "consultation" | "prescription" | "nomenclatureActe" | "acteRealise" | "resultatExamen" | "medicament" | "fournisseur" | "commandePharmacie" | "ligneCommandePharmacie" | "stock" | "mouvementStock" | "dispensation" | "facture" | "ligneFacture" | "paiement" | "lit" | "hospitalisation" | "observationInfirmier" | "intervention" | "dossierMaternite" | "nouveauNe" | "articleLogistique" | "mouvementLogistique" | "documentGED" | "employe" | "conge" | "bulletinPaie" | "ligneBulletin" | "planning" | "equipement" | "ticketMaintenance" | "evenementIndesirable" | "auditQualite" | "configuration"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      CompteComptable: {
        payload: Prisma.$CompteComptablePayload<ExtArgs>
        fields: Prisma.CompteComptableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompteComptableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompteComptableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          findFirst: {
            args: Prisma.CompteComptableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompteComptableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          findMany: {
            args: Prisma.CompteComptableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>[]
          }
          create: {
            args: Prisma.CompteComptableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          createMany: {
            args: Prisma.CompteComptableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompteComptableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>[]
          }
          delete: {
            args: Prisma.CompteComptableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          update: {
            args: Prisma.CompteComptableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          deleteMany: {
            args: Prisma.CompteComptableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompteComptableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompteComptableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>[]
          }
          upsert: {
            args: Prisma.CompteComptableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompteComptablePayload>
          }
          aggregate: {
            args: Prisma.CompteComptableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompteComptable>
          }
          groupBy: {
            args: Prisma.CompteComptableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompteComptableGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompteComptableCountArgs<ExtArgs>
            result: $Utils.Optional<CompteComptableCountAggregateOutputType> | number
          }
        }
      }
      Journal: {
        payload: Prisma.$JournalPayload<ExtArgs>
        fields: Prisma.JournalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findFirst: {
            args: Prisma.JournalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          findMany: {
            args: Prisma.JournalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          create: {
            args: Prisma.JournalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          createMany: {
            args: Prisma.JournalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          delete: {
            args: Prisma.JournalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          update: {
            args: Prisma.JournalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          deleteMany: {
            args: Prisma.JournalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JournalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>[]
          }
          upsert: {
            args: Prisma.JournalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalPayload>
          }
          aggregate: {
            args: Prisma.JournalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournal>
          }
          groupBy: {
            args: Prisma.JournalGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalCountArgs<ExtArgs>
            result: $Utils.Optional<JournalCountAggregateOutputType> | number
          }
        }
      }
      ExerciceComptable: {
        payload: Prisma.$ExerciceComptablePayload<ExtArgs>
        fields: Prisma.ExerciceComptableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciceComptableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciceComptableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          findFirst: {
            args: Prisma.ExerciceComptableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciceComptableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          findMany: {
            args: Prisma.ExerciceComptableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>[]
          }
          create: {
            args: Prisma.ExerciceComptableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          createMany: {
            args: Prisma.ExerciceComptableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciceComptableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>[]
          }
          delete: {
            args: Prisma.ExerciceComptableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          update: {
            args: Prisma.ExerciceComptableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          deleteMany: {
            args: Prisma.ExerciceComptableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciceComptableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExerciceComptableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>[]
          }
          upsert: {
            args: Prisma.ExerciceComptableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExerciceComptablePayload>
          }
          aggregate: {
            args: Prisma.ExerciceComptableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExerciceComptable>
          }
          groupBy: {
            args: Prisma.ExerciceComptableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciceComptableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciceComptableCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciceComptableCountAggregateOutputType> | number
          }
        }
      }
      EcritureComptable: {
        payload: Prisma.$EcritureComptablePayload<ExtArgs>
        fields: Prisma.EcritureComptableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EcritureComptableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EcritureComptableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          findFirst: {
            args: Prisma.EcritureComptableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EcritureComptableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          findMany: {
            args: Prisma.EcritureComptableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>[]
          }
          create: {
            args: Prisma.EcritureComptableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          createMany: {
            args: Prisma.EcritureComptableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EcritureComptableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>[]
          }
          delete: {
            args: Prisma.EcritureComptableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          update: {
            args: Prisma.EcritureComptableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          deleteMany: {
            args: Prisma.EcritureComptableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EcritureComptableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EcritureComptableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>[]
          }
          upsert: {
            args: Prisma.EcritureComptableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EcritureComptablePayload>
          }
          aggregate: {
            args: Prisma.EcritureComptableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEcritureComptable>
          }
          groupBy: {
            args: Prisma.EcritureComptableGroupByArgs<ExtArgs>
            result: $Utils.Optional<EcritureComptableGroupByOutputType>[]
          }
          count: {
            args: Prisma.EcritureComptableCountArgs<ExtArgs>
            result: $Utils.Optional<EcritureComptableCountAggregateOutputType> | number
          }
        }
      }
      CentreAnalytique: {
        payload: Prisma.$CentreAnalytiquePayload<ExtArgs>
        fields: Prisma.CentreAnalytiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CentreAnalytiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CentreAnalytiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          findFirst: {
            args: Prisma.CentreAnalytiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CentreAnalytiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          findMany: {
            args: Prisma.CentreAnalytiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>[]
          }
          create: {
            args: Prisma.CentreAnalytiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          createMany: {
            args: Prisma.CentreAnalytiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CentreAnalytiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>[]
          }
          delete: {
            args: Prisma.CentreAnalytiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          update: {
            args: Prisma.CentreAnalytiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          deleteMany: {
            args: Prisma.CentreAnalytiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CentreAnalytiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CentreAnalytiqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>[]
          }
          upsert: {
            args: Prisma.CentreAnalytiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CentreAnalytiquePayload>
          }
          aggregate: {
            args: Prisma.CentreAnalytiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCentreAnalytique>
          }
          groupBy: {
            args: Prisma.CentreAnalytiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<CentreAnalytiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.CentreAnalytiqueCountArgs<ExtArgs>
            result: $Utils.Optional<CentreAnalytiqueCountAggregateOutputType> | number
          }
        }
      }
      Budget: {
        payload: Prisma.$BudgetPayload<ExtArgs>
        fields: Prisma.BudgetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BudgetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findFirst: {
            args: Prisma.BudgetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          findMany: {
            args: Prisma.BudgetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          create: {
            args: Prisma.BudgetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          createMany: {
            args: Prisma.BudgetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          delete: {
            args: Prisma.BudgetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          update: {
            args: Prisma.BudgetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          deleteMany: {
            args: Prisma.BudgetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BudgetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>[]
          }
          upsert: {
            args: Prisma.BudgetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BudgetPayload>
          }
          aggregate: {
            args: Prisma.BudgetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBudget>
          }
          groupBy: {
            args: Prisma.BudgetGroupByArgs<ExtArgs>
            result: $Utils.Optional<BudgetGroupByOutputType>[]
          }
          count: {
            args: Prisma.BudgetCountArgs<ExtArgs>
            result: $Utils.Optional<BudgetCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Antecedent: {
        payload: Prisma.$AntecedentPayload<ExtArgs>
        fields: Prisma.AntecedentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AntecedentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AntecedentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          findFirst: {
            args: Prisma.AntecedentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AntecedentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          findMany: {
            args: Prisma.AntecedentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>[]
          }
          create: {
            args: Prisma.AntecedentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          createMany: {
            args: Prisma.AntecedentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AntecedentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>[]
          }
          delete: {
            args: Prisma.AntecedentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          update: {
            args: Prisma.AntecedentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          deleteMany: {
            args: Prisma.AntecedentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AntecedentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AntecedentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>[]
          }
          upsert: {
            args: Prisma.AntecedentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AntecedentPayload>
          }
          aggregate: {
            args: Prisma.AntecedentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAntecedent>
          }
          groupBy: {
            args: Prisma.AntecedentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AntecedentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AntecedentCountArgs<ExtArgs>
            result: $Utils.Optional<AntecedentCountAggregateOutputType> | number
          }
        }
      }
      Allergie: {
        payload: Prisma.$AllergiePayload<ExtArgs>
        fields: Prisma.AllergieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AllergieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AllergieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          findFirst: {
            args: Prisma.AllergieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AllergieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          findMany: {
            args: Prisma.AllergieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>[]
          }
          create: {
            args: Prisma.AllergieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          createMany: {
            args: Prisma.AllergieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AllergieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>[]
          }
          delete: {
            args: Prisma.AllergieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          update: {
            args: Prisma.AllergieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          deleteMany: {
            args: Prisma.AllergieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AllergieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AllergieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>[]
          }
          upsert: {
            args: Prisma.AllergieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AllergiePayload>
          }
          aggregate: {
            args: Prisma.AllergieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAllergie>
          }
          groupBy: {
            args: Prisma.AllergieGroupByArgs<ExtArgs>
            result: $Utils.Optional<AllergieGroupByOutputType>[]
          }
          count: {
            args: Prisma.AllergieCountArgs<ExtArgs>
            result: $Utils.Optional<AllergieCountAggregateOutputType> | number
          }
        }
      }
      Vaccination: {
        payload: Prisma.$VaccinationPayload<ExtArgs>
        fields: Prisma.VaccinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findFirst: {
            args: Prisma.VaccinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findMany: {
            args: Prisma.VaccinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>[]
          }
          create: {
            args: Prisma.VaccinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          createMany: {
            args: Prisma.VaccinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VaccinationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>[]
          }
          delete: {
            args: Prisma.VaccinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          update: {
            args: Prisma.VaccinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VaccinationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>[]
          }
          upsert: {
            args: Prisma.VaccinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          aggregate: {
            args: Prisma.VaccinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccination>
          }
          groupBy: {
            args: Prisma.VaccinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccinationCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationCountAggregateOutputType> | number
          }
        }
      }
      RendezVous: {
        payload: Prisma.$RendezVousPayload<ExtArgs>
        fields: Prisma.RendezVousFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RendezVousFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RendezVousFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          findFirst: {
            args: Prisma.RendezVousFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RendezVousFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          findMany: {
            args: Prisma.RendezVousFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>[]
          }
          create: {
            args: Prisma.RendezVousCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          createMany: {
            args: Prisma.RendezVousCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RendezVousCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>[]
          }
          delete: {
            args: Prisma.RendezVousDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          update: {
            args: Prisma.RendezVousUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          deleteMany: {
            args: Prisma.RendezVousDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RendezVousUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RendezVousUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>[]
          }
          upsert: {
            args: Prisma.RendezVousUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RendezVousPayload>
          }
          aggregate: {
            args: Prisma.RendezVousAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRendezVous>
          }
          groupBy: {
            args: Prisma.RendezVousGroupByArgs<ExtArgs>
            result: $Utils.Optional<RendezVousGroupByOutputType>[]
          }
          count: {
            args: Prisma.RendezVousCountArgs<ExtArgs>
            result: $Utils.Optional<RendezVousCountAggregateOutputType> | number
          }
        }
      }
      Consultation: {
        payload: Prisma.$ConsultationPayload<ExtArgs>
        fields: Prisma.ConsultationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConsultationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConsultationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findFirst: {
            args: Prisma.ConsultationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConsultationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          findMany: {
            args: Prisma.ConsultationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          create: {
            args: Prisma.ConsultationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          createMany: {
            args: Prisma.ConsultationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConsultationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          delete: {
            args: Prisma.ConsultationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          update: {
            args: Prisma.ConsultationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          deleteMany: {
            args: Prisma.ConsultationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConsultationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConsultationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>[]
          }
          upsert: {
            args: Prisma.ConsultationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConsultationPayload>
          }
          aggregate: {
            args: Prisma.ConsultationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsultation>
          }
          groupBy: {
            args: Prisma.ConsultationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConsultationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConsultationCountArgs<ExtArgs>
            result: $Utils.Optional<ConsultationCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      NomenclatureActe: {
        payload: Prisma.$NomenclatureActePayload<ExtArgs>
        fields: Prisma.NomenclatureActeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NomenclatureActeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NomenclatureActeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          findFirst: {
            args: Prisma.NomenclatureActeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NomenclatureActeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          findMany: {
            args: Prisma.NomenclatureActeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>[]
          }
          create: {
            args: Prisma.NomenclatureActeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          createMany: {
            args: Prisma.NomenclatureActeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NomenclatureActeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>[]
          }
          delete: {
            args: Prisma.NomenclatureActeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          update: {
            args: Prisma.NomenclatureActeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          deleteMany: {
            args: Prisma.NomenclatureActeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NomenclatureActeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NomenclatureActeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>[]
          }
          upsert: {
            args: Prisma.NomenclatureActeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NomenclatureActePayload>
          }
          aggregate: {
            args: Prisma.NomenclatureActeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNomenclatureActe>
          }
          groupBy: {
            args: Prisma.NomenclatureActeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NomenclatureActeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NomenclatureActeCountArgs<ExtArgs>
            result: $Utils.Optional<NomenclatureActeCountAggregateOutputType> | number
          }
        }
      }
      ActeRealise: {
        payload: Prisma.$ActeRealisePayload<ExtArgs>
        fields: Prisma.ActeRealiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActeRealiseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActeRealiseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          findFirst: {
            args: Prisma.ActeRealiseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActeRealiseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          findMany: {
            args: Prisma.ActeRealiseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>[]
          }
          create: {
            args: Prisma.ActeRealiseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          createMany: {
            args: Prisma.ActeRealiseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActeRealiseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>[]
          }
          delete: {
            args: Prisma.ActeRealiseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          update: {
            args: Prisma.ActeRealiseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          deleteMany: {
            args: Prisma.ActeRealiseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActeRealiseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActeRealiseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>[]
          }
          upsert: {
            args: Prisma.ActeRealiseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActeRealisePayload>
          }
          aggregate: {
            args: Prisma.ActeRealiseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActeRealise>
          }
          groupBy: {
            args: Prisma.ActeRealiseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActeRealiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActeRealiseCountArgs<ExtArgs>
            result: $Utils.Optional<ActeRealiseCountAggregateOutputType> | number
          }
        }
      }
      ResultatExamen: {
        payload: Prisma.$ResultatExamenPayload<ExtArgs>
        fields: Prisma.ResultatExamenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultatExamenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultatExamenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          findFirst: {
            args: Prisma.ResultatExamenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultatExamenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          findMany: {
            args: Prisma.ResultatExamenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>[]
          }
          create: {
            args: Prisma.ResultatExamenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          createMany: {
            args: Prisma.ResultatExamenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultatExamenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>[]
          }
          delete: {
            args: Prisma.ResultatExamenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          update: {
            args: Prisma.ResultatExamenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          deleteMany: {
            args: Prisma.ResultatExamenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultatExamenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResultatExamenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>[]
          }
          upsert: {
            args: Prisma.ResultatExamenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatExamenPayload>
          }
          aggregate: {
            args: Prisma.ResultatExamenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultatExamen>
          }
          groupBy: {
            args: Prisma.ResultatExamenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultatExamenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultatExamenCountArgs<ExtArgs>
            result: $Utils.Optional<ResultatExamenCountAggregateOutputType> | number
          }
        }
      }
      Medicament: {
        payload: Prisma.$MedicamentPayload<ExtArgs>
        fields: Prisma.MedicamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          findFirst: {
            args: Prisma.MedicamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          findMany: {
            args: Prisma.MedicamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>[]
          }
          create: {
            args: Prisma.MedicamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          createMany: {
            args: Prisma.MedicamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>[]
          }
          delete: {
            args: Prisma.MedicamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          update: {
            args: Prisma.MedicamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          deleteMany: {
            args: Prisma.MedicamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>[]
          }
          upsert: {
            args: Prisma.MedicamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicamentPayload>
          }
          aggregate: {
            args: Prisma.MedicamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicament>
          }
          groupBy: {
            args: Prisma.MedicamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicamentCountArgs<ExtArgs>
            result: $Utils.Optional<MedicamentCountAggregateOutputType> | number
          }
        }
      }
      Fournisseur: {
        payload: Prisma.$FournisseurPayload<ExtArgs>
        fields: Prisma.FournisseurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FournisseurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FournisseurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findFirst: {
            args: Prisma.FournisseurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FournisseurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findMany: {
            args: Prisma.FournisseurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          create: {
            args: Prisma.FournisseurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          createMany: {
            args: Prisma.FournisseurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FournisseurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          delete: {
            args: Prisma.FournisseurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          update: {
            args: Prisma.FournisseurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          deleteMany: {
            args: Prisma.FournisseurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FournisseurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FournisseurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          upsert: {
            args: Prisma.FournisseurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          aggregate: {
            args: Prisma.FournisseurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFournisseur>
          }
          groupBy: {
            args: Prisma.FournisseurGroupByArgs<ExtArgs>
            result: $Utils.Optional<FournisseurGroupByOutputType>[]
          }
          count: {
            args: Prisma.FournisseurCountArgs<ExtArgs>
            result: $Utils.Optional<FournisseurCountAggregateOutputType> | number
          }
        }
      }
      CommandePharmacie: {
        payload: Prisma.$CommandePharmaciePayload<ExtArgs>
        fields: Prisma.CommandePharmacieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandePharmacieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandePharmacieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          findFirst: {
            args: Prisma.CommandePharmacieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandePharmacieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          findMany: {
            args: Prisma.CommandePharmacieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>[]
          }
          create: {
            args: Prisma.CommandePharmacieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          createMany: {
            args: Prisma.CommandePharmacieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandePharmacieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>[]
          }
          delete: {
            args: Prisma.CommandePharmacieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          update: {
            args: Prisma.CommandePharmacieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          deleteMany: {
            args: Prisma.CommandePharmacieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandePharmacieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommandePharmacieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>[]
          }
          upsert: {
            args: Prisma.CommandePharmacieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePharmaciePayload>
          }
          aggregate: {
            args: Prisma.CommandePharmacieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommandePharmacie>
          }
          groupBy: {
            args: Prisma.CommandePharmacieGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandePharmacieGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandePharmacieCountArgs<ExtArgs>
            result: $Utils.Optional<CommandePharmacieCountAggregateOutputType> | number
          }
        }
      }
      LigneCommandePharmacie: {
        payload: Prisma.$LigneCommandePharmaciePayload<ExtArgs>
        fields: Prisma.LigneCommandePharmacieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneCommandePharmacieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneCommandePharmacieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          findFirst: {
            args: Prisma.LigneCommandePharmacieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneCommandePharmacieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          findMany: {
            args: Prisma.LigneCommandePharmacieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>[]
          }
          create: {
            args: Prisma.LigneCommandePharmacieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          createMany: {
            args: Prisma.LigneCommandePharmacieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneCommandePharmacieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>[]
          }
          delete: {
            args: Prisma.LigneCommandePharmacieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          update: {
            args: Prisma.LigneCommandePharmacieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          deleteMany: {
            args: Prisma.LigneCommandePharmacieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneCommandePharmacieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LigneCommandePharmacieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>[]
          }
          upsert: {
            args: Prisma.LigneCommandePharmacieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneCommandePharmaciePayload>
          }
          aggregate: {
            args: Prisma.LigneCommandePharmacieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneCommandePharmacie>
          }
          groupBy: {
            args: Prisma.LigneCommandePharmacieGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandePharmacieGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneCommandePharmacieCountArgs<ExtArgs>
            result: $Utils.Optional<LigneCommandePharmacieCountAggregateOutputType> | number
          }
        }
      }
      Stock: {
        payload: Prisma.$StockPayload<ExtArgs>
        fields: Prisma.StockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findFirst: {
            args: Prisma.StockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          findMany: {
            args: Prisma.StockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          create: {
            args: Prisma.StockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          createMany: {
            args: Prisma.StockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          delete: {
            args: Prisma.StockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          update: {
            args: Prisma.StockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          deleteMany: {
            args: Prisma.StockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>[]
          }
          upsert: {
            args: Prisma.StockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockPayload>
          }
          aggregate: {
            args: Prisma.StockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStock>
          }
          groupBy: {
            args: Prisma.StockGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockCountArgs<ExtArgs>
            result: $Utils.Optional<StockCountAggregateOutputType> | number
          }
        }
      }
      MouvementStock: {
        payload: Prisma.$MouvementStockPayload<ExtArgs>
        fields: Prisma.MouvementStockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MouvementStockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MouvementStockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          findFirst: {
            args: Prisma.MouvementStockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MouvementStockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          findMany: {
            args: Prisma.MouvementStockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>[]
          }
          create: {
            args: Prisma.MouvementStockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          createMany: {
            args: Prisma.MouvementStockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MouvementStockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>[]
          }
          delete: {
            args: Prisma.MouvementStockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          update: {
            args: Prisma.MouvementStockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          deleteMany: {
            args: Prisma.MouvementStockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MouvementStockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MouvementStockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>[]
          }
          upsert: {
            args: Prisma.MouvementStockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementStockPayload>
          }
          aggregate: {
            args: Prisma.MouvementStockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMouvementStock>
          }
          groupBy: {
            args: Prisma.MouvementStockGroupByArgs<ExtArgs>
            result: $Utils.Optional<MouvementStockGroupByOutputType>[]
          }
          count: {
            args: Prisma.MouvementStockCountArgs<ExtArgs>
            result: $Utils.Optional<MouvementStockCountAggregateOutputType> | number
          }
        }
      }
      Dispensation: {
        payload: Prisma.$DispensationPayload<ExtArgs>
        fields: Prisma.DispensationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DispensationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DispensationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          findFirst: {
            args: Prisma.DispensationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DispensationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          findMany: {
            args: Prisma.DispensationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>[]
          }
          create: {
            args: Prisma.DispensationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          createMany: {
            args: Prisma.DispensationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DispensationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>[]
          }
          delete: {
            args: Prisma.DispensationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          update: {
            args: Prisma.DispensationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          deleteMany: {
            args: Prisma.DispensationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DispensationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DispensationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>[]
          }
          upsert: {
            args: Prisma.DispensationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DispensationPayload>
          }
          aggregate: {
            args: Prisma.DispensationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispensation>
          }
          groupBy: {
            args: Prisma.DispensationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DispensationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DispensationCountArgs<ExtArgs>
            result: $Utils.Optional<DispensationCountAggregateOutputType> | number
          }
        }
      }
      Facture: {
        payload: Prisma.$FacturePayload<ExtArgs>
        fields: Prisma.FactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          findFirst: {
            args: Prisma.FactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          findMany: {
            args: Prisma.FactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>[]
          }
          create: {
            args: Prisma.FactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          createMany: {
            args: Prisma.FactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FactureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>[]
          }
          delete: {
            args: Prisma.FactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          update: {
            args: Prisma.FactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          deleteMany: {
            args: Prisma.FactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FactureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>[]
          }
          upsert: {
            args: Prisma.FactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FacturePayload>
          }
          aggregate: {
            args: Prisma.FactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFacture>
          }
          groupBy: {
            args: Prisma.FactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FactureCountArgs<ExtArgs>
            result: $Utils.Optional<FactureCountAggregateOutputType> | number
          }
        }
      }
      LigneFacture: {
        payload: Prisma.$LigneFacturePayload<ExtArgs>
        fields: Prisma.LigneFactureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneFactureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneFactureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          findFirst: {
            args: Prisma.LigneFactureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneFactureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          findMany: {
            args: Prisma.LigneFactureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>[]
          }
          create: {
            args: Prisma.LigneFactureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          createMany: {
            args: Prisma.LigneFactureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneFactureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>[]
          }
          delete: {
            args: Prisma.LigneFactureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          update: {
            args: Prisma.LigneFactureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          deleteMany: {
            args: Prisma.LigneFactureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneFactureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LigneFactureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>[]
          }
          upsert: {
            args: Prisma.LigneFactureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneFacturePayload>
          }
          aggregate: {
            args: Prisma.LigneFactureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneFacture>
          }
          groupBy: {
            args: Prisma.LigneFactureGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneFactureGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneFactureCountArgs<ExtArgs>
            result: $Utils.Optional<LigneFactureCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaiementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaiementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
      Lit: {
        payload: Prisma.$LitPayload<ExtArgs>
        fields: Prisma.LitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          findFirst: {
            args: Prisma.LitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          findMany: {
            args: Prisma.LitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>[]
          }
          create: {
            args: Prisma.LitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          createMany: {
            args: Prisma.LitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>[]
          }
          delete: {
            args: Prisma.LitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          update: {
            args: Prisma.LitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          deleteMany: {
            args: Prisma.LitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>[]
          }
          upsert: {
            args: Prisma.LitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LitPayload>
          }
          aggregate: {
            args: Prisma.LitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLit>
          }
          groupBy: {
            args: Prisma.LitGroupByArgs<ExtArgs>
            result: $Utils.Optional<LitGroupByOutputType>[]
          }
          count: {
            args: Prisma.LitCountArgs<ExtArgs>
            result: $Utils.Optional<LitCountAggregateOutputType> | number
          }
        }
      }
      Hospitalisation: {
        payload: Prisma.$HospitalisationPayload<ExtArgs>
        fields: Prisma.HospitalisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HospitalisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HospitalisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          findFirst: {
            args: Prisma.HospitalisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HospitalisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          findMany: {
            args: Prisma.HospitalisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>[]
          }
          create: {
            args: Prisma.HospitalisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          createMany: {
            args: Prisma.HospitalisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HospitalisationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>[]
          }
          delete: {
            args: Prisma.HospitalisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          update: {
            args: Prisma.HospitalisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          deleteMany: {
            args: Prisma.HospitalisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HospitalisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HospitalisationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>[]
          }
          upsert: {
            args: Prisma.HospitalisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HospitalisationPayload>
          }
          aggregate: {
            args: Prisma.HospitalisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHospitalisation>
          }
          groupBy: {
            args: Prisma.HospitalisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HospitalisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HospitalisationCountArgs<ExtArgs>
            result: $Utils.Optional<HospitalisationCountAggregateOutputType> | number
          }
        }
      }
      ObservationInfirmier: {
        payload: Prisma.$ObservationInfirmierPayload<ExtArgs>
        fields: Prisma.ObservationInfirmierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationInfirmierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationInfirmierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          findFirst: {
            args: Prisma.ObservationInfirmierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationInfirmierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          findMany: {
            args: Prisma.ObservationInfirmierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>[]
          }
          create: {
            args: Prisma.ObservationInfirmierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          createMany: {
            args: Prisma.ObservationInfirmierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObservationInfirmierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>[]
          }
          delete: {
            args: Prisma.ObservationInfirmierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          update: {
            args: Prisma.ObservationInfirmierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          deleteMany: {
            args: Prisma.ObservationInfirmierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationInfirmierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ObservationInfirmierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>[]
          }
          upsert: {
            args: Prisma.ObservationInfirmierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationInfirmierPayload>
          }
          aggregate: {
            args: Prisma.ObservationInfirmierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservationInfirmier>
          }
          groupBy: {
            args: Prisma.ObservationInfirmierGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationInfirmierGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationInfirmierCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationInfirmierCountAggregateOutputType> | number
          }
        }
      }
      Intervention: {
        payload: Prisma.$InterventionPayload<ExtArgs>
        fields: Prisma.InterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findFirst: {
            args: Prisma.InterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findMany: {
            args: Prisma.InterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          create: {
            args: Prisma.InterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          createMany: {
            args: Prisma.InterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          delete: {
            args: Prisma.InterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          update: {
            args: Prisma.InterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          deleteMany: {
            args: Prisma.InterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterventionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          upsert: {
            args: Prisma.InterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          aggregate: {
            args: Prisma.InterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention>
          }
          groupBy: {
            args: Prisma.InterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionCountAggregateOutputType> | number
          }
        }
      }
      DossierMaternite: {
        payload: Prisma.$DossierMaternitePayload<ExtArgs>
        fields: Prisma.DossierMaterniteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DossierMaterniteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DossierMaterniteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          findFirst: {
            args: Prisma.DossierMaterniteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DossierMaterniteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          findMany: {
            args: Prisma.DossierMaterniteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>[]
          }
          create: {
            args: Prisma.DossierMaterniteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          createMany: {
            args: Prisma.DossierMaterniteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DossierMaterniteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>[]
          }
          delete: {
            args: Prisma.DossierMaterniteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          update: {
            args: Prisma.DossierMaterniteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          deleteMany: {
            args: Prisma.DossierMaterniteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DossierMaterniteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DossierMaterniteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>[]
          }
          upsert: {
            args: Prisma.DossierMaterniteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DossierMaternitePayload>
          }
          aggregate: {
            args: Prisma.DossierMaterniteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDossierMaternite>
          }
          groupBy: {
            args: Prisma.DossierMaterniteGroupByArgs<ExtArgs>
            result: $Utils.Optional<DossierMaterniteGroupByOutputType>[]
          }
          count: {
            args: Prisma.DossierMaterniteCountArgs<ExtArgs>
            result: $Utils.Optional<DossierMaterniteCountAggregateOutputType> | number
          }
        }
      }
      NouveauNe: {
        payload: Prisma.$NouveauNePayload<ExtArgs>
        fields: Prisma.NouveauNeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NouveauNeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NouveauNeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          findFirst: {
            args: Prisma.NouveauNeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NouveauNeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          findMany: {
            args: Prisma.NouveauNeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>[]
          }
          create: {
            args: Prisma.NouveauNeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          createMany: {
            args: Prisma.NouveauNeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NouveauNeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>[]
          }
          delete: {
            args: Prisma.NouveauNeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          update: {
            args: Prisma.NouveauNeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          deleteMany: {
            args: Prisma.NouveauNeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NouveauNeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NouveauNeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>[]
          }
          upsert: {
            args: Prisma.NouveauNeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NouveauNePayload>
          }
          aggregate: {
            args: Prisma.NouveauNeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNouveauNe>
          }
          groupBy: {
            args: Prisma.NouveauNeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NouveauNeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NouveauNeCountArgs<ExtArgs>
            result: $Utils.Optional<NouveauNeCountAggregateOutputType> | number
          }
        }
      }
      ArticleLogistique: {
        payload: Prisma.$ArticleLogistiquePayload<ExtArgs>
        fields: Prisma.ArticleLogistiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleLogistiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleLogistiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          findFirst: {
            args: Prisma.ArticleLogistiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleLogistiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          findMany: {
            args: Prisma.ArticleLogistiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>[]
          }
          create: {
            args: Prisma.ArticleLogistiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          createMany: {
            args: Prisma.ArticleLogistiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleLogistiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>[]
          }
          delete: {
            args: Prisma.ArticleLogistiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          update: {
            args: Prisma.ArticleLogistiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          deleteMany: {
            args: Prisma.ArticleLogistiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleLogistiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArticleLogistiqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>[]
          }
          upsert: {
            args: Prisma.ArticleLogistiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleLogistiquePayload>
          }
          aggregate: {
            args: Prisma.ArticleLogistiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleLogistique>
          }
          groupBy: {
            args: Prisma.ArticleLogistiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleLogistiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleLogistiqueCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleLogistiqueCountAggregateOutputType> | number
          }
        }
      }
      MouvementLogistique: {
        payload: Prisma.$MouvementLogistiquePayload<ExtArgs>
        fields: Prisma.MouvementLogistiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MouvementLogistiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MouvementLogistiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          findFirst: {
            args: Prisma.MouvementLogistiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MouvementLogistiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          findMany: {
            args: Prisma.MouvementLogistiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>[]
          }
          create: {
            args: Prisma.MouvementLogistiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          createMany: {
            args: Prisma.MouvementLogistiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MouvementLogistiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>[]
          }
          delete: {
            args: Prisma.MouvementLogistiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          update: {
            args: Prisma.MouvementLogistiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          deleteMany: {
            args: Prisma.MouvementLogistiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MouvementLogistiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MouvementLogistiqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>[]
          }
          upsert: {
            args: Prisma.MouvementLogistiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementLogistiquePayload>
          }
          aggregate: {
            args: Prisma.MouvementLogistiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMouvementLogistique>
          }
          groupBy: {
            args: Prisma.MouvementLogistiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<MouvementLogistiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.MouvementLogistiqueCountArgs<ExtArgs>
            result: $Utils.Optional<MouvementLogistiqueCountAggregateOutputType> | number
          }
        }
      }
      DocumentGED: {
        payload: Prisma.$DocumentGEDPayload<ExtArgs>
        fields: Prisma.DocumentGEDFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentGEDFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentGEDFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          findFirst: {
            args: Prisma.DocumentGEDFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentGEDFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          findMany: {
            args: Prisma.DocumentGEDFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>[]
          }
          create: {
            args: Prisma.DocumentGEDCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          createMany: {
            args: Prisma.DocumentGEDCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentGEDCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>[]
          }
          delete: {
            args: Prisma.DocumentGEDDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          update: {
            args: Prisma.DocumentGEDUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          deleteMany: {
            args: Prisma.DocumentGEDDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentGEDUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentGEDUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>[]
          }
          upsert: {
            args: Prisma.DocumentGEDUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentGEDPayload>
          }
          aggregate: {
            args: Prisma.DocumentGEDAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentGED>
          }
          groupBy: {
            args: Prisma.DocumentGEDGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGEDGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentGEDCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentGEDCountAggregateOutputType> | number
          }
        }
      }
      Employe: {
        payload: Prisma.$EmployePayload<ExtArgs>
        fields: Prisma.EmployeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          findFirst: {
            args: Prisma.EmployeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          findMany: {
            args: Prisma.EmployeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>[]
          }
          create: {
            args: Prisma.EmployeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          createMany: {
            args: Prisma.EmployeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>[]
          }
          delete: {
            args: Prisma.EmployeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          update: {
            args: Prisma.EmployeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          deleteMany: {
            args: Prisma.EmployeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>[]
          }
          upsert: {
            args: Prisma.EmployeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployePayload>
          }
          aggregate: {
            args: Prisma.EmployeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploye>
          }
          groupBy: {
            args: Prisma.EmployeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeCountAggregateOutputType> | number
          }
        }
      }
      Conge: {
        payload: Prisma.$CongePayload<ExtArgs>
        fields: Prisma.CongeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CongeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CongeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          findFirst: {
            args: Prisma.CongeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CongeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          findMany: {
            args: Prisma.CongeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>[]
          }
          create: {
            args: Prisma.CongeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          createMany: {
            args: Prisma.CongeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CongeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>[]
          }
          delete: {
            args: Prisma.CongeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          update: {
            args: Prisma.CongeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          deleteMany: {
            args: Prisma.CongeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CongeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CongeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>[]
          }
          upsert: {
            args: Prisma.CongeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CongePayload>
          }
          aggregate: {
            args: Prisma.CongeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConge>
          }
          groupBy: {
            args: Prisma.CongeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CongeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CongeCountArgs<ExtArgs>
            result: $Utils.Optional<CongeCountAggregateOutputType> | number
          }
        }
      }
      BulletinPaie: {
        payload: Prisma.$BulletinPaiePayload<ExtArgs>
        fields: Prisma.BulletinPaieFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BulletinPaieFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BulletinPaieFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          findFirst: {
            args: Prisma.BulletinPaieFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BulletinPaieFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          findMany: {
            args: Prisma.BulletinPaieFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>[]
          }
          create: {
            args: Prisma.BulletinPaieCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          createMany: {
            args: Prisma.BulletinPaieCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BulletinPaieCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>[]
          }
          delete: {
            args: Prisma.BulletinPaieDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          update: {
            args: Prisma.BulletinPaieUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          deleteMany: {
            args: Prisma.BulletinPaieDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BulletinPaieUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BulletinPaieUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>[]
          }
          upsert: {
            args: Prisma.BulletinPaieUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BulletinPaiePayload>
          }
          aggregate: {
            args: Prisma.BulletinPaieAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBulletinPaie>
          }
          groupBy: {
            args: Prisma.BulletinPaieGroupByArgs<ExtArgs>
            result: $Utils.Optional<BulletinPaieGroupByOutputType>[]
          }
          count: {
            args: Prisma.BulletinPaieCountArgs<ExtArgs>
            result: $Utils.Optional<BulletinPaieCountAggregateOutputType> | number
          }
        }
      }
      LigneBulletin: {
        payload: Prisma.$LigneBulletinPayload<ExtArgs>
        fields: Prisma.LigneBulletinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LigneBulletinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LigneBulletinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          findFirst: {
            args: Prisma.LigneBulletinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LigneBulletinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          findMany: {
            args: Prisma.LigneBulletinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>[]
          }
          create: {
            args: Prisma.LigneBulletinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          createMany: {
            args: Prisma.LigneBulletinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LigneBulletinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>[]
          }
          delete: {
            args: Prisma.LigneBulletinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          update: {
            args: Prisma.LigneBulletinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          deleteMany: {
            args: Prisma.LigneBulletinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LigneBulletinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LigneBulletinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>[]
          }
          upsert: {
            args: Prisma.LigneBulletinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LigneBulletinPayload>
          }
          aggregate: {
            args: Prisma.LigneBulletinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLigneBulletin>
          }
          groupBy: {
            args: Prisma.LigneBulletinGroupByArgs<ExtArgs>
            result: $Utils.Optional<LigneBulletinGroupByOutputType>[]
          }
          count: {
            args: Prisma.LigneBulletinCountArgs<ExtArgs>
            result: $Utils.Optional<LigneBulletinCountAggregateOutputType> | number
          }
        }
      }
      Planning: {
        payload: Prisma.$PlanningPayload<ExtArgs>
        fields: Prisma.PlanningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findFirst: {
            args: Prisma.PlanningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          findMany: {
            args: Prisma.PlanningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          create: {
            args: Prisma.PlanningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          createMany: {
            args: Prisma.PlanningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          delete: {
            args: Prisma.PlanningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          update: {
            args: Prisma.PlanningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          deleteMany: {
            args: Prisma.PlanningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>[]
          }
          upsert: {
            args: Prisma.PlanningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanningPayload>
          }
          aggregate: {
            args: Prisma.PlanningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanning>
          }
          groupBy: {
            args: Prisma.PlanningGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanningGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanningCountArgs<ExtArgs>
            result: $Utils.Optional<PlanningCountAggregateOutputType> | number
          }
        }
      }
      Equipement: {
        payload: Prisma.$EquipementPayload<ExtArgs>
        fields: Prisma.EquipementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findFirst: {
            args: Prisma.EquipementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          findMany: {
            args: Prisma.EquipementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          create: {
            args: Prisma.EquipementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          createMany: {
            args: Prisma.EquipementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          delete: {
            args: Prisma.EquipementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          update: {
            args: Prisma.EquipementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          deleteMany: {
            args: Prisma.EquipementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>[]
          }
          upsert: {
            args: Prisma.EquipementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipementPayload>
          }
          aggregate: {
            args: Prisma.EquipementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipement>
          }
          groupBy: {
            args: Prisma.EquipementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipementCountArgs<ExtArgs>
            result: $Utils.Optional<EquipementCountAggregateOutputType> | number
          }
        }
      }
      TicketMaintenance: {
        payload: Prisma.$TicketMaintenancePayload<ExtArgs>
        fields: Prisma.TicketMaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketMaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketMaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          findFirst: {
            args: Prisma.TicketMaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketMaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          findMany: {
            args: Prisma.TicketMaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>[]
          }
          create: {
            args: Prisma.TicketMaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          createMany: {
            args: Prisma.TicketMaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketMaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>[]
          }
          delete: {
            args: Prisma.TicketMaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          update: {
            args: Prisma.TicketMaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          deleteMany: {
            args: Prisma.TicketMaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketMaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketMaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>[]
          }
          upsert: {
            args: Prisma.TicketMaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketMaintenancePayload>
          }
          aggregate: {
            args: Prisma.TicketMaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketMaintenance>
          }
          groupBy: {
            args: Prisma.TicketMaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketMaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketMaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<TicketMaintenanceCountAggregateOutputType> | number
          }
        }
      }
      EvenementIndesirable: {
        payload: Prisma.$EvenementIndesirablePayload<ExtArgs>
        fields: Prisma.EvenementIndesirableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvenementIndesirableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvenementIndesirableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          findFirst: {
            args: Prisma.EvenementIndesirableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvenementIndesirableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          findMany: {
            args: Prisma.EvenementIndesirableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>[]
          }
          create: {
            args: Prisma.EvenementIndesirableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          createMany: {
            args: Prisma.EvenementIndesirableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvenementIndesirableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>[]
          }
          delete: {
            args: Prisma.EvenementIndesirableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          update: {
            args: Prisma.EvenementIndesirableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          deleteMany: {
            args: Prisma.EvenementIndesirableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvenementIndesirableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvenementIndesirableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>[]
          }
          upsert: {
            args: Prisma.EvenementIndesirableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvenementIndesirablePayload>
          }
          aggregate: {
            args: Prisma.EvenementIndesirableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvenementIndesirable>
          }
          groupBy: {
            args: Prisma.EvenementIndesirableGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvenementIndesirableGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvenementIndesirableCountArgs<ExtArgs>
            result: $Utils.Optional<EvenementIndesirableCountAggregateOutputType> | number
          }
        }
      }
      AuditQualite: {
        payload: Prisma.$AuditQualitePayload<ExtArgs>
        fields: Prisma.AuditQualiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditQualiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditQualiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          findFirst: {
            args: Prisma.AuditQualiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditQualiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          findMany: {
            args: Prisma.AuditQualiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>[]
          }
          create: {
            args: Prisma.AuditQualiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          createMany: {
            args: Prisma.AuditQualiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditQualiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>[]
          }
          delete: {
            args: Prisma.AuditQualiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          update: {
            args: Prisma.AuditQualiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          deleteMany: {
            args: Prisma.AuditQualiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditQualiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditQualiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>[]
          }
          upsert: {
            args: Prisma.AuditQualiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditQualitePayload>
          }
          aggregate: {
            args: Prisma.AuditQualiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditQualite>
          }
          groupBy: {
            args: Prisma.AuditQualiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditQualiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditQualiteCountArgs<ExtArgs>
            result: $Utils.Optional<AuditQualiteCountAggregateOutputType> | number
          }
        }
      }
      Configuration: {
        payload: Prisma.$ConfigurationPayload<ExtArgs>
        fields: Prisma.ConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findFirst: {
            args: Prisma.ConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          findMany: {
            args: Prisma.ConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          create: {
            args: Prisma.ConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          createMany: {
            args: Prisma.ConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigurationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          delete: {
            args: Prisma.ConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          update: {
            args: Prisma.ConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.ConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigurationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>[]
          }
          upsert: {
            args: Prisma.ConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigurationPayload>
          }
          aggregate: {
            args: Prisma.ConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguration>
          }
          groupBy: {
            args: Prisma.ConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigurationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    role?: RoleOmit
    permission?: PermissionOmit
    auditLog?: AuditLogOmit
    compteComptable?: CompteComptableOmit
    journal?: JournalOmit
    exerciceComptable?: ExerciceComptableOmit
    ecritureComptable?: EcritureComptableOmit
    centreAnalytique?: CentreAnalytiqueOmit
    budget?: BudgetOmit
    patient?: PatientOmit
    antecedent?: AntecedentOmit
    allergie?: AllergieOmit
    vaccination?: VaccinationOmit
    rendezVous?: RendezVousOmit
    consultation?: ConsultationOmit
    prescription?: PrescriptionOmit
    nomenclatureActe?: NomenclatureActeOmit
    acteRealise?: ActeRealiseOmit
    resultatExamen?: ResultatExamenOmit
    medicament?: MedicamentOmit
    fournisseur?: FournisseurOmit
    commandePharmacie?: CommandePharmacieOmit
    ligneCommandePharmacie?: LigneCommandePharmacieOmit
    stock?: StockOmit
    mouvementStock?: MouvementStockOmit
    dispensation?: DispensationOmit
    facture?: FactureOmit
    ligneFacture?: LigneFactureOmit
    paiement?: PaiementOmit
    lit?: LitOmit
    hospitalisation?: HospitalisationOmit
    observationInfirmier?: ObservationInfirmierOmit
    intervention?: InterventionOmit
    dossierMaternite?: DossierMaterniteOmit
    nouveauNe?: NouveauNeOmit
    articleLogistique?: ArticleLogistiqueOmit
    mouvementLogistique?: MouvementLogistiqueOmit
    documentGED?: DocumentGEDOmit
    employe?: EmployeOmit
    conge?: CongeOmit
    bulletinPaie?: BulletinPaieOmit
    ligneBulletin?: LigneBulletinOmit
    planning?: PlanningOmit
    equipement?: EquipementOmit
    ticketMaintenance?: TicketMaintenanceOmit
    evenementIndesirable?: EvenementIndesirableOmit
    auditQualite?: AuditQualiteOmit
    configuration?: ConfigurationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    consultations: number
    rendezvous: number
    ecritures: number
    paiements: number
    auditLogs: number
    observationsCrees: number
    chirurgies: number
    anesthesies: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultations?: boolean | UserCountOutputTypeCountConsultationsArgs
    rendezvous?: boolean | UserCountOutputTypeCountRendezvousArgs
    ecritures?: boolean | UserCountOutputTypeCountEcrituresArgs
    paiements?: boolean | UserCountOutputTypeCountPaiementsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    observationsCrees?: boolean | UserCountOutputTypeCountObservationsCreesArgs
    chirurgies?: boolean | UserCountOutputTypeCountChirurgiesArgs
    anesthesies?: boolean | UserCountOutputTypeCountAnesthesiesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRendezvousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RendezVousWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEcrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountObservationsCreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationInfirmierWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChirurgiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnesthesiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
  }


  /**
   * Count Type CompteComptableCountOutputType
   */

  export type CompteComptableCountOutputType = {
    ecritures: number
  }

  export type CompteComptableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | CompteComptableCountOutputTypeCountEcrituresArgs
  }

  // Custom InputTypes
  /**
   * CompteComptableCountOutputType without action
   */
  export type CompteComptableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptableCountOutputType
     */
    select?: CompteComptableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompteComptableCountOutputType without action
   */
  export type CompteComptableCountOutputTypeCountEcrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
  }


  /**
   * Count Type JournalCountOutputType
   */

  export type JournalCountOutputType = {
    ecritures: number
  }

  export type JournalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | JournalCountOutputTypeCountEcrituresArgs
  }

  // Custom InputTypes
  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalCountOutputType
     */
    select?: JournalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JournalCountOutputType without action
   */
  export type JournalCountOutputTypeCountEcrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
  }


  /**
   * Count Type ExerciceComptableCountOutputType
   */

  export type ExerciceComptableCountOutputType = {
    ecritures: number
    budgets: number
  }

  export type ExerciceComptableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | ExerciceComptableCountOutputTypeCountEcrituresArgs
    budgets?: boolean | ExerciceComptableCountOutputTypeCountBudgetsArgs
  }

  // Custom InputTypes
  /**
   * ExerciceComptableCountOutputType without action
   */
  export type ExerciceComptableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptableCountOutputType
     */
    select?: ExerciceComptableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciceComptableCountOutputType without action
   */
  export type ExerciceComptableCountOutputTypeCountEcrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
  }

  /**
   * ExerciceComptableCountOutputType without action
   */
  export type ExerciceComptableCountOutputTypeCountBudgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
  }


  /**
   * Count Type CentreAnalytiqueCountOutputType
   */

  export type CentreAnalytiqueCountOutputType = {
    ecritures: number
  }

  export type CentreAnalytiqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | CentreAnalytiqueCountOutputTypeCountEcrituresArgs
  }

  // Custom InputTypes
  /**
   * CentreAnalytiqueCountOutputType without action
   */
  export type CentreAnalytiqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytiqueCountOutputType
     */
    select?: CentreAnalytiqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CentreAnalytiqueCountOutputType without action
   */
  export type CentreAnalytiqueCountOutputTypeCountEcrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    antecedents: number
    allergies: number
    vaccinations: number
    consultations: number
    rendezvous: number
    factures: number
    dispensations: number
    hospitalisations: number
    interventions: number
    dossiersMaternite: number
    documentsGED: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    antecedents?: boolean | PatientCountOutputTypeCountAntecedentsArgs
    allergies?: boolean | PatientCountOutputTypeCountAllergiesArgs
    vaccinations?: boolean | PatientCountOutputTypeCountVaccinationsArgs
    consultations?: boolean | PatientCountOutputTypeCountConsultationsArgs
    rendezvous?: boolean | PatientCountOutputTypeCountRendezvousArgs
    factures?: boolean | PatientCountOutputTypeCountFacturesArgs
    dispensations?: boolean | PatientCountOutputTypeCountDispensationsArgs
    hospitalisations?: boolean | PatientCountOutputTypeCountHospitalisationsArgs
    interventions?: boolean | PatientCountOutputTypeCountInterventionsArgs
    dossiersMaternite?: boolean | PatientCountOutputTypeCountDossiersMaterniteArgs
    documentsGED?: boolean | PatientCountOutputTypeCountDocumentsGEDArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAntecedentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAllergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergieWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountRendezvousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RendezVousWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountFacturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDispensationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispensationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountHospitalisationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalisationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDossiersMaterniteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DossierMaterniteWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDocumentsGEDArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentGEDWhereInput
  }


  /**
   * Count Type ConsultationCountOutputType
   */

  export type ConsultationCountOutputType = {
    prescriptions: number
    actesRealises: number
  }

  export type ConsultationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptions?: boolean | ConsultationCountOutputTypeCountPrescriptionsArgs
    actesRealises?: boolean | ConsultationCountOutputTypeCountActesRealisesArgs
  }

  // Custom InputTypes
  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConsultationCountOutputType
     */
    select?: ConsultationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * ConsultationCountOutputType without action
   */
  export type ConsultationCountOutputTypeCountActesRealisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActeRealiseWhereInput
  }


  /**
   * Count Type NomenclatureActeCountOutputType
   */

  export type NomenclatureActeCountOutputType = {
    actes: number
  }

  export type NomenclatureActeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actes?: boolean | NomenclatureActeCountOutputTypeCountActesArgs
  }

  // Custom InputTypes
  /**
   * NomenclatureActeCountOutputType without action
   */
  export type NomenclatureActeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActeCountOutputType
     */
    select?: NomenclatureActeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NomenclatureActeCountOutputType without action
   */
  export type NomenclatureActeCountOutputTypeCountActesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActeRealiseWhereInput
  }


  /**
   * Count Type MedicamentCountOutputType
   */

  export type MedicamentCountOutputType = {
    stocks: number
    mouvements: number
    dispensations: number
    commandes: number
  }

  export type MedicamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | MedicamentCountOutputTypeCountStocksArgs
    mouvements?: boolean | MedicamentCountOutputTypeCountMouvementsArgs
    dispensations?: boolean | MedicamentCountOutputTypeCountDispensationsArgs
    commandes?: boolean | MedicamentCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicamentCountOutputType
     */
    select?: MedicamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountStocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountMouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementStockWhereInput
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountDispensationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispensationWhereInput
  }

  /**
   * MedicamentCountOutputType without action
   */
  export type MedicamentCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandePharmacieWhereInput
  }


  /**
   * Count Type FournisseurCountOutputType
   */

  export type FournisseurCountOutputType = {
    commandes: number
  }

  export type FournisseurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandes?: boolean | FournisseurCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FournisseurCountOutputType
     */
    select?: FournisseurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandePharmacieWhereInput
  }


  /**
   * Count Type CommandePharmacieCountOutputType
   */

  export type CommandePharmacieCountOutputType = {
    lignes: number
  }

  export type CommandePharmacieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | CommandePharmacieCountOutputTypeCountLignesArgs
  }

  // Custom InputTypes
  /**
   * CommandePharmacieCountOutputType without action
   */
  export type CommandePharmacieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacieCountOutputType
     */
    select?: CommandePharmacieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandePharmacieCountOutputType without action
   */
  export type CommandePharmacieCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandePharmacieWhereInput
  }


  /**
   * Count Type FactureCountOutputType
   */

  export type FactureCountOutputType = {
    lignes: number
    paiements: number
    consultations: number
  }

  export type FactureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | FactureCountOutputTypeCountLignesArgs
    paiements?: boolean | FactureCountOutputTypeCountPaiementsArgs
    consultations?: boolean | FactureCountOutputTypeCountConsultationsArgs
  }

  // Custom InputTypes
  /**
   * FactureCountOutputType without action
   */
  export type FactureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FactureCountOutputType
     */
    select?: FactureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FactureCountOutputType without action
   */
  export type FactureCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneFactureWhereInput
  }

  /**
   * FactureCountOutputType without action
   */
  export type FactureCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * FactureCountOutputType without action
   */
  export type FactureCountOutputTypeCountConsultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
  }


  /**
   * Count Type LitCountOutputType
   */

  export type LitCountOutputType = {
    hospitalisations: number
  }

  export type LitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospitalisations?: boolean | LitCountOutputTypeCountHospitalisationsArgs
  }

  // Custom InputTypes
  /**
   * LitCountOutputType without action
   */
  export type LitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LitCountOutputType
     */
    select?: LitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LitCountOutputType without action
   */
  export type LitCountOutputTypeCountHospitalisationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalisationWhereInput
  }


  /**
   * Count Type HospitalisationCountOutputType
   */

  export type HospitalisationCountOutputType = {
    observations: number
  }

  export type HospitalisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    observations?: boolean | HospitalisationCountOutputTypeCountObservationsArgs
  }

  // Custom InputTypes
  /**
   * HospitalisationCountOutputType without action
   */
  export type HospitalisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HospitalisationCountOutputType
     */
    select?: HospitalisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HospitalisationCountOutputType without action
   */
  export type HospitalisationCountOutputTypeCountObservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationInfirmierWhereInput
  }


  /**
   * Count Type DossierMaterniteCountOutputType
   */

  export type DossierMaterniteCountOutputType = {
    nouveauNes: number
  }

  export type DossierMaterniteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nouveauNes?: boolean | DossierMaterniteCountOutputTypeCountNouveauNesArgs
  }

  // Custom InputTypes
  /**
   * DossierMaterniteCountOutputType without action
   */
  export type DossierMaterniteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaterniteCountOutputType
     */
    select?: DossierMaterniteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DossierMaterniteCountOutputType without action
   */
  export type DossierMaterniteCountOutputTypeCountNouveauNesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NouveauNeWhereInput
  }


  /**
   * Count Type ArticleLogistiqueCountOutputType
   */

  export type ArticleLogistiqueCountOutputType = {
    mouvements: number
  }

  export type ArticleLogistiqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mouvements?: boolean | ArticleLogistiqueCountOutputTypeCountMouvementsArgs
  }

  // Custom InputTypes
  /**
   * ArticleLogistiqueCountOutputType without action
   */
  export type ArticleLogistiqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistiqueCountOutputType
     */
    select?: ArticleLogistiqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArticleLogistiqueCountOutputType without action
   */
  export type ArticleLogistiqueCountOutputTypeCountMouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementLogistiqueWhereInput
  }


  /**
   * Count Type EmployeCountOutputType
   */

  export type EmployeCountOutputType = {
    conges: number
    plannings: number
    bulletins: number
  }

  export type EmployeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conges?: boolean | EmployeCountOutputTypeCountCongesArgs
    plannings?: boolean | EmployeCountOutputTypeCountPlanningsArgs
    bulletins?: boolean | EmployeCountOutputTypeCountBulletinsArgs
  }

  // Custom InputTypes
  /**
   * EmployeCountOutputType without action
   */
  export type EmployeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeCountOutputType
     */
    select?: EmployeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeCountOutputType without action
   */
  export type EmployeCountOutputTypeCountCongesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CongeWhereInput
  }

  /**
   * EmployeCountOutputType without action
   */
  export type EmployeCountOutputTypeCountPlanningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
  }

  /**
   * EmployeCountOutputType without action
   */
  export type EmployeCountOutputTypeCountBulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulletinPaieWhereInput
  }


  /**
   * Count Type BulletinPaieCountOutputType
   */

  export type BulletinPaieCountOutputType = {
    lignes: number
  }

  export type BulletinPaieCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lignes?: boolean | BulletinPaieCountOutputTypeCountLignesArgs
  }

  // Custom InputTypes
  /**
   * BulletinPaieCountOutputType without action
   */
  export type BulletinPaieCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaieCountOutputType
     */
    select?: BulletinPaieCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BulletinPaieCountOutputType without action
   */
  export type BulletinPaieCountOutputTypeCountLignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneBulletinWhereInput
  }


  /**
   * Count Type EquipementCountOutputType
   */

  export type EquipementCountOutputType = {
    tickets: number
  }

  export type EquipementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | EquipementCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipementCountOutputType
     */
    select?: EquipementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipementCountOutputType without action
   */
  export type EquipementCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMaintenanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nom: string | null
    prenom: string | null
    telephone: string | null
    photo: string | null
    actif: boolean | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nom: string | null
    prenom: string | null
    telephone: string | null
    photo: string | null
    actif: boolean | null
    roleId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    nom: number
    prenom: number
    telephone: number
    photo: number
    actif: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nom?: true
    prenom?: true
    telephone?: true
    photo?: true
    actif?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nom?: true
    prenom?: true
    telephone?: true
    photo?: true
    actif?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nom?: true
    prenom?: true
    telephone?: true
    photo?: true
    actif?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone: string | null
    photo: string | null
    actif: boolean
    roleId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nom?: boolean
    prenom?: boolean
    telephone?: boolean
    photo?: boolean
    actif?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    consultations?: boolean | User$consultationsArgs<ExtArgs>
    rendezvous?: boolean | User$rendezvousArgs<ExtArgs>
    ecritures?: boolean | User$ecrituresArgs<ExtArgs>
    paiements?: boolean | User$paiementsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    observationsCrees?: boolean | User$observationsCreesArgs<ExtArgs>
    chirurgies?: boolean | User$chirurgiesArgs<ExtArgs>
    anesthesies?: boolean | User$anesthesiesArgs<ExtArgs>
    employe?: boolean | User$employeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nom?: boolean
    prenom?: boolean
    telephone?: boolean
    photo?: boolean
    actif?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nom?: boolean
    prenom?: boolean
    telephone?: boolean
    photo?: boolean
    actif?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    nom?: boolean
    prenom?: boolean
    telephone?: boolean
    photo?: boolean
    actif?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "nom" | "prenom" | "telephone" | "photo" | "actif" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    consultations?: boolean | User$consultationsArgs<ExtArgs>
    rendezvous?: boolean | User$rendezvousArgs<ExtArgs>
    ecritures?: boolean | User$ecrituresArgs<ExtArgs>
    paiements?: boolean | User$paiementsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    observationsCrees?: boolean | User$observationsCreesArgs<ExtArgs>
    chirurgies?: boolean | User$chirurgiesArgs<ExtArgs>
    anesthesies?: boolean | User$anesthesiesArgs<ExtArgs>
    employe?: boolean | User$employeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      rendezvous: Prisma.$RendezVousPayload<ExtArgs>[]
      ecritures: Prisma.$EcritureComptablePayload<ExtArgs>[]
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      observationsCrees: Prisma.$ObservationInfirmierPayload<ExtArgs>[]
      chirurgies: Prisma.$InterventionPayload<ExtArgs>[]
      anesthesies: Prisma.$InterventionPayload<ExtArgs>[]
      employe: Prisma.$EmployePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      nom: string
      prenom: string
      telephone: string | null
      photo: string | null
      actif: boolean
      roleId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    consultations<T extends User$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, User$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rendezvous<T extends User$rendezvousArgs<ExtArgs> = {}>(args?: Subset<T, User$rendezvousArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    ecritures<T extends User$ecrituresArgs<ExtArgs> = {}>(args?: Subset<T, User$ecrituresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    paiements<T extends User$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, User$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    observationsCrees<T extends User$observationsCreesArgs<ExtArgs> = {}>(args?: Subset<T, User$observationsCreesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chirurgies<T extends User$chirurgiesArgs<ExtArgs> = {}>(args?: Subset<T, User$chirurgiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    anesthesies<T extends User$anesthesiesArgs<ExtArgs> = {}>(args?: Subset<T, User$anesthesiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    employe<T extends User$employeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly nom: FieldRef<"User", 'String'>
    readonly prenom: FieldRef<"User", 'String'>
    readonly telephone: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly actif: FieldRef<"User", 'Boolean'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.consultations
   */
  export type User$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * User.rendezvous
   */
  export type User$rendezvousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    where?: RendezVousWhereInput
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    cursor?: RendezVousWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RendezVousScalarFieldEnum | RendezVousScalarFieldEnum[]
  }

  /**
   * User.ecritures
   */
  export type User$ecrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    cursor?: EcritureComptableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * User.paiements
   */
  export type User$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.observationsCrees
   */
  export type User$observationsCreesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    where?: ObservationInfirmierWhereInput
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    cursor?: ObservationInfirmierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationInfirmierScalarFieldEnum | ObservationInfirmierScalarFieldEnum[]
  }

  /**
   * User.chirurgies
   */
  export type User$chirurgiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * User.anesthesies
   */
  export type User$anesthesiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * User.employe
   */
  export type User$employeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    where?: EmployeWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    nom: string
    description: string | null
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    createdAt?: boolean
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "createdAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */ 
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly nom: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    module: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    module: string | null
    action: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    module: number
    action: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    module?: true
    action?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    module?: true
    action?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    module?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    nom: string
    description: string | null
    module: string
    action: string
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    module?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "module" | "action" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      description: string | null
      module: string
      action: string
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly nom: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly module: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    cursor?: RoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    module: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    module: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    module: number
    entityType: number
    entityId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    module?: true
    entityType?: true
    entityId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    module: string
    entityType: string
    entityId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    module?: boolean
    entityType?: boolean
    entityId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "module" | "entityType" | "entityId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      module: string
      entityType: string
      entityId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly module: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model CompteComptable
   */

  export type AggregateCompteComptable = {
    _count: CompteComptableCountAggregateOutputType | null
    _avg: CompteComptableAvgAggregateOutputType | null
    _sum: CompteComptableSumAggregateOutputType | null
    _min: CompteComptableMinAggregateOutputType | null
    _max: CompteComptableMaxAggregateOutputType | null
  }

  export type CompteComptableAvgAggregateOutputType = {
    classe: number | null
  }

  export type CompteComptableSumAggregateOutputType = {
    classe: number | null
  }

  export type CompteComptableMinAggregateOutputType = {
    id: string | null
    numero: string | null
    libelle: string | null
    classe: number | null
    type: string | null
    sens: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompteComptableMaxAggregateOutputType = {
    id: string | null
    numero: string | null
    libelle: string | null
    classe: number | null
    type: string | null
    sens: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompteComptableCountAggregateOutputType = {
    id: number
    numero: number
    libelle: number
    classe: number
    type: number
    sens: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompteComptableAvgAggregateInputType = {
    classe?: true
  }

  export type CompteComptableSumAggregateInputType = {
    classe?: true
  }

  export type CompteComptableMinAggregateInputType = {
    id?: true
    numero?: true
    libelle?: true
    classe?: true
    type?: true
    sens?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompteComptableMaxAggregateInputType = {
    id?: true
    numero?: true
    libelle?: true
    classe?: true
    type?: true
    sens?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompteComptableCountAggregateInputType = {
    id?: true
    numero?: true
    libelle?: true
    classe?: true
    type?: true
    sens?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompteComptableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompteComptable to aggregate.
     */
    where?: CompteComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompteComptables to fetch.
     */
    orderBy?: CompteComptableOrderByWithRelationInput | CompteComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompteComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompteComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompteComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompteComptables
    **/
    _count?: true | CompteComptableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompteComptableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompteComptableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompteComptableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompteComptableMaxAggregateInputType
  }

  export type GetCompteComptableAggregateType<T extends CompteComptableAggregateArgs> = {
        [P in keyof T & keyof AggregateCompteComptable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompteComptable[P]>
      : GetScalarType<T[P], AggregateCompteComptable[P]>
  }




  export type CompteComptableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompteComptableWhereInput
    orderBy?: CompteComptableOrderByWithAggregationInput | CompteComptableOrderByWithAggregationInput[]
    by: CompteComptableScalarFieldEnum[] | CompteComptableScalarFieldEnum
    having?: CompteComptableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompteComptableCountAggregateInputType | true
    _avg?: CompteComptableAvgAggregateInputType
    _sum?: CompteComptableSumAggregateInputType
    _min?: CompteComptableMinAggregateInputType
    _max?: CompteComptableMaxAggregateInputType
  }

  export type CompteComptableGroupByOutputType = {
    id: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: CompteComptableCountAggregateOutputType | null
    _avg: CompteComptableAvgAggregateOutputType | null
    _sum: CompteComptableSumAggregateOutputType | null
    _min: CompteComptableMinAggregateOutputType | null
    _max: CompteComptableMaxAggregateOutputType | null
  }

  type GetCompteComptableGroupByPayload<T extends CompteComptableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompteComptableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompteComptableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompteComptableGroupByOutputType[P]>
            : GetScalarType<T[P], CompteComptableGroupByOutputType[P]>
        }
      >
    >


  export type CompteComptableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    libelle?: boolean
    classe?: boolean
    type?: boolean
    sens?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ecritures?: boolean | CompteComptable$ecrituresArgs<ExtArgs>
    _count?: boolean | CompteComptableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compteComptable"]>

  export type CompteComptableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    libelle?: boolean
    classe?: boolean
    type?: boolean
    sens?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["compteComptable"]>

  export type CompteComptableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    libelle?: boolean
    classe?: boolean
    type?: boolean
    sens?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["compteComptable"]>

  export type CompteComptableSelectScalar = {
    id?: boolean
    numero?: boolean
    libelle?: boolean
    classe?: boolean
    type?: boolean
    sens?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompteComptableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numero" | "libelle" | "classe" | "type" | "sens" | "actif" | "createdAt" | "updatedAt", ExtArgs["result"]["compteComptable"]>
  export type CompteComptableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | CompteComptable$ecrituresArgs<ExtArgs>
    _count?: boolean | CompteComptableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompteComptableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompteComptableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompteComptablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompteComptable"
    objects: {
      ecritures: Prisma.$EcritureComptablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numero: string
      libelle: string
      classe: number
      type: string
      sens: string
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["compteComptable"]>
    composites: {}
  }

  type CompteComptableGetPayload<S extends boolean | null | undefined | CompteComptableDefaultArgs> = $Result.GetResult<Prisma.$CompteComptablePayload, S>

  type CompteComptableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompteComptableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompteComptableCountAggregateInputType | true
    }

  export interface CompteComptableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompteComptable'], meta: { name: 'CompteComptable' } }
    /**
     * Find zero or one CompteComptable that matches the filter.
     * @param {CompteComptableFindUniqueArgs} args - Arguments to find a CompteComptable
     * @example
     * // Get one CompteComptable
     * const compteComptable = await prisma.compteComptable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompteComptableFindUniqueArgs>(args: SelectSubset<T, CompteComptableFindUniqueArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CompteComptable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompteComptableFindUniqueOrThrowArgs} args - Arguments to find a CompteComptable
     * @example
     * // Get one CompteComptable
     * const compteComptable = await prisma.compteComptable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompteComptableFindUniqueOrThrowArgs>(args: SelectSubset<T, CompteComptableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CompteComptable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableFindFirstArgs} args - Arguments to find a CompteComptable
     * @example
     * // Get one CompteComptable
     * const compteComptable = await prisma.compteComptable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompteComptableFindFirstArgs>(args?: SelectSubset<T, CompteComptableFindFirstArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CompteComptable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableFindFirstOrThrowArgs} args - Arguments to find a CompteComptable
     * @example
     * // Get one CompteComptable
     * const compteComptable = await prisma.compteComptable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompteComptableFindFirstOrThrowArgs>(args?: SelectSubset<T, CompteComptableFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CompteComptables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompteComptables
     * const compteComptables = await prisma.compteComptable.findMany()
     * 
     * // Get first 10 CompteComptables
     * const compteComptables = await prisma.compteComptable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const compteComptableWithIdOnly = await prisma.compteComptable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompteComptableFindManyArgs>(args?: SelectSubset<T, CompteComptableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CompteComptable.
     * @param {CompteComptableCreateArgs} args - Arguments to create a CompteComptable.
     * @example
     * // Create one CompteComptable
     * const CompteComptable = await prisma.compteComptable.create({
     *   data: {
     *     // ... data to create a CompteComptable
     *   }
     * })
     * 
     */
    create<T extends CompteComptableCreateArgs>(args: SelectSubset<T, CompteComptableCreateArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CompteComptables.
     * @param {CompteComptableCreateManyArgs} args - Arguments to create many CompteComptables.
     * @example
     * // Create many CompteComptables
     * const compteComptable = await prisma.compteComptable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompteComptableCreateManyArgs>(args?: SelectSubset<T, CompteComptableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompteComptables and returns the data saved in the database.
     * @param {CompteComptableCreateManyAndReturnArgs} args - Arguments to create many CompteComptables.
     * @example
     * // Create many CompteComptables
     * const compteComptable = await prisma.compteComptable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompteComptables and only return the `id`
     * const compteComptableWithIdOnly = await prisma.compteComptable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompteComptableCreateManyAndReturnArgs>(args?: SelectSubset<T, CompteComptableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CompteComptable.
     * @param {CompteComptableDeleteArgs} args - Arguments to delete one CompteComptable.
     * @example
     * // Delete one CompteComptable
     * const CompteComptable = await prisma.compteComptable.delete({
     *   where: {
     *     // ... filter to delete one CompteComptable
     *   }
     * })
     * 
     */
    delete<T extends CompteComptableDeleteArgs>(args: SelectSubset<T, CompteComptableDeleteArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CompteComptable.
     * @param {CompteComptableUpdateArgs} args - Arguments to update one CompteComptable.
     * @example
     * // Update one CompteComptable
     * const compteComptable = await prisma.compteComptable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompteComptableUpdateArgs>(args: SelectSubset<T, CompteComptableUpdateArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CompteComptables.
     * @param {CompteComptableDeleteManyArgs} args - Arguments to filter CompteComptables to delete.
     * @example
     * // Delete a few CompteComptables
     * const { count } = await prisma.compteComptable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompteComptableDeleteManyArgs>(args?: SelectSubset<T, CompteComptableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompteComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompteComptables
     * const compteComptable = await prisma.compteComptable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompteComptableUpdateManyArgs>(args: SelectSubset<T, CompteComptableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompteComptables and returns the data updated in the database.
     * @param {CompteComptableUpdateManyAndReturnArgs} args - Arguments to update many CompteComptables.
     * @example
     * // Update many CompteComptables
     * const compteComptable = await prisma.compteComptable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompteComptables and only return the `id`
     * const compteComptableWithIdOnly = await prisma.compteComptable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompteComptableUpdateManyAndReturnArgs>(args: SelectSubset<T, CompteComptableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CompteComptable.
     * @param {CompteComptableUpsertArgs} args - Arguments to update or create a CompteComptable.
     * @example
     * // Update or create a CompteComptable
     * const compteComptable = await prisma.compteComptable.upsert({
     *   create: {
     *     // ... data to create a CompteComptable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompteComptable we want to update
     *   }
     * })
     */
    upsert<T extends CompteComptableUpsertArgs>(args: SelectSubset<T, CompteComptableUpsertArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CompteComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableCountArgs} args - Arguments to filter CompteComptables to count.
     * @example
     * // Count the number of CompteComptables
     * const count = await prisma.compteComptable.count({
     *   where: {
     *     // ... the filter for the CompteComptables we want to count
     *   }
     * })
    **/
    count<T extends CompteComptableCountArgs>(
      args?: Subset<T, CompteComptableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompteComptableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompteComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompteComptableAggregateArgs>(args: Subset<T, CompteComptableAggregateArgs>): Prisma.PrismaPromise<GetCompteComptableAggregateType<T>>

    /**
     * Group by CompteComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompteComptableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompteComptableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompteComptableGroupByArgs['orderBy'] }
        : { orderBy?: CompteComptableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompteComptableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompteComptableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompteComptable model
   */
  readonly fields: CompteComptableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompteComptable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompteComptableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ecritures<T extends CompteComptable$ecrituresArgs<ExtArgs> = {}>(args?: Subset<T, CompteComptable$ecrituresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompteComptable model
   */ 
  interface CompteComptableFieldRefs {
    readonly id: FieldRef<"CompteComptable", 'String'>
    readonly numero: FieldRef<"CompteComptable", 'String'>
    readonly libelle: FieldRef<"CompteComptable", 'String'>
    readonly classe: FieldRef<"CompteComptable", 'Int'>
    readonly type: FieldRef<"CompteComptable", 'String'>
    readonly sens: FieldRef<"CompteComptable", 'String'>
    readonly actif: FieldRef<"CompteComptable", 'Boolean'>
    readonly createdAt: FieldRef<"CompteComptable", 'DateTime'>
    readonly updatedAt: FieldRef<"CompteComptable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompteComptable findUnique
   */
  export type CompteComptableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter, which CompteComptable to fetch.
     */
    where: CompteComptableWhereUniqueInput
  }

  /**
   * CompteComptable findUniqueOrThrow
   */
  export type CompteComptableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter, which CompteComptable to fetch.
     */
    where: CompteComptableWhereUniqueInput
  }

  /**
   * CompteComptable findFirst
   */
  export type CompteComptableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter, which CompteComptable to fetch.
     */
    where?: CompteComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompteComptables to fetch.
     */
    orderBy?: CompteComptableOrderByWithRelationInput | CompteComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompteComptables.
     */
    cursor?: CompteComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompteComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompteComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompteComptables.
     */
    distinct?: CompteComptableScalarFieldEnum | CompteComptableScalarFieldEnum[]
  }

  /**
   * CompteComptable findFirstOrThrow
   */
  export type CompteComptableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter, which CompteComptable to fetch.
     */
    where?: CompteComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompteComptables to fetch.
     */
    orderBy?: CompteComptableOrderByWithRelationInput | CompteComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompteComptables.
     */
    cursor?: CompteComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompteComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompteComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompteComptables.
     */
    distinct?: CompteComptableScalarFieldEnum | CompteComptableScalarFieldEnum[]
  }

  /**
   * CompteComptable findMany
   */
  export type CompteComptableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter, which CompteComptables to fetch.
     */
    where?: CompteComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompteComptables to fetch.
     */
    orderBy?: CompteComptableOrderByWithRelationInput | CompteComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompteComptables.
     */
    cursor?: CompteComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompteComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompteComptables.
     */
    skip?: number
    distinct?: CompteComptableScalarFieldEnum | CompteComptableScalarFieldEnum[]
  }

  /**
   * CompteComptable create
   */
  export type CompteComptableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * The data needed to create a CompteComptable.
     */
    data: XOR<CompteComptableCreateInput, CompteComptableUncheckedCreateInput>
  }

  /**
   * CompteComptable createMany
   */
  export type CompteComptableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompteComptables.
     */
    data: CompteComptableCreateManyInput | CompteComptableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompteComptable createManyAndReturn
   */
  export type CompteComptableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * The data used to create many CompteComptables.
     */
    data: CompteComptableCreateManyInput | CompteComptableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompteComptable update
   */
  export type CompteComptableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * The data needed to update a CompteComptable.
     */
    data: XOR<CompteComptableUpdateInput, CompteComptableUncheckedUpdateInput>
    /**
     * Choose, which CompteComptable to update.
     */
    where: CompteComptableWhereUniqueInput
  }

  /**
   * CompteComptable updateMany
   */
  export type CompteComptableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompteComptables.
     */
    data: XOR<CompteComptableUpdateManyMutationInput, CompteComptableUncheckedUpdateManyInput>
    /**
     * Filter which CompteComptables to update
     */
    where?: CompteComptableWhereInput
  }

  /**
   * CompteComptable updateManyAndReturn
   */
  export type CompteComptableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * The data used to update CompteComptables.
     */
    data: XOR<CompteComptableUpdateManyMutationInput, CompteComptableUncheckedUpdateManyInput>
    /**
     * Filter which CompteComptables to update
     */
    where?: CompteComptableWhereInput
  }

  /**
   * CompteComptable upsert
   */
  export type CompteComptableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * The filter to search for the CompteComptable to update in case it exists.
     */
    where: CompteComptableWhereUniqueInput
    /**
     * In case the CompteComptable found by the `where` argument doesn't exist, create a new CompteComptable with this data.
     */
    create: XOR<CompteComptableCreateInput, CompteComptableUncheckedCreateInput>
    /**
     * In case the CompteComptable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompteComptableUpdateInput, CompteComptableUncheckedUpdateInput>
  }

  /**
   * CompteComptable delete
   */
  export type CompteComptableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
    /**
     * Filter which CompteComptable to delete.
     */
    where: CompteComptableWhereUniqueInput
  }

  /**
   * CompteComptable deleteMany
   */
  export type CompteComptableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompteComptables to delete
     */
    where?: CompteComptableWhereInput
  }

  /**
   * CompteComptable.ecritures
   */
  export type CompteComptable$ecrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    cursor?: EcritureComptableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * CompteComptable without action
   */
  export type CompteComptableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompteComptable
     */
    select?: CompteComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompteComptable
     */
    omit?: CompteComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompteComptableInclude<ExtArgs> | null
  }


  /**
   * Model Journal
   */

  export type AggregateJournal = {
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  export type JournalMinAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    type: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type JournalMaxAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    type: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type JournalCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    type: number
    actif: number
    createdAt: number
    _all: number
  }


  export type JournalMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
  }

  export type JournalMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
  }

  export type JournalCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
    _all?: true
  }

  export type JournalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journal to aggregate.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Journals
    **/
    _count?: true | JournalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalMaxAggregateInputType
  }

  export type GetJournalAggregateType<T extends JournalAggregateArgs> = {
        [P in keyof T & keyof AggregateJournal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournal[P]>
      : GetScalarType<T[P], AggregateJournal[P]>
  }




  export type JournalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalWhereInput
    orderBy?: JournalOrderByWithAggregationInput | JournalOrderByWithAggregationInput[]
    by: JournalScalarFieldEnum[] | JournalScalarFieldEnum
    having?: JournalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalCountAggregateInputType | true
    _min?: JournalMinAggregateInputType
    _max?: JournalMaxAggregateInputType
  }

  export type JournalGroupByOutputType = {
    id: string
    code: string
    libelle: string
    type: string
    actif: boolean
    createdAt: Date
    _count: JournalCountAggregateOutputType | null
    _min: JournalMinAggregateOutputType | null
    _max: JournalMaxAggregateOutputType | null
  }

  type GetJournalGroupByPayload<T extends JournalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalGroupByOutputType[P]>
            : GetScalarType<T[P], JournalGroupByOutputType[P]>
        }
      >
    >


  export type JournalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
    ecritures?: boolean | Journal$ecrituresArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["journal"]>

  export type JournalSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }

  export type JournalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "libelle" | "type" | "actif" | "createdAt", ExtArgs["result"]["journal"]>
  export type JournalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | Journal$ecrituresArgs<ExtArgs>
    _count?: boolean | JournalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JournalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type JournalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $JournalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Journal"
    objects: {
      ecritures: Prisma.$EcritureComptablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      libelle: string
      type: string
      actif: boolean
      createdAt: Date
    }, ExtArgs["result"]["journal"]>
    composites: {}
  }

  type JournalGetPayload<S extends boolean | null | undefined | JournalDefaultArgs> = $Result.GetResult<Prisma.$JournalPayload, S>

  type JournalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JournalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JournalCountAggregateInputType | true
    }

  export interface JournalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Journal'], meta: { name: 'Journal' } }
    /**
     * Find zero or one Journal that matches the filter.
     * @param {JournalFindUniqueArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalFindUniqueArgs>(args: SelectSubset<T, JournalFindUniqueArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Journal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JournalFindUniqueOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Journal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalFindFirstArgs>(args?: SelectSubset<T, JournalFindFirstArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Journal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindFirstOrThrowArgs} args - Arguments to find a Journal
     * @example
     * // Get one Journal
     * const journal = await prisma.journal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Journals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Journals
     * const journals = await prisma.journal.findMany()
     * 
     * // Get first 10 Journals
     * const journals = await prisma.journal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalWithIdOnly = await prisma.journal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalFindManyArgs>(args?: SelectSubset<T, JournalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Journal.
     * @param {JournalCreateArgs} args - Arguments to create a Journal.
     * @example
     * // Create one Journal
     * const Journal = await prisma.journal.create({
     *   data: {
     *     // ... data to create a Journal
     *   }
     * })
     * 
     */
    create<T extends JournalCreateArgs>(args: SelectSubset<T, JournalCreateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Journals.
     * @param {JournalCreateManyArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalCreateManyArgs>(args?: SelectSubset<T, JournalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Journals and returns the data saved in the database.
     * @param {JournalCreateManyAndReturnArgs} args - Arguments to create many Journals.
     * @example
     * // Create many Journals
     * const journal = await prisma.journal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Journal.
     * @param {JournalDeleteArgs} args - Arguments to delete one Journal.
     * @example
     * // Delete one Journal
     * const Journal = await prisma.journal.delete({
     *   where: {
     *     // ... filter to delete one Journal
     *   }
     * })
     * 
     */
    delete<T extends JournalDeleteArgs>(args: SelectSubset<T, JournalDeleteArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Journal.
     * @param {JournalUpdateArgs} args - Arguments to update one Journal.
     * @example
     * // Update one Journal
     * const journal = await prisma.journal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalUpdateArgs>(args: SelectSubset<T, JournalUpdateArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Journals.
     * @param {JournalDeleteManyArgs} args - Arguments to filter Journals to delete.
     * @example
     * // Delete a few Journals
     * const { count } = await prisma.journal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalDeleteManyArgs>(args?: SelectSubset<T, JournalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalUpdateManyArgs>(args: SelectSubset<T, JournalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Journals and returns the data updated in the database.
     * @param {JournalUpdateManyAndReturnArgs} args - Arguments to update many Journals.
     * @example
     * // Update many Journals
     * const journal = await prisma.journal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Journals and only return the `id`
     * const journalWithIdOnly = await prisma.journal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JournalUpdateManyAndReturnArgs>(args: SelectSubset<T, JournalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Journal.
     * @param {JournalUpsertArgs} args - Arguments to update or create a Journal.
     * @example
     * // Update or create a Journal
     * const journal = await prisma.journal.upsert({
     *   create: {
     *     // ... data to create a Journal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Journal we want to update
     *   }
     * })
     */
    upsert<T extends JournalUpsertArgs>(args: SelectSubset<T, JournalUpsertArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Journals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalCountArgs} args - Arguments to filter Journals to count.
     * @example
     * // Count the number of Journals
     * const count = await prisma.journal.count({
     *   where: {
     *     // ... the filter for the Journals we want to count
     *   }
     * })
    **/
    count<T extends JournalCountArgs>(
      args?: Subset<T, JournalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalAggregateArgs>(args: Subset<T, JournalAggregateArgs>): Prisma.PrismaPromise<GetJournalAggregateType<T>>

    /**
     * Group by Journal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalGroupByArgs['orderBy'] }
        : { orderBy?: JournalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Journal model
   */
  readonly fields: JournalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Journal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ecritures<T extends Journal$ecrituresArgs<ExtArgs> = {}>(args?: Subset<T, Journal$ecrituresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Journal model
   */ 
  interface JournalFieldRefs {
    readonly id: FieldRef<"Journal", 'String'>
    readonly code: FieldRef<"Journal", 'String'>
    readonly libelle: FieldRef<"Journal", 'String'>
    readonly type: FieldRef<"Journal", 'String'>
    readonly actif: FieldRef<"Journal", 'Boolean'>
    readonly createdAt: FieldRef<"Journal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Journal findUnique
   */
  export type JournalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findUniqueOrThrow
   */
  export type JournalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal findFirst
   */
  export type JournalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findFirstOrThrow
   */
  export type JournalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journal to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Journals.
     */
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal findMany
   */
  export type JournalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter, which Journals to fetch.
     */
    where?: JournalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Journals to fetch.
     */
    orderBy?: JournalOrderByWithRelationInput | JournalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Journals.
     */
    cursor?: JournalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Journals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Journals.
     */
    skip?: number
    distinct?: JournalScalarFieldEnum | JournalScalarFieldEnum[]
  }

  /**
   * Journal create
   */
  export type JournalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to create a Journal.
     */
    data: XOR<JournalCreateInput, JournalUncheckedCreateInput>
  }

  /**
   * Journal createMany
   */
  export type JournalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal createManyAndReturn
   */
  export type JournalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * The data used to create many Journals.
     */
    data: JournalCreateManyInput | JournalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Journal update
   */
  export type JournalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The data needed to update a Journal.
     */
    data: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
    /**
     * Choose, which Journal to update.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal updateMany
   */
  export type JournalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
  }

  /**
   * Journal updateManyAndReturn
   */
  export type JournalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * The data used to update Journals.
     */
    data: XOR<JournalUpdateManyMutationInput, JournalUncheckedUpdateManyInput>
    /**
     * Filter which Journals to update
     */
    where?: JournalWhereInput
  }

  /**
   * Journal upsert
   */
  export type JournalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * The filter to search for the Journal to update in case it exists.
     */
    where: JournalWhereUniqueInput
    /**
     * In case the Journal found by the `where` argument doesn't exist, create a new Journal with this data.
     */
    create: XOR<JournalCreateInput, JournalUncheckedCreateInput>
    /**
     * In case the Journal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalUpdateInput, JournalUncheckedUpdateInput>
  }

  /**
   * Journal delete
   */
  export type JournalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
    /**
     * Filter which Journal to delete.
     */
    where: JournalWhereUniqueInput
  }

  /**
   * Journal deleteMany
   */
  export type JournalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Journals to delete
     */
    where?: JournalWhereInput
  }

  /**
   * Journal.ecritures
   */
  export type Journal$ecrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    cursor?: EcritureComptableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * Journal without action
   */
  export type JournalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Journal
     */
    select?: JournalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Journal
     */
    omit?: JournalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JournalInclude<ExtArgs> | null
  }


  /**
   * Model ExerciceComptable
   */

  export type AggregateExerciceComptable = {
    _count: ExerciceComptableCountAggregateOutputType | null
    _avg: ExerciceComptableAvgAggregateOutputType | null
    _sum: ExerciceComptableSumAggregateOutputType | null
    _min: ExerciceComptableMinAggregateOutputType | null
    _max: ExerciceComptableMaxAggregateOutputType | null
  }

  export type ExerciceComptableAvgAggregateOutputType = {
    annee: number | null
  }

  export type ExerciceComptableSumAggregateOutputType = {
    annee: number | null
  }

  export type ExerciceComptableMinAggregateOutputType = {
    id: string | null
    annee: number | null
    dateDebut: Date | null
    dateFin: Date | null
    cloture: boolean | null
    createdAt: Date | null
  }

  export type ExerciceComptableMaxAggregateOutputType = {
    id: string | null
    annee: number | null
    dateDebut: Date | null
    dateFin: Date | null
    cloture: boolean | null
    createdAt: Date | null
  }

  export type ExerciceComptableCountAggregateOutputType = {
    id: number
    annee: number
    dateDebut: number
    dateFin: number
    cloture: number
    createdAt: number
    _all: number
  }


  export type ExerciceComptableAvgAggregateInputType = {
    annee?: true
  }

  export type ExerciceComptableSumAggregateInputType = {
    annee?: true
  }

  export type ExerciceComptableMinAggregateInputType = {
    id?: true
    annee?: true
    dateDebut?: true
    dateFin?: true
    cloture?: true
    createdAt?: true
  }

  export type ExerciceComptableMaxAggregateInputType = {
    id?: true
    annee?: true
    dateDebut?: true
    dateFin?: true
    cloture?: true
    createdAt?: true
  }

  export type ExerciceComptableCountAggregateInputType = {
    id?: true
    annee?: true
    dateDebut?: true
    dateFin?: true
    cloture?: true
    createdAt?: true
    _all?: true
  }

  export type ExerciceComptableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciceComptable to aggregate.
     */
    where?: ExerciceComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciceComptables to fetch.
     */
    orderBy?: ExerciceComptableOrderByWithRelationInput | ExerciceComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciceComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciceComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciceComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciceComptables
    **/
    _count?: true | ExerciceComptableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciceComptableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciceComptableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciceComptableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciceComptableMaxAggregateInputType
  }

  export type GetExerciceComptableAggregateType<T extends ExerciceComptableAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciceComptable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciceComptable[P]>
      : GetScalarType<T[P], AggregateExerciceComptable[P]>
  }




  export type ExerciceComptableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciceComptableWhereInput
    orderBy?: ExerciceComptableOrderByWithAggregationInput | ExerciceComptableOrderByWithAggregationInput[]
    by: ExerciceComptableScalarFieldEnum[] | ExerciceComptableScalarFieldEnum
    having?: ExerciceComptableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciceComptableCountAggregateInputType | true
    _avg?: ExerciceComptableAvgAggregateInputType
    _sum?: ExerciceComptableSumAggregateInputType
    _min?: ExerciceComptableMinAggregateInputType
    _max?: ExerciceComptableMaxAggregateInputType
  }

  export type ExerciceComptableGroupByOutputType = {
    id: string
    annee: number
    dateDebut: Date
    dateFin: Date
    cloture: boolean
    createdAt: Date
    _count: ExerciceComptableCountAggregateOutputType | null
    _avg: ExerciceComptableAvgAggregateOutputType | null
    _sum: ExerciceComptableSumAggregateOutputType | null
    _min: ExerciceComptableMinAggregateOutputType | null
    _max: ExerciceComptableMaxAggregateOutputType | null
  }

  type GetExerciceComptableGroupByPayload<T extends ExerciceComptableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciceComptableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciceComptableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciceComptableGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciceComptableGroupByOutputType[P]>
        }
      >
    >


  export type ExerciceComptableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    annee?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    cloture?: boolean
    createdAt?: boolean
    ecritures?: boolean | ExerciceComptable$ecrituresArgs<ExtArgs>
    budgets?: boolean | ExerciceComptable$budgetsArgs<ExtArgs>
    _count?: boolean | ExerciceComptableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exerciceComptable"]>

  export type ExerciceComptableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    annee?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    cloture?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exerciceComptable"]>

  export type ExerciceComptableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    annee?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    cloture?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exerciceComptable"]>

  export type ExerciceComptableSelectScalar = {
    id?: boolean
    annee?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    cloture?: boolean
    createdAt?: boolean
  }

  export type ExerciceComptableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "annee" | "dateDebut" | "dateFin" | "cloture" | "createdAt", ExtArgs["result"]["exerciceComptable"]>
  export type ExerciceComptableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | ExerciceComptable$ecrituresArgs<ExtArgs>
    budgets?: boolean | ExerciceComptable$budgetsArgs<ExtArgs>
    _count?: boolean | ExerciceComptableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciceComptableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExerciceComptableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExerciceComptablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExerciceComptable"
    objects: {
      ecritures: Prisma.$EcritureComptablePayload<ExtArgs>[]
      budgets: Prisma.$BudgetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      annee: number
      dateDebut: Date
      dateFin: Date
      cloture: boolean
      createdAt: Date
    }, ExtArgs["result"]["exerciceComptable"]>
    composites: {}
  }

  type ExerciceComptableGetPayload<S extends boolean | null | undefined | ExerciceComptableDefaultArgs> = $Result.GetResult<Prisma.$ExerciceComptablePayload, S>

  type ExerciceComptableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExerciceComptableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExerciceComptableCountAggregateInputType | true
    }

  export interface ExerciceComptableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExerciceComptable'], meta: { name: 'ExerciceComptable' } }
    /**
     * Find zero or one ExerciceComptable that matches the filter.
     * @param {ExerciceComptableFindUniqueArgs} args - Arguments to find a ExerciceComptable
     * @example
     * // Get one ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciceComptableFindUniqueArgs>(args: SelectSubset<T, ExerciceComptableFindUniqueArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ExerciceComptable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExerciceComptableFindUniqueOrThrowArgs} args - Arguments to find a ExerciceComptable
     * @example
     * // Get one ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciceComptableFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciceComptableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ExerciceComptable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableFindFirstArgs} args - Arguments to find a ExerciceComptable
     * @example
     * // Get one ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciceComptableFindFirstArgs>(args?: SelectSubset<T, ExerciceComptableFindFirstArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ExerciceComptable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableFindFirstOrThrowArgs} args - Arguments to find a ExerciceComptable
     * @example
     * // Get one ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciceComptableFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciceComptableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ExerciceComptables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciceComptables
     * const exerciceComptables = await prisma.exerciceComptable.findMany()
     * 
     * // Get first 10 ExerciceComptables
     * const exerciceComptables = await prisma.exerciceComptable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciceComptableWithIdOnly = await prisma.exerciceComptable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciceComptableFindManyArgs>(args?: SelectSubset<T, ExerciceComptableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ExerciceComptable.
     * @param {ExerciceComptableCreateArgs} args - Arguments to create a ExerciceComptable.
     * @example
     * // Create one ExerciceComptable
     * const ExerciceComptable = await prisma.exerciceComptable.create({
     *   data: {
     *     // ... data to create a ExerciceComptable
     *   }
     * })
     * 
     */
    create<T extends ExerciceComptableCreateArgs>(args: SelectSubset<T, ExerciceComptableCreateArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ExerciceComptables.
     * @param {ExerciceComptableCreateManyArgs} args - Arguments to create many ExerciceComptables.
     * @example
     * // Create many ExerciceComptables
     * const exerciceComptable = await prisma.exerciceComptable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciceComptableCreateManyArgs>(args?: SelectSubset<T, ExerciceComptableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExerciceComptables and returns the data saved in the database.
     * @param {ExerciceComptableCreateManyAndReturnArgs} args - Arguments to create many ExerciceComptables.
     * @example
     * // Create many ExerciceComptables
     * const exerciceComptable = await prisma.exerciceComptable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExerciceComptables and only return the `id`
     * const exerciceComptableWithIdOnly = await prisma.exerciceComptable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciceComptableCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciceComptableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ExerciceComptable.
     * @param {ExerciceComptableDeleteArgs} args - Arguments to delete one ExerciceComptable.
     * @example
     * // Delete one ExerciceComptable
     * const ExerciceComptable = await prisma.exerciceComptable.delete({
     *   where: {
     *     // ... filter to delete one ExerciceComptable
     *   }
     * })
     * 
     */
    delete<T extends ExerciceComptableDeleteArgs>(args: SelectSubset<T, ExerciceComptableDeleteArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ExerciceComptable.
     * @param {ExerciceComptableUpdateArgs} args - Arguments to update one ExerciceComptable.
     * @example
     * // Update one ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciceComptableUpdateArgs>(args: SelectSubset<T, ExerciceComptableUpdateArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ExerciceComptables.
     * @param {ExerciceComptableDeleteManyArgs} args - Arguments to filter ExerciceComptables to delete.
     * @example
     * // Delete a few ExerciceComptables
     * const { count } = await prisma.exerciceComptable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciceComptableDeleteManyArgs>(args?: SelectSubset<T, ExerciceComptableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciceComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciceComptables
     * const exerciceComptable = await prisma.exerciceComptable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciceComptableUpdateManyArgs>(args: SelectSubset<T, ExerciceComptableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciceComptables and returns the data updated in the database.
     * @param {ExerciceComptableUpdateManyAndReturnArgs} args - Arguments to update many ExerciceComptables.
     * @example
     * // Update many ExerciceComptables
     * const exerciceComptable = await prisma.exerciceComptable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExerciceComptables and only return the `id`
     * const exerciceComptableWithIdOnly = await prisma.exerciceComptable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExerciceComptableUpdateManyAndReturnArgs>(args: SelectSubset<T, ExerciceComptableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ExerciceComptable.
     * @param {ExerciceComptableUpsertArgs} args - Arguments to update or create a ExerciceComptable.
     * @example
     * // Update or create a ExerciceComptable
     * const exerciceComptable = await prisma.exerciceComptable.upsert({
     *   create: {
     *     // ... data to create a ExerciceComptable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciceComptable we want to update
     *   }
     * })
     */
    upsert<T extends ExerciceComptableUpsertArgs>(args: SelectSubset<T, ExerciceComptableUpsertArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ExerciceComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableCountArgs} args - Arguments to filter ExerciceComptables to count.
     * @example
     * // Count the number of ExerciceComptables
     * const count = await prisma.exerciceComptable.count({
     *   where: {
     *     // ... the filter for the ExerciceComptables we want to count
     *   }
     * })
    **/
    count<T extends ExerciceComptableCountArgs>(
      args?: Subset<T, ExerciceComptableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciceComptableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciceComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciceComptableAggregateArgs>(args: Subset<T, ExerciceComptableAggregateArgs>): Prisma.PrismaPromise<GetExerciceComptableAggregateType<T>>

    /**
     * Group by ExerciceComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciceComptableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciceComptableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciceComptableGroupByArgs['orderBy'] }
        : { orderBy?: ExerciceComptableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciceComptableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciceComptableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExerciceComptable model
   */
  readonly fields: ExerciceComptableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciceComptable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciceComptableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ecritures<T extends ExerciceComptable$ecrituresArgs<ExtArgs> = {}>(args?: Subset<T, ExerciceComptable$ecrituresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    budgets<T extends ExerciceComptable$budgetsArgs<ExtArgs> = {}>(args?: Subset<T, ExerciceComptable$budgetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExerciceComptable model
   */ 
  interface ExerciceComptableFieldRefs {
    readonly id: FieldRef<"ExerciceComptable", 'String'>
    readonly annee: FieldRef<"ExerciceComptable", 'Int'>
    readonly dateDebut: FieldRef<"ExerciceComptable", 'DateTime'>
    readonly dateFin: FieldRef<"ExerciceComptable", 'DateTime'>
    readonly cloture: FieldRef<"ExerciceComptable", 'Boolean'>
    readonly createdAt: FieldRef<"ExerciceComptable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExerciceComptable findUnique
   */
  export type ExerciceComptableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter, which ExerciceComptable to fetch.
     */
    where: ExerciceComptableWhereUniqueInput
  }

  /**
   * ExerciceComptable findUniqueOrThrow
   */
  export type ExerciceComptableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter, which ExerciceComptable to fetch.
     */
    where: ExerciceComptableWhereUniqueInput
  }

  /**
   * ExerciceComptable findFirst
   */
  export type ExerciceComptableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter, which ExerciceComptable to fetch.
     */
    where?: ExerciceComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciceComptables to fetch.
     */
    orderBy?: ExerciceComptableOrderByWithRelationInput | ExerciceComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciceComptables.
     */
    cursor?: ExerciceComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciceComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciceComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciceComptables.
     */
    distinct?: ExerciceComptableScalarFieldEnum | ExerciceComptableScalarFieldEnum[]
  }

  /**
   * ExerciceComptable findFirstOrThrow
   */
  export type ExerciceComptableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter, which ExerciceComptable to fetch.
     */
    where?: ExerciceComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciceComptables to fetch.
     */
    orderBy?: ExerciceComptableOrderByWithRelationInput | ExerciceComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciceComptables.
     */
    cursor?: ExerciceComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciceComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciceComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciceComptables.
     */
    distinct?: ExerciceComptableScalarFieldEnum | ExerciceComptableScalarFieldEnum[]
  }

  /**
   * ExerciceComptable findMany
   */
  export type ExerciceComptableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter, which ExerciceComptables to fetch.
     */
    where?: ExerciceComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciceComptables to fetch.
     */
    orderBy?: ExerciceComptableOrderByWithRelationInput | ExerciceComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciceComptables.
     */
    cursor?: ExerciceComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciceComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciceComptables.
     */
    skip?: number
    distinct?: ExerciceComptableScalarFieldEnum | ExerciceComptableScalarFieldEnum[]
  }

  /**
   * ExerciceComptable create
   */
  export type ExerciceComptableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * The data needed to create a ExerciceComptable.
     */
    data: XOR<ExerciceComptableCreateInput, ExerciceComptableUncheckedCreateInput>
  }

  /**
   * ExerciceComptable createMany
   */
  export type ExerciceComptableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExerciceComptables.
     */
    data: ExerciceComptableCreateManyInput | ExerciceComptableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciceComptable createManyAndReturn
   */
  export type ExerciceComptableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * The data used to create many ExerciceComptables.
     */
    data: ExerciceComptableCreateManyInput | ExerciceComptableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExerciceComptable update
   */
  export type ExerciceComptableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * The data needed to update a ExerciceComptable.
     */
    data: XOR<ExerciceComptableUpdateInput, ExerciceComptableUncheckedUpdateInput>
    /**
     * Choose, which ExerciceComptable to update.
     */
    where: ExerciceComptableWhereUniqueInput
  }

  /**
   * ExerciceComptable updateMany
   */
  export type ExerciceComptableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExerciceComptables.
     */
    data: XOR<ExerciceComptableUpdateManyMutationInput, ExerciceComptableUncheckedUpdateManyInput>
    /**
     * Filter which ExerciceComptables to update
     */
    where?: ExerciceComptableWhereInput
  }

  /**
   * ExerciceComptable updateManyAndReturn
   */
  export type ExerciceComptableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * The data used to update ExerciceComptables.
     */
    data: XOR<ExerciceComptableUpdateManyMutationInput, ExerciceComptableUncheckedUpdateManyInput>
    /**
     * Filter which ExerciceComptables to update
     */
    where?: ExerciceComptableWhereInput
  }

  /**
   * ExerciceComptable upsert
   */
  export type ExerciceComptableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * The filter to search for the ExerciceComptable to update in case it exists.
     */
    where: ExerciceComptableWhereUniqueInput
    /**
     * In case the ExerciceComptable found by the `where` argument doesn't exist, create a new ExerciceComptable with this data.
     */
    create: XOR<ExerciceComptableCreateInput, ExerciceComptableUncheckedCreateInput>
    /**
     * In case the ExerciceComptable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciceComptableUpdateInput, ExerciceComptableUncheckedUpdateInput>
  }

  /**
   * ExerciceComptable delete
   */
  export type ExerciceComptableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
    /**
     * Filter which ExerciceComptable to delete.
     */
    where: ExerciceComptableWhereUniqueInput
  }

  /**
   * ExerciceComptable deleteMany
   */
  export type ExerciceComptableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExerciceComptables to delete
     */
    where?: ExerciceComptableWhereInput
  }

  /**
   * ExerciceComptable.ecritures
   */
  export type ExerciceComptable$ecrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    cursor?: EcritureComptableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * ExerciceComptable.budgets
   */
  export type ExerciceComptable$budgetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    cursor?: BudgetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * ExerciceComptable without action
   */
  export type ExerciceComptableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciceComptable
     */
    select?: ExerciceComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExerciceComptable
     */
    omit?: ExerciceComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciceComptableInclude<ExtArgs> | null
  }


  /**
   * Model EcritureComptable
   */

  export type AggregateEcritureComptable = {
    _count: EcritureComptableCountAggregateOutputType | null
    _avg: EcritureComptableAvgAggregateOutputType | null
    _sum: EcritureComptableSumAggregateOutputType | null
    _min: EcritureComptableMinAggregateOutputType | null
    _max: EcritureComptableMaxAggregateOutputType | null
  }

  export type EcritureComptableAvgAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type EcritureComptableSumAggregateOutputType = {
    debit: Decimal | null
    credit: Decimal | null
  }

  export type EcritureComptableMinAggregateOutputType = {
    id: string | null
    journalId: string | null
    compteId: string | null
    exerciceId: string | null
    dateEcriture: Date | null
    libelle: string | null
    debit: Decimal | null
    credit: Decimal | null
    pieceRef: string | null
    centreAnalytiqueId: string | null
    valide: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EcritureComptableMaxAggregateOutputType = {
    id: string | null
    journalId: string | null
    compteId: string | null
    exerciceId: string | null
    dateEcriture: Date | null
    libelle: string | null
    debit: Decimal | null
    credit: Decimal | null
    pieceRef: string | null
    centreAnalytiqueId: string | null
    valide: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EcritureComptableCountAggregateOutputType = {
    id: number
    journalId: number
    compteId: number
    exerciceId: number
    dateEcriture: number
    libelle: number
    debit: number
    credit: number
    pieceRef: number
    centreAnalytiqueId: number
    valide: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EcritureComptableAvgAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type EcritureComptableSumAggregateInputType = {
    debit?: true
    credit?: true
  }

  export type EcritureComptableMinAggregateInputType = {
    id?: true
    journalId?: true
    compteId?: true
    exerciceId?: true
    dateEcriture?: true
    libelle?: true
    debit?: true
    credit?: true
    pieceRef?: true
    centreAnalytiqueId?: true
    valide?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EcritureComptableMaxAggregateInputType = {
    id?: true
    journalId?: true
    compteId?: true
    exerciceId?: true
    dateEcriture?: true
    libelle?: true
    debit?: true
    credit?: true
    pieceRef?: true
    centreAnalytiqueId?: true
    valide?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EcritureComptableCountAggregateInputType = {
    id?: true
    journalId?: true
    compteId?: true
    exerciceId?: true
    dateEcriture?: true
    libelle?: true
    debit?: true
    credit?: true
    pieceRef?: true
    centreAnalytiqueId?: true
    valide?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EcritureComptableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcritureComptable to aggregate.
     */
    where?: EcritureComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcritureComptables to fetch.
     */
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EcritureComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcritureComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcritureComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EcritureComptables
    **/
    _count?: true | EcritureComptableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EcritureComptableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EcritureComptableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EcritureComptableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EcritureComptableMaxAggregateInputType
  }

  export type GetEcritureComptableAggregateType<T extends EcritureComptableAggregateArgs> = {
        [P in keyof T & keyof AggregateEcritureComptable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEcritureComptable[P]>
      : GetScalarType<T[P], AggregateEcritureComptable[P]>
  }




  export type EcritureComptableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithAggregationInput | EcritureComptableOrderByWithAggregationInput[]
    by: EcritureComptableScalarFieldEnum[] | EcritureComptableScalarFieldEnum
    having?: EcritureComptableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EcritureComptableCountAggregateInputType | true
    _avg?: EcritureComptableAvgAggregateInputType
    _sum?: EcritureComptableSumAggregateInputType
    _min?: EcritureComptableMinAggregateInputType
    _max?: EcritureComptableMaxAggregateInputType
  }

  export type EcritureComptableGroupByOutputType = {
    id: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date
    libelle: string
    debit: Decimal
    credit: Decimal
    pieceRef: string | null
    centreAnalytiqueId: string | null
    valide: boolean
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: EcritureComptableCountAggregateOutputType | null
    _avg: EcritureComptableAvgAggregateOutputType | null
    _sum: EcritureComptableSumAggregateOutputType | null
    _min: EcritureComptableMinAggregateOutputType | null
    _max: EcritureComptableMaxAggregateOutputType | null
  }

  type GetEcritureComptableGroupByPayload<T extends EcritureComptableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EcritureComptableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EcritureComptableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EcritureComptableGroupByOutputType[P]>
            : GetScalarType<T[P], EcritureComptableGroupByOutputType[P]>
        }
      >
    >


  export type EcritureComptableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    compteId?: boolean
    exerciceId?: boolean
    dateEcriture?: boolean
    libelle?: boolean
    debit?: boolean
    credit?: boolean
    pieceRef?: boolean
    centreAnalytiqueId?: boolean
    valide?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecritureComptable"]>

  export type EcritureComptableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    compteId?: boolean
    exerciceId?: boolean
    dateEcriture?: boolean
    libelle?: boolean
    debit?: boolean
    credit?: boolean
    pieceRef?: boolean
    centreAnalytiqueId?: boolean
    valide?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecritureComptable"]>

  export type EcritureComptableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    journalId?: boolean
    compteId?: boolean
    exerciceId?: boolean
    dateEcriture?: boolean
    libelle?: boolean
    debit?: boolean
    credit?: boolean
    pieceRef?: boolean
    centreAnalytiqueId?: boolean
    valide?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ecritureComptable"]>

  export type EcritureComptableSelectScalar = {
    id?: boolean
    journalId?: boolean
    compteId?: boolean
    exerciceId?: boolean
    dateEcriture?: boolean
    libelle?: boolean
    debit?: boolean
    credit?: boolean
    pieceRef?: boolean
    centreAnalytiqueId?: boolean
    valide?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EcritureComptableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "journalId" | "compteId" | "exerciceId" | "dateEcriture" | "libelle" | "debit" | "credit" | "pieceRef" | "centreAnalytiqueId" | "valide" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["ecritureComptable"]>
  export type EcritureComptableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EcritureComptableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EcritureComptableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journal?: boolean | JournalDefaultArgs<ExtArgs>
    compte?: boolean | CompteComptableDefaultArgs<ExtArgs>
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
    centreAnalytique?: boolean | EcritureComptable$centreAnalytiqueArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EcritureComptablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EcritureComptable"
    objects: {
      journal: Prisma.$JournalPayload<ExtArgs>
      compte: Prisma.$CompteComptablePayload<ExtArgs>
      exercice: Prisma.$ExerciceComptablePayload<ExtArgs>
      centreAnalytique: Prisma.$CentreAnalytiquePayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      journalId: string
      compteId: string
      exerciceId: string
      dateEcriture: Date
      libelle: string
      debit: Prisma.Decimal
      credit: Prisma.Decimal
      pieceRef: string | null
      centreAnalytiqueId: string | null
      valide: boolean
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ecritureComptable"]>
    composites: {}
  }

  type EcritureComptableGetPayload<S extends boolean | null | undefined | EcritureComptableDefaultArgs> = $Result.GetResult<Prisma.$EcritureComptablePayload, S>

  type EcritureComptableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EcritureComptableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EcritureComptableCountAggregateInputType | true
    }

  export interface EcritureComptableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EcritureComptable'], meta: { name: 'EcritureComptable' } }
    /**
     * Find zero or one EcritureComptable that matches the filter.
     * @param {EcritureComptableFindUniqueArgs} args - Arguments to find a EcritureComptable
     * @example
     * // Get one EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EcritureComptableFindUniqueArgs>(args: SelectSubset<T, EcritureComptableFindUniqueArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EcritureComptable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EcritureComptableFindUniqueOrThrowArgs} args - Arguments to find a EcritureComptable
     * @example
     * // Get one EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EcritureComptableFindUniqueOrThrowArgs>(args: SelectSubset<T, EcritureComptableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EcritureComptable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableFindFirstArgs} args - Arguments to find a EcritureComptable
     * @example
     * // Get one EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EcritureComptableFindFirstArgs>(args?: SelectSubset<T, EcritureComptableFindFirstArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EcritureComptable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableFindFirstOrThrowArgs} args - Arguments to find a EcritureComptable
     * @example
     * // Get one EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EcritureComptableFindFirstOrThrowArgs>(args?: SelectSubset<T, EcritureComptableFindFirstOrThrowArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EcritureComptables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EcritureComptables
     * const ecritureComptables = await prisma.ecritureComptable.findMany()
     * 
     * // Get first 10 EcritureComptables
     * const ecritureComptables = await prisma.ecritureComptable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ecritureComptableWithIdOnly = await prisma.ecritureComptable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EcritureComptableFindManyArgs>(args?: SelectSubset<T, EcritureComptableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EcritureComptable.
     * @param {EcritureComptableCreateArgs} args - Arguments to create a EcritureComptable.
     * @example
     * // Create one EcritureComptable
     * const EcritureComptable = await prisma.ecritureComptable.create({
     *   data: {
     *     // ... data to create a EcritureComptable
     *   }
     * })
     * 
     */
    create<T extends EcritureComptableCreateArgs>(args: SelectSubset<T, EcritureComptableCreateArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EcritureComptables.
     * @param {EcritureComptableCreateManyArgs} args - Arguments to create many EcritureComptables.
     * @example
     * // Create many EcritureComptables
     * const ecritureComptable = await prisma.ecritureComptable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EcritureComptableCreateManyArgs>(args?: SelectSubset<T, EcritureComptableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EcritureComptables and returns the data saved in the database.
     * @param {EcritureComptableCreateManyAndReturnArgs} args - Arguments to create many EcritureComptables.
     * @example
     * // Create many EcritureComptables
     * const ecritureComptable = await prisma.ecritureComptable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EcritureComptables and only return the `id`
     * const ecritureComptableWithIdOnly = await prisma.ecritureComptable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EcritureComptableCreateManyAndReturnArgs>(args?: SelectSubset<T, EcritureComptableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EcritureComptable.
     * @param {EcritureComptableDeleteArgs} args - Arguments to delete one EcritureComptable.
     * @example
     * // Delete one EcritureComptable
     * const EcritureComptable = await prisma.ecritureComptable.delete({
     *   where: {
     *     // ... filter to delete one EcritureComptable
     *   }
     * })
     * 
     */
    delete<T extends EcritureComptableDeleteArgs>(args: SelectSubset<T, EcritureComptableDeleteArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EcritureComptable.
     * @param {EcritureComptableUpdateArgs} args - Arguments to update one EcritureComptable.
     * @example
     * // Update one EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EcritureComptableUpdateArgs>(args: SelectSubset<T, EcritureComptableUpdateArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EcritureComptables.
     * @param {EcritureComptableDeleteManyArgs} args - Arguments to filter EcritureComptables to delete.
     * @example
     * // Delete a few EcritureComptables
     * const { count } = await prisma.ecritureComptable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EcritureComptableDeleteManyArgs>(args?: SelectSubset<T, EcritureComptableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcritureComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EcritureComptables
     * const ecritureComptable = await prisma.ecritureComptable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EcritureComptableUpdateManyArgs>(args: SelectSubset<T, EcritureComptableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EcritureComptables and returns the data updated in the database.
     * @param {EcritureComptableUpdateManyAndReturnArgs} args - Arguments to update many EcritureComptables.
     * @example
     * // Update many EcritureComptables
     * const ecritureComptable = await prisma.ecritureComptable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EcritureComptables and only return the `id`
     * const ecritureComptableWithIdOnly = await prisma.ecritureComptable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EcritureComptableUpdateManyAndReturnArgs>(args: SelectSubset<T, EcritureComptableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EcritureComptable.
     * @param {EcritureComptableUpsertArgs} args - Arguments to update or create a EcritureComptable.
     * @example
     * // Update or create a EcritureComptable
     * const ecritureComptable = await prisma.ecritureComptable.upsert({
     *   create: {
     *     // ... data to create a EcritureComptable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EcritureComptable we want to update
     *   }
     * })
     */
    upsert<T extends EcritureComptableUpsertArgs>(args: SelectSubset<T, EcritureComptableUpsertArgs<ExtArgs>>): Prisma__EcritureComptableClient<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EcritureComptables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableCountArgs} args - Arguments to filter EcritureComptables to count.
     * @example
     * // Count the number of EcritureComptables
     * const count = await prisma.ecritureComptable.count({
     *   where: {
     *     // ... the filter for the EcritureComptables we want to count
     *   }
     * })
    **/
    count<T extends EcritureComptableCountArgs>(
      args?: Subset<T, EcritureComptableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EcritureComptableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EcritureComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EcritureComptableAggregateArgs>(args: Subset<T, EcritureComptableAggregateArgs>): Prisma.PrismaPromise<GetEcritureComptableAggregateType<T>>

    /**
     * Group by EcritureComptable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EcritureComptableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EcritureComptableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EcritureComptableGroupByArgs['orderBy'] }
        : { orderBy?: EcritureComptableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EcritureComptableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEcritureComptableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EcritureComptable model
   */
  readonly fields: EcritureComptableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EcritureComptable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EcritureComptableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    journal<T extends JournalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JournalDefaultArgs<ExtArgs>>): Prisma__JournalClient<$Result.GetResult<Prisma.$JournalPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    compte<T extends CompteComptableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompteComptableDefaultArgs<ExtArgs>>): Prisma__CompteComptableClient<$Result.GetResult<Prisma.$CompteComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    exercice<T extends ExerciceComptableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciceComptableDefaultArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    centreAnalytique<T extends EcritureComptable$centreAnalytiqueArgs<ExtArgs> = {}>(args?: Subset<T, EcritureComptable$centreAnalytiqueArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EcritureComptable model
   */ 
  interface EcritureComptableFieldRefs {
    readonly id: FieldRef<"EcritureComptable", 'String'>
    readonly journalId: FieldRef<"EcritureComptable", 'String'>
    readonly compteId: FieldRef<"EcritureComptable", 'String'>
    readonly exerciceId: FieldRef<"EcritureComptable", 'String'>
    readonly dateEcriture: FieldRef<"EcritureComptable", 'DateTime'>
    readonly libelle: FieldRef<"EcritureComptable", 'String'>
    readonly debit: FieldRef<"EcritureComptable", 'Decimal'>
    readonly credit: FieldRef<"EcritureComptable", 'Decimal'>
    readonly pieceRef: FieldRef<"EcritureComptable", 'String'>
    readonly centreAnalytiqueId: FieldRef<"EcritureComptable", 'String'>
    readonly valide: FieldRef<"EcritureComptable", 'Boolean'>
    readonly createdById: FieldRef<"EcritureComptable", 'String'>
    readonly createdAt: FieldRef<"EcritureComptable", 'DateTime'>
    readonly updatedAt: FieldRef<"EcritureComptable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EcritureComptable findUnique
   */
  export type EcritureComptableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter, which EcritureComptable to fetch.
     */
    where: EcritureComptableWhereUniqueInput
  }

  /**
   * EcritureComptable findUniqueOrThrow
   */
  export type EcritureComptableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter, which EcritureComptable to fetch.
     */
    where: EcritureComptableWhereUniqueInput
  }

  /**
   * EcritureComptable findFirst
   */
  export type EcritureComptableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter, which EcritureComptable to fetch.
     */
    where?: EcritureComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcritureComptables to fetch.
     */
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcritureComptables.
     */
    cursor?: EcritureComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcritureComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcritureComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcritureComptables.
     */
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * EcritureComptable findFirstOrThrow
   */
  export type EcritureComptableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter, which EcritureComptable to fetch.
     */
    where?: EcritureComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcritureComptables to fetch.
     */
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EcritureComptables.
     */
    cursor?: EcritureComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcritureComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcritureComptables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EcritureComptables.
     */
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * EcritureComptable findMany
   */
  export type EcritureComptableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter, which EcritureComptables to fetch.
     */
    where?: EcritureComptableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EcritureComptables to fetch.
     */
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EcritureComptables.
     */
    cursor?: EcritureComptableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EcritureComptables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EcritureComptables.
     */
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * EcritureComptable create
   */
  export type EcritureComptableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * The data needed to create a EcritureComptable.
     */
    data: XOR<EcritureComptableCreateInput, EcritureComptableUncheckedCreateInput>
  }

  /**
   * EcritureComptable createMany
   */
  export type EcritureComptableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EcritureComptables.
     */
    data: EcritureComptableCreateManyInput | EcritureComptableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EcritureComptable createManyAndReturn
   */
  export type EcritureComptableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * The data used to create many EcritureComptables.
     */
    data: EcritureComptableCreateManyInput | EcritureComptableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcritureComptable update
   */
  export type EcritureComptableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * The data needed to update a EcritureComptable.
     */
    data: XOR<EcritureComptableUpdateInput, EcritureComptableUncheckedUpdateInput>
    /**
     * Choose, which EcritureComptable to update.
     */
    where: EcritureComptableWhereUniqueInput
  }

  /**
   * EcritureComptable updateMany
   */
  export type EcritureComptableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EcritureComptables.
     */
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyInput>
    /**
     * Filter which EcritureComptables to update
     */
    where?: EcritureComptableWhereInput
  }

  /**
   * EcritureComptable updateManyAndReturn
   */
  export type EcritureComptableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * The data used to update EcritureComptables.
     */
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyInput>
    /**
     * Filter which EcritureComptables to update
     */
    where?: EcritureComptableWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EcritureComptable upsert
   */
  export type EcritureComptableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * The filter to search for the EcritureComptable to update in case it exists.
     */
    where: EcritureComptableWhereUniqueInput
    /**
     * In case the EcritureComptable found by the `where` argument doesn't exist, create a new EcritureComptable with this data.
     */
    create: XOR<EcritureComptableCreateInput, EcritureComptableUncheckedCreateInput>
    /**
     * In case the EcritureComptable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EcritureComptableUpdateInput, EcritureComptableUncheckedUpdateInput>
  }

  /**
   * EcritureComptable delete
   */
  export type EcritureComptableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    /**
     * Filter which EcritureComptable to delete.
     */
    where: EcritureComptableWhereUniqueInput
  }

  /**
   * EcritureComptable deleteMany
   */
  export type EcritureComptableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EcritureComptables to delete
     */
    where?: EcritureComptableWhereInput
  }

  /**
   * EcritureComptable.centreAnalytique
   */
  export type EcritureComptable$centreAnalytiqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    where?: CentreAnalytiqueWhereInput
  }

  /**
   * EcritureComptable without action
   */
  export type EcritureComptableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
  }


  /**
   * Model CentreAnalytique
   */

  export type AggregateCentreAnalytique = {
    _count: CentreAnalytiqueCountAggregateOutputType | null
    _min: CentreAnalytiqueMinAggregateOutputType | null
    _max: CentreAnalytiqueMaxAggregateOutputType | null
  }

  export type CentreAnalytiqueMinAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    type: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type CentreAnalytiqueMaxAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    type: string | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type CentreAnalytiqueCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    type: number
    actif: number
    createdAt: number
    _all: number
  }


  export type CentreAnalytiqueMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
  }

  export type CentreAnalytiqueMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
  }

  export type CentreAnalytiqueCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    type?: true
    actif?: true
    createdAt?: true
    _all?: true
  }

  export type CentreAnalytiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CentreAnalytique to aggregate.
     */
    where?: CentreAnalytiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CentreAnalytiques to fetch.
     */
    orderBy?: CentreAnalytiqueOrderByWithRelationInput | CentreAnalytiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CentreAnalytiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CentreAnalytiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CentreAnalytiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CentreAnalytiques
    **/
    _count?: true | CentreAnalytiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CentreAnalytiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CentreAnalytiqueMaxAggregateInputType
  }

  export type GetCentreAnalytiqueAggregateType<T extends CentreAnalytiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateCentreAnalytique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCentreAnalytique[P]>
      : GetScalarType<T[P], AggregateCentreAnalytique[P]>
  }




  export type CentreAnalytiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CentreAnalytiqueWhereInput
    orderBy?: CentreAnalytiqueOrderByWithAggregationInput | CentreAnalytiqueOrderByWithAggregationInput[]
    by: CentreAnalytiqueScalarFieldEnum[] | CentreAnalytiqueScalarFieldEnum
    having?: CentreAnalytiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CentreAnalytiqueCountAggregateInputType | true
    _min?: CentreAnalytiqueMinAggregateInputType
    _max?: CentreAnalytiqueMaxAggregateInputType
  }

  export type CentreAnalytiqueGroupByOutputType = {
    id: string
    code: string
    libelle: string
    type: string
    actif: boolean
    createdAt: Date
    _count: CentreAnalytiqueCountAggregateOutputType | null
    _min: CentreAnalytiqueMinAggregateOutputType | null
    _max: CentreAnalytiqueMaxAggregateOutputType | null
  }

  type GetCentreAnalytiqueGroupByPayload<T extends CentreAnalytiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CentreAnalytiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CentreAnalytiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CentreAnalytiqueGroupByOutputType[P]>
            : GetScalarType<T[P], CentreAnalytiqueGroupByOutputType[P]>
        }
      >
    >


  export type CentreAnalytiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
    ecritures?: boolean | CentreAnalytique$ecrituresArgs<ExtArgs>
    _count?: boolean | CentreAnalytiqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["centreAnalytique"]>

  export type CentreAnalytiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["centreAnalytique"]>

  export type CentreAnalytiqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["centreAnalytique"]>

  export type CentreAnalytiqueSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    type?: boolean
    actif?: boolean
    createdAt?: boolean
  }

  export type CentreAnalytiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "libelle" | "type" | "actif" | "createdAt", ExtArgs["result"]["centreAnalytique"]>
  export type CentreAnalytiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ecritures?: boolean | CentreAnalytique$ecrituresArgs<ExtArgs>
    _count?: boolean | CentreAnalytiqueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CentreAnalytiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CentreAnalytiqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CentreAnalytiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CentreAnalytique"
    objects: {
      ecritures: Prisma.$EcritureComptablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      libelle: string
      type: string
      actif: boolean
      createdAt: Date
    }, ExtArgs["result"]["centreAnalytique"]>
    composites: {}
  }

  type CentreAnalytiqueGetPayload<S extends boolean | null | undefined | CentreAnalytiqueDefaultArgs> = $Result.GetResult<Prisma.$CentreAnalytiquePayload, S>

  type CentreAnalytiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CentreAnalytiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CentreAnalytiqueCountAggregateInputType | true
    }

  export interface CentreAnalytiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CentreAnalytique'], meta: { name: 'CentreAnalytique' } }
    /**
     * Find zero or one CentreAnalytique that matches the filter.
     * @param {CentreAnalytiqueFindUniqueArgs} args - Arguments to find a CentreAnalytique
     * @example
     * // Get one CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CentreAnalytiqueFindUniqueArgs>(args: SelectSubset<T, CentreAnalytiqueFindUniqueArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CentreAnalytique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CentreAnalytiqueFindUniqueOrThrowArgs} args - Arguments to find a CentreAnalytique
     * @example
     * // Get one CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CentreAnalytiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, CentreAnalytiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CentreAnalytique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueFindFirstArgs} args - Arguments to find a CentreAnalytique
     * @example
     * // Get one CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CentreAnalytiqueFindFirstArgs>(args?: SelectSubset<T, CentreAnalytiqueFindFirstArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CentreAnalytique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueFindFirstOrThrowArgs} args - Arguments to find a CentreAnalytique
     * @example
     * // Get one CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CentreAnalytiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, CentreAnalytiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CentreAnalytiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CentreAnalytiques
     * const centreAnalytiques = await prisma.centreAnalytique.findMany()
     * 
     * // Get first 10 CentreAnalytiques
     * const centreAnalytiques = await prisma.centreAnalytique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const centreAnalytiqueWithIdOnly = await prisma.centreAnalytique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CentreAnalytiqueFindManyArgs>(args?: SelectSubset<T, CentreAnalytiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CentreAnalytique.
     * @param {CentreAnalytiqueCreateArgs} args - Arguments to create a CentreAnalytique.
     * @example
     * // Create one CentreAnalytique
     * const CentreAnalytique = await prisma.centreAnalytique.create({
     *   data: {
     *     // ... data to create a CentreAnalytique
     *   }
     * })
     * 
     */
    create<T extends CentreAnalytiqueCreateArgs>(args: SelectSubset<T, CentreAnalytiqueCreateArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CentreAnalytiques.
     * @param {CentreAnalytiqueCreateManyArgs} args - Arguments to create many CentreAnalytiques.
     * @example
     * // Create many CentreAnalytiques
     * const centreAnalytique = await prisma.centreAnalytique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CentreAnalytiqueCreateManyArgs>(args?: SelectSubset<T, CentreAnalytiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CentreAnalytiques and returns the data saved in the database.
     * @param {CentreAnalytiqueCreateManyAndReturnArgs} args - Arguments to create many CentreAnalytiques.
     * @example
     * // Create many CentreAnalytiques
     * const centreAnalytique = await prisma.centreAnalytique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CentreAnalytiques and only return the `id`
     * const centreAnalytiqueWithIdOnly = await prisma.centreAnalytique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CentreAnalytiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, CentreAnalytiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CentreAnalytique.
     * @param {CentreAnalytiqueDeleteArgs} args - Arguments to delete one CentreAnalytique.
     * @example
     * // Delete one CentreAnalytique
     * const CentreAnalytique = await prisma.centreAnalytique.delete({
     *   where: {
     *     // ... filter to delete one CentreAnalytique
     *   }
     * })
     * 
     */
    delete<T extends CentreAnalytiqueDeleteArgs>(args: SelectSubset<T, CentreAnalytiqueDeleteArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CentreAnalytique.
     * @param {CentreAnalytiqueUpdateArgs} args - Arguments to update one CentreAnalytique.
     * @example
     * // Update one CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CentreAnalytiqueUpdateArgs>(args: SelectSubset<T, CentreAnalytiqueUpdateArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CentreAnalytiques.
     * @param {CentreAnalytiqueDeleteManyArgs} args - Arguments to filter CentreAnalytiques to delete.
     * @example
     * // Delete a few CentreAnalytiques
     * const { count } = await prisma.centreAnalytique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CentreAnalytiqueDeleteManyArgs>(args?: SelectSubset<T, CentreAnalytiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CentreAnalytiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CentreAnalytiques
     * const centreAnalytique = await prisma.centreAnalytique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CentreAnalytiqueUpdateManyArgs>(args: SelectSubset<T, CentreAnalytiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CentreAnalytiques and returns the data updated in the database.
     * @param {CentreAnalytiqueUpdateManyAndReturnArgs} args - Arguments to update many CentreAnalytiques.
     * @example
     * // Update many CentreAnalytiques
     * const centreAnalytique = await prisma.centreAnalytique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CentreAnalytiques and only return the `id`
     * const centreAnalytiqueWithIdOnly = await prisma.centreAnalytique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CentreAnalytiqueUpdateManyAndReturnArgs>(args: SelectSubset<T, CentreAnalytiqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CentreAnalytique.
     * @param {CentreAnalytiqueUpsertArgs} args - Arguments to update or create a CentreAnalytique.
     * @example
     * // Update or create a CentreAnalytique
     * const centreAnalytique = await prisma.centreAnalytique.upsert({
     *   create: {
     *     // ... data to create a CentreAnalytique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CentreAnalytique we want to update
     *   }
     * })
     */
    upsert<T extends CentreAnalytiqueUpsertArgs>(args: SelectSubset<T, CentreAnalytiqueUpsertArgs<ExtArgs>>): Prisma__CentreAnalytiqueClient<$Result.GetResult<Prisma.$CentreAnalytiquePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CentreAnalytiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueCountArgs} args - Arguments to filter CentreAnalytiques to count.
     * @example
     * // Count the number of CentreAnalytiques
     * const count = await prisma.centreAnalytique.count({
     *   where: {
     *     // ... the filter for the CentreAnalytiques we want to count
     *   }
     * })
    **/
    count<T extends CentreAnalytiqueCountArgs>(
      args?: Subset<T, CentreAnalytiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CentreAnalytiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CentreAnalytique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CentreAnalytiqueAggregateArgs>(args: Subset<T, CentreAnalytiqueAggregateArgs>): Prisma.PrismaPromise<GetCentreAnalytiqueAggregateType<T>>

    /**
     * Group by CentreAnalytique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CentreAnalytiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CentreAnalytiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CentreAnalytiqueGroupByArgs['orderBy'] }
        : { orderBy?: CentreAnalytiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CentreAnalytiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCentreAnalytiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CentreAnalytique model
   */
  readonly fields: CentreAnalytiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CentreAnalytique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CentreAnalytiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ecritures<T extends CentreAnalytique$ecrituresArgs<ExtArgs> = {}>(args?: Subset<T, CentreAnalytique$ecrituresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EcritureComptablePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CentreAnalytique model
   */ 
  interface CentreAnalytiqueFieldRefs {
    readonly id: FieldRef<"CentreAnalytique", 'String'>
    readonly code: FieldRef<"CentreAnalytique", 'String'>
    readonly libelle: FieldRef<"CentreAnalytique", 'String'>
    readonly type: FieldRef<"CentreAnalytique", 'String'>
    readonly actif: FieldRef<"CentreAnalytique", 'Boolean'>
    readonly createdAt: FieldRef<"CentreAnalytique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CentreAnalytique findUnique
   */
  export type CentreAnalytiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter, which CentreAnalytique to fetch.
     */
    where: CentreAnalytiqueWhereUniqueInput
  }

  /**
   * CentreAnalytique findUniqueOrThrow
   */
  export type CentreAnalytiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter, which CentreAnalytique to fetch.
     */
    where: CentreAnalytiqueWhereUniqueInput
  }

  /**
   * CentreAnalytique findFirst
   */
  export type CentreAnalytiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter, which CentreAnalytique to fetch.
     */
    where?: CentreAnalytiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CentreAnalytiques to fetch.
     */
    orderBy?: CentreAnalytiqueOrderByWithRelationInput | CentreAnalytiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CentreAnalytiques.
     */
    cursor?: CentreAnalytiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CentreAnalytiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CentreAnalytiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CentreAnalytiques.
     */
    distinct?: CentreAnalytiqueScalarFieldEnum | CentreAnalytiqueScalarFieldEnum[]
  }

  /**
   * CentreAnalytique findFirstOrThrow
   */
  export type CentreAnalytiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter, which CentreAnalytique to fetch.
     */
    where?: CentreAnalytiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CentreAnalytiques to fetch.
     */
    orderBy?: CentreAnalytiqueOrderByWithRelationInput | CentreAnalytiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CentreAnalytiques.
     */
    cursor?: CentreAnalytiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CentreAnalytiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CentreAnalytiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CentreAnalytiques.
     */
    distinct?: CentreAnalytiqueScalarFieldEnum | CentreAnalytiqueScalarFieldEnum[]
  }

  /**
   * CentreAnalytique findMany
   */
  export type CentreAnalytiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter, which CentreAnalytiques to fetch.
     */
    where?: CentreAnalytiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CentreAnalytiques to fetch.
     */
    orderBy?: CentreAnalytiqueOrderByWithRelationInput | CentreAnalytiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CentreAnalytiques.
     */
    cursor?: CentreAnalytiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CentreAnalytiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CentreAnalytiques.
     */
    skip?: number
    distinct?: CentreAnalytiqueScalarFieldEnum | CentreAnalytiqueScalarFieldEnum[]
  }

  /**
   * CentreAnalytique create
   */
  export type CentreAnalytiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a CentreAnalytique.
     */
    data: XOR<CentreAnalytiqueCreateInput, CentreAnalytiqueUncheckedCreateInput>
  }

  /**
   * CentreAnalytique createMany
   */
  export type CentreAnalytiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CentreAnalytiques.
     */
    data: CentreAnalytiqueCreateManyInput | CentreAnalytiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CentreAnalytique createManyAndReturn
   */
  export type CentreAnalytiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * The data used to create many CentreAnalytiques.
     */
    data: CentreAnalytiqueCreateManyInput | CentreAnalytiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CentreAnalytique update
   */
  export type CentreAnalytiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a CentreAnalytique.
     */
    data: XOR<CentreAnalytiqueUpdateInput, CentreAnalytiqueUncheckedUpdateInput>
    /**
     * Choose, which CentreAnalytique to update.
     */
    where: CentreAnalytiqueWhereUniqueInput
  }

  /**
   * CentreAnalytique updateMany
   */
  export type CentreAnalytiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CentreAnalytiques.
     */
    data: XOR<CentreAnalytiqueUpdateManyMutationInput, CentreAnalytiqueUncheckedUpdateManyInput>
    /**
     * Filter which CentreAnalytiques to update
     */
    where?: CentreAnalytiqueWhereInput
  }

  /**
   * CentreAnalytique updateManyAndReturn
   */
  export type CentreAnalytiqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * The data used to update CentreAnalytiques.
     */
    data: XOR<CentreAnalytiqueUpdateManyMutationInput, CentreAnalytiqueUncheckedUpdateManyInput>
    /**
     * Filter which CentreAnalytiques to update
     */
    where?: CentreAnalytiqueWhereInput
  }

  /**
   * CentreAnalytique upsert
   */
  export type CentreAnalytiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the CentreAnalytique to update in case it exists.
     */
    where: CentreAnalytiqueWhereUniqueInput
    /**
     * In case the CentreAnalytique found by the `where` argument doesn't exist, create a new CentreAnalytique with this data.
     */
    create: XOR<CentreAnalytiqueCreateInput, CentreAnalytiqueUncheckedCreateInput>
    /**
     * In case the CentreAnalytique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CentreAnalytiqueUpdateInput, CentreAnalytiqueUncheckedUpdateInput>
  }

  /**
   * CentreAnalytique delete
   */
  export type CentreAnalytiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
    /**
     * Filter which CentreAnalytique to delete.
     */
    where: CentreAnalytiqueWhereUniqueInput
  }

  /**
   * CentreAnalytique deleteMany
   */
  export type CentreAnalytiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CentreAnalytiques to delete
     */
    where?: CentreAnalytiqueWhereInput
  }

  /**
   * CentreAnalytique.ecritures
   */
  export type CentreAnalytique$ecrituresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EcritureComptable
     */
    select?: EcritureComptableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EcritureComptable
     */
    omit?: EcritureComptableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EcritureComptableInclude<ExtArgs> | null
    where?: EcritureComptableWhereInput
    orderBy?: EcritureComptableOrderByWithRelationInput | EcritureComptableOrderByWithRelationInput[]
    cursor?: EcritureComptableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EcritureComptableScalarFieldEnum | EcritureComptableScalarFieldEnum[]
  }

  /**
   * CentreAnalytique without action
   */
  export type CentreAnalytiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CentreAnalytique
     */
    select?: CentreAnalytiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CentreAnalytique
     */
    omit?: CentreAnalytiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CentreAnalytiqueInclude<ExtArgs> | null
  }


  /**
   * Model Budget
   */

  export type AggregateBudget = {
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  export type BudgetAvgAggregateOutputType = {
    montant: Decimal | null
    mois: number | null
  }

  export type BudgetSumAggregateOutputType = {
    montant: Decimal | null
    mois: number | null
  }

  export type BudgetMinAggregateOutputType = {
    id: string | null
    exerciceId: string | null
    compte: string | null
    libelle: string | null
    montant: Decimal | null
    type: string | null
    mois: number | null
    createdAt: Date | null
  }

  export type BudgetMaxAggregateOutputType = {
    id: string | null
    exerciceId: string | null
    compte: string | null
    libelle: string | null
    montant: Decimal | null
    type: string | null
    mois: number | null
    createdAt: Date | null
  }

  export type BudgetCountAggregateOutputType = {
    id: number
    exerciceId: number
    compte: number
    libelle: number
    montant: number
    type: number
    mois: number
    createdAt: number
    _all: number
  }


  export type BudgetAvgAggregateInputType = {
    montant?: true
    mois?: true
  }

  export type BudgetSumAggregateInputType = {
    montant?: true
    mois?: true
  }

  export type BudgetMinAggregateInputType = {
    id?: true
    exerciceId?: true
    compte?: true
    libelle?: true
    montant?: true
    type?: true
    mois?: true
    createdAt?: true
  }

  export type BudgetMaxAggregateInputType = {
    id?: true
    exerciceId?: true
    compte?: true
    libelle?: true
    montant?: true
    type?: true
    mois?: true
    createdAt?: true
  }

  export type BudgetCountAggregateInputType = {
    id?: true
    exerciceId?: true
    compte?: true
    libelle?: true
    montant?: true
    type?: true
    mois?: true
    createdAt?: true
    _all?: true
  }

  export type BudgetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budget to aggregate.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Budgets
    **/
    _count?: true | BudgetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BudgetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BudgetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BudgetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BudgetMaxAggregateInputType
  }

  export type GetBudgetAggregateType<T extends BudgetAggregateArgs> = {
        [P in keyof T & keyof AggregateBudget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBudget[P]>
      : GetScalarType<T[P], AggregateBudget[P]>
  }




  export type BudgetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BudgetWhereInput
    orderBy?: BudgetOrderByWithAggregationInput | BudgetOrderByWithAggregationInput[]
    by: BudgetScalarFieldEnum[] | BudgetScalarFieldEnum
    having?: BudgetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BudgetCountAggregateInputType | true
    _avg?: BudgetAvgAggregateInputType
    _sum?: BudgetSumAggregateInputType
    _min?: BudgetMinAggregateInputType
    _max?: BudgetMaxAggregateInputType
  }

  export type BudgetGroupByOutputType = {
    id: string
    exerciceId: string
    compte: string
    libelle: string
    montant: Decimal
    type: string
    mois: number | null
    createdAt: Date
    _count: BudgetCountAggregateOutputType | null
    _avg: BudgetAvgAggregateOutputType | null
    _sum: BudgetSumAggregateOutputType | null
    _min: BudgetMinAggregateOutputType | null
    _max: BudgetMaxAggregateOutputType | null
  }

  type GetBudgetGroupByPayload<T extends BudgetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BudgetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BudgetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BudgetGroupByOutputType[P]>
            : GetScalarType<T[P], BudgetGroupByOutputType[P]>
        }
      >
    >


  export type BudgetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciceId?: boolean
    compte?: boolean
    libelle?: boolean
    montant?: boolean
    type?: boolean
    mois?: boolean
    createdAt?: boolean
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciceId?: boolean
    compte?: boolean
    libelle?: boolean
    montant?: boolean
    type?: boolean
    mois?: boolean
    createdAt?: boolean
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciceId?: boolean
    compte?: boolean
    libelle?: boolean
    montant?: boolean
    type?: boolean
    mois?: boolean
    createdAt?: boolean
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["budget"]>

  export type BudgetSelectScalar = {
    id?: boolean
    exerciceId?: boolean
    compte?: boolean
    libelle?: boolean
    montant?: boolean
    type?: boolean
    mois?: boolean
    createdAt?: boolean
  }

  export type BudgetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exerciceId" | "compte" | "libelle" | "montant" | "type" | "mois" | "createdAt", ExtArgs["result"]["budget"]>
  export type BudgetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }
  export type BudgetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercice?: boolean | ExerciceComptableDefaultArgs<ExtArgs>
  }

  export type $BudgetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Budget"
    objects: {
      exercice: Prisma.$ExerciceComptablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exerciceId: string
      compte: string
      libelle: string
      montant: Prisma.Decimal
      type: string
      mois: number | null
      createdAt: Date
    }, ExtArgs["result"]["budget"]>
    composites: {}
  }

  type BudgetGetPayload<S extends boolean | null | undefined | BudgetDefaultArgs> = $Result.GetResult<Prisma.$BudgetPayload, S>

  type BudgetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BudgetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BudgetCountAggregateInputType | true
    }

  export interface BudgetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Budget'], meta: { name: 'Budget' } }
    /**
     * Find zero or one Budget that matches the filter.
     * @param {BudgetFindUniqueArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BudgetFindUniqueArgs>(args: SelectSubset<T, BudgetFindUniqueArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Budget that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BudgetFindUniqueOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BudgetFindUniqueOrThrowArgs>(args: SelectSubset<T, BudgetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Budget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BudgetFindFirstArgs>(args?: SelectSubset<T, BudgetFindFirstArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Budget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindFirstOrThrowArgs} args - Arguments to find a Budget
     * @example
     * // Get one Budget
     * const budget = await prisma.budget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BudgetFindFirstOrThrowArgs>(args?: SelectSubset<T, BudgetFindFirstOrThrowArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Budgets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Budgets
     * const budgets = await prisma.budget.findMany()
     * 
     * // Get first 10 Budgets
     * const budgets = await prisma.budget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const budgetWithIdOnly = await prisma.budget.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BudgetFindManyArgs>(args?: SelectSubset<T, BudgetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Budget.
     * @param {BudgetCreateArgs} args - Arguments to create a Budget.
     * @example
     * // Create one Budget
     * const Budget = await prisma.budget.create({
     *   data: {
     *     // ... data to create a Budget
     *   }
     * })
     * 
     */
    create<T extends BudgetCreateArgs>(args: SelectSubset<T, BudgetCreateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Budgets.
     * @param {BudgetCreateManyArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BudgetCreateManyArgs>(args?: SelectSubset<T, BudgetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Budgets and returns the data saved in the database.
     * @param {BudgetCreateManyAndReturnArgs} args - Arguments to create many Budgets.
     * @example
     * // Create many Budgets
     * const budget = await prisma.budget.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BudgetCreateManyAndReturnArgs>(args?: SelectSubset<T, BudgetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Budget.
     * @param {BudgetDeleteArgs} args - Arguments to delete one Budget.
     * @example
     * // Delete one Budget
     * const Budget = await prisma.budget.delete({
     *   where: {
     *     // ... filter to delete one Budget
     *   }
     * })
     * 
     */
    delete<T extends BudgetDeleteArgs>(args: SelectSubset<T, BudgetDeleteArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Budget.
     * @param {BudgetUpdateArgs} args - Arguments to update one Budget.
     * @example
     * // Update one Budget
     * const budget = await prisma.budget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BudgetUpdateArgs>(args: SelectSubset<T, BudgetUpdateArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Budgets.
     * @param {BudgetDeleteManyArgs} args - Arguments to filter Budgets to delete.
     * @example
     * // Delete a few Budgets
     * const { count } = await prisma.budget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BudgetDeleteManyArgs>(args?: SelectSubset<T, BudgetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BudgetUpdateManyArgs>(args: SelectSubset<T, BudgetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Budgets and returns the data updated in the database.
     * @param {BudgetUpdateManyAndReturnArgs} args - Arguments to update many Budgets.
     * @example
     * // Update many Budgets
     * const budget = await prisma.budget.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Budgets and only return the `id`
     * const budgetWithIdOnly = await prisma.budget.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BudgetUpdateManyAndReturnArgs>(args: SelectSubset<T, BudgetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Budget.
     * @param {BudgetUpsertArgs} args - Arguments to update or create a Budget.
     * @example
     * // Update or create a Budget
     * const budget = await prisma.budget.upsert({
     *   create: {
     *     // ... data to create a Budget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Budget we want to update
     *   }
     * })
     */
    upsert<T extends BudgetUpsertArgs>(args: SelectSubset<T, BudgetUpsertArgs<ExtArgs>>): Prisma__BudgetClient<$Result.GetResult<Prisma.$BudgetPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Budgets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetCountArgs} args - Arguments to filter Budgets to count.
     * @example
     * // Count the number of Budgets
     * const count = await prisma.budget.count({
     *   where: {
     *     // ... the filter for the Budgets we want to count
     *   }
     * })
    **/
    count<T extends BudgetCountArgs>(
      args?: Subset<T, BudgetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BudgetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BudgetAggregateArgs>(args: Subset<T, BudgetAggregateArgs>): Prisma.PrismaPromise<GetBudgetAggregateType<T>>

    /**
     * Group by Budget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BudgetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BudgetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BudgetGroupByArgs['orderBy'] }
        : { orderBy?: BudgetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BudgetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBudgetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Budget model
   */
  readonly fields: BudgetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Budget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BudgetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercice<T extends ExerciceComptableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciceComptableDefaultArgs<ExtArgs>>): Prisma__ExerciceComptableClient<$Result.GetResult<Prisma.$ExerciceComptablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Budget model
   */ 
  interface BudgetFieldRefs {
    readonly id: FieldRef<"Budget", 'String'>
    readonly exerciceId: FieldRef<"Budget", 'String'>
    readonly compte: FieldRef<"Budget", 'String'>
    readonly libelle: FieldRef<"Budget", 'String'>
    readonly montant: FieldRef<"Budget", 'Decimal'>
    readonly type: FieldRef<"Budget", 'String'>
    readonly mois: FieldRef<"Budget", 'Int'>
    readonly createdAt: FieldRef<"Budget", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Budget findUnique
   */
  export type BudgetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findUniqueOrThrow
   */
  export type BudgetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget findFirst
   */
  export type BudgetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findFirstOrThrow
   */
  export type BudgetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budget to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Budgets.
     */
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget findMany
   */
  export type BudgetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter, which Budgets to fetch.
     */
    where?: BudgetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Budgets to fetch.
     */
    orderBy?: BudgetOrderByWithRelationInput | BudgetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Budgets.
     */
    cursor?: BudgetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Budgets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Budgets.
     */
    skip?: number
    distinct?: BudgetScalarFieldEnum | BudgetScalarFieldEnum[]
  }

  /**
   * Budget create
   */
  export type BudgetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to create a Budget.
     */
    data: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
  }

  /**
   * Budget createMany
   */
  export type BudgetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Budget createManyAndReturn
   */
  export type BudgetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to create many Budgets.
     */
    data: BudgetCreateManyInput | BudgetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget update
   */
  export type BudgetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The data needed to update a Budget.
     */
    data: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
    /**
     * Choose, which Budget to update.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget updateMany
   */
  export type BudgetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget updateManyAndReturn
   */
  export type BudgetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * The data used to update Budgets.
     */
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyInput>
    /**
     * Filter which Budgets to update
     */
    where?: BudgetWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Budget upsert
   */
  export type BudgetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * The filter to search for the Budget to update in case it exists.
     */
    where: BudgetWhereUniqueInput
    /**
     * In case the Budget found by the `where` argument doesn't exist, create a new Budget with this data.
     */
    create: XOR<BudgetCreateInput, BudgetUncheckedCreateInput>
    /**
     * In case the Budget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BudgetUpdateInput, BudgetUncheckedUpdateInput>
  }

  /**
   * Budget delete
   */
  export type BudgetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
    /**
     * Filter which Budget to delete.
     */
    where: BudgetWhereUniqueInput
  }

  /**
   * Budget deleteMany
   */
  export type BudgetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Budgets to delete
     */
    where?: BudgetWhereInput
  }

  /**
   * Budget without action
   */
  export type BudgetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Budget
     */
    select?: BudgetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Budget
     */
    omit?: BudgetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BudgetInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    tauxCouverture: Decimal | null
  }

  export type PatientSumAggregateOutputType = {
    tauxCouverture: Decimal | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    numeroPatient: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: string | null
    telephone: string | null
    email: string | null
    adresse: string | null
    ville: string | null
    profession: string | null
    situationMatrimoniale: string | null
    assureur: string | null
    numeroAssure: string | null
    tauxCouverture: Decimal | null
    contactUrgenceNom: string | null
    contactUrgenceTel: string | null
    contactUrgenceLien: string | null
    photo: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    numeroPatient: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: string | null
    telephone: string | null
    email: string | null
    adresse: string | null
    ville: string | null
    profession: string | null
    situationMatrimoniale: string | null
    assureur: string | null
    numeroAssure: string | null
    tauxCouverture: Decimal | null
    contactUrgenceNom: string | null
    contactUrgenceTel: string | null
    contactUrgenceLien: string | null
    photo: string | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    numeroPatient: number
    nom: number
    prenom: number
    dateNaissance: number
    sexe: number
    telephone: number
    email: number
    adresse: number
    ville: number
    profession: number
    situationMatrimoniale: number
    assureur: number
    numeroAssure: number
    tauxCouverture: number
    contactUrgenceNom: number
    contactUrgenceTel: number
    contactUrgenceLien: number
    photo: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    tauxCouverture?: true
  }

  export type PatientSumAggregateInputType = {
    tauxCouverture?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    numeroPatient?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    ville?: true
    profession?: true
    situationMatrimoniale?: true
    assureur?: true
    numeroAssure?: true
    tauxCouverture?: true
    contactUrgenceNom?: true
    contactUrgenceTel?: true
    contactUrgenceLien?: true
    photo?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    numeroPatient?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    ville?: true
    profession?: true
    situationMatrimoniale?: true
    assureur?: true
    numeroAssure?: true
    tauxCouverture?: true
    contactUrgenceNom?: true
    contactUrgenceTel?: true
    contactUrgenceLien?: true
    photo?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    numeroPatient?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    ville?: true
    profession?: true
    situationMatrimoniale?: true
    assureur?: true
    numeroAssure?: true
    tauxCouverture?: true
    contactUrgenceNom?: true
    contactUrgenceTel?: true
    contactUrgenceLien?: true
    photo?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date
    sexe: string
    telephone: string
    email: string | null
    adresse: string | null
    ville: string | null
    profession: string | null
    situationMatrimoniale: string | null
    assureur: string | null
    numeroAssure: string | null
    tauxCouverture: Decimal | null
    contactUrgenceNom: string | null
    contactUrgenceTel: string | null
    contactUrgenceLien: string | null
    photo: string | null
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroPatient?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    ville?: boolean
    profession?: boolean
    situationMatrimoniale?: boolean
    assureur?: boolean
    numeroAssure?: boolean
    tauxCouverture?: boolean
    contactUrgenceNom?: boolean
    contactUrgenceTel?: boolean
    contactUrgenceLien?: boolean
    photo?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    antecedents?: boolean | Patient$antecedentsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    vaccinations?: boolean | Patient$vaccinationsArgs<ExtArgs>
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    rendezvous?: boolean | Patient$rendezvousArgs<ExtArgs>
    factures?: boolean | Patient$facturesArgs<ExtArgs>
    dispensations?: boolean | Patient$dispensationsArgs<ExtArgs>
    hospitalisations?: boolean | Patient$hospitalisationsArgs<ExtArgs>
    interventions?: boolean | Patient$interventionsArgs<ExtArgs>
    dossiersMaternite?: boolean | Patient$dossiersMaterniteArgs<ExtArgs>
    documentsGED?: boolean | Patient$documentsGEDArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroPatient?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    ville?: boolean
    profession?: boolean
    situationMatrimoniale?: boolean
    assureur?: boolean
    numeroAssure?: boolean
    tauxCouverture?: boolean
    contactUrgenceNom?: boolean
    contactUrgenceTel?: boolean
    contactUrgenceLien?: boolean
    photo?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroPatient?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    ville?: boolean
    profession?: boolean
    situationMatrimoniale?: boolean
    assureur?: boolean
    numeroAssure?: boolean
    tauxCouverture?: boolean
    contactUrgenceNom?: boolean
    contactUrgenceTel?: boolean
    contactUrgenceLien?: boolean
    photo?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    numeroPatient?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    ville?: boolean
    profession?: boolean
    situationMatrimoniale?: boolean
    assureur?: boolean
    numeroAssure?: boolean
    tauxCouverture?: boolean
    contactUrgenceNom?: boolean
    contactUrgenceTel?: boolean
    contactUrgenceLien?: boolean
    photo?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroPatient" | "nom" | "prenom" | "dateNaissance" | "sexe" | "telephone" | "email" | "adresse" | "ville" | "profession" | "situationMatrimoniale" | "assureur" | "numeroAssure" | "tauxCouverture" | "contactUrgenceNom" | "contactUrgenceTel" | "contactUrgenceLien" | "photo" | "actif" | "createdAt" | "updatedAt", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    antecedents?: boolean | Patient$antecedentsArgs<ExtArgs>
    allergies?: boolean | Patient$allergiesArgs<ExtArgs>
    vaccinations?: boolean | Patient$vaccinationsArgs<ExtArgs>
    consultations?: boolean | Patient$consultationsArgs<ExtArgs>
    rendezvous?: boolean | Patient$rendezvousArgs<ExtArgs>
    factures?: boolean | Patient$facturesArgs<ExtArgs>
    dispensations?: boolean | Patient$dispensationsArgs<ExtArgs>
    hospitalisations?: boolean | Patient$hospitalisationsArgs<ExtArgs>
    interventions?: boolean | Patient$interventionsArgs<ExtArgs>
    dossiersMaternite?: boolean | Patient$dossiersMaterniteArgs<ExtArgs>
    documentsGED?: boolean | Patient$documentsGEDArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      antecedents: Prisma.$AntecedentPayload<ExtArgs>[]
      allergies: Prisma.$AllergiePayload<ExtArgs>[]
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
      rendezvous: Prisma.$RendezVousPayload<ExtArgs>[]
      factures: Prisma.$FacturePayload<ExtArgs>[]
      dispensations: Prisma.$DispensationPayload<ExtArgs>[]
      hospitalisations: Prisma.$HospitalisationPayload<ExtArgs>[]
      interventions: Prisma.$InterventionPayload<ExtArgs>[]
      dossiersMaternite: Prisma.$DossierMaternitePayload<ExtArgs>[]
      documentsGED: Prisma.$DocumentGEDPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroPatient: string
      nom: string
      prenom: string
      dateNaissance: Date
      sexe: string
      telephone: string
      email: string | null
      adresse: string | null
      ville: string | null
      profession: string | null
      situationMatrimoniale: string | null
      assureur: string | null
      numeroAssure: string | null
      tauxCouverture: Prisma.Decimal | null
      contactUrgenceNom: string | null
      contactUrgenceTel: string | null
      contactUrgenceLien: string | null
      photo: string | null
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    antecedents<T extends Patient$antecedentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$antecedentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    allergies<T extends Patient$allergiesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$allergiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    vaccinations<T extends Patient$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    consultations<T extends Patient$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    rendezvous<T extends Patient$rendezvousArgs<ExtArgs> = {}>(args?: Subset<T, Patient$rendezvousArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    factures<T extends Patient$facturesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$facturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dispensations<T extends Patient$dispensationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$dispensationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    hospitalisations<T extends Patient$hospitalisationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$hospitalisationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    interventions<T extends Patient$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dossiersMaternite<T extends Patient$dossiersMaterniteArgs<ExtArgs> = {}>(args?: Subset<T, Patient$dossiersMaterniteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    documentsGED<T extends Patient$documentsGEDArgs<ExtArgs> = {}>(args?: Subset<T, Patient$documentsGEDArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly numeroPatient: FieldRef<"Patient", 'String'>
    readonly nom: FieldRef<"Patient", 'String'>
    readonly prenom: FieldRef<"Patient", 'String'>
    readonly dateNaissance: FieldRef<"Patient", 'DateTime'>
    readonly sexe: FieldRef<"Patient", 'String'>
    readonly telephone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly adresse: FieldRef<"Patient", 'String'>
    readonly ville: FieldRef<"Patient", 'String'>
    readonly profession: FieldRef<"Patient", 'String'>
    readonly situationMatrimoniale: FieldRef<"Patient", 'String'>
    readonly assureur: FieldRef<"Patient", 'String'>
    readonly numeroAssure: FieldRef<"Patient", 'String'>
    readonly tauxCouverture: FieldRef<"Patient", 'Decimal'>
    readonly contactUrgenceNom: FieldRef<"Patient", 'String'>
    readonly contactUrgenceTel: FieldRef<"Patient", 'String'>
    readonly contactUrgenceLien: FieldRef<"Patient", 'String'>
    readonly photo: FieldRef<"Patient", 'String'>
    readonly actif: FieldRef<"Patient", 'Boolean'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.antecedents
   */
  export type Patient$antecedentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    where?: AntecedentWhereInput
    orderBy?: AntecedentOrderByWithRelationInput | AntecedentOrderByWithRelationInput[]
    cursor?: AntecedentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AntecedentScalarFieldEnum | AntecedentScalarFieldEnum[]
  }

  /**
   * Patient.allergies
   */
  export type Patient$allergiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    where?: AllergieWhereInput
    orderBy?: AllergieOrderByWithRelationInput | AllergieOrderByWithRelationInput[]
    cursor?: AllergieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AllergieScalarFieldEnum | AllergieScalarFieldEnum[]
  }

  /**
   * Patient.vaccinations
   */
  export type Patient$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Patient.consultations
   */
  export type Patient$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Patient.rendezvous
   */
  export type Patient$rendezvousArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    where?: RendezVousWhereInput
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    cursor?: RendezVousWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RendezVousScalarFieldEnum | RendezVousScalarFieldEnum[]
  }

  /**
   * Patient.factures
   */
  export type Patient$facturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    where?: FactureWhereInput
    orderBy?: FactureOrderByWithRelationInput | FactureOrderByWithRelationInput[]
    cursor?: FactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }

  /**
   * Patient.dispensations
   */
  export type Patient$dispensationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    where?: DispensationWhereInput
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    cursor?: DispensationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispensationScalarFieldEnum | DispensationScalarFieldEnum[]
  }

  /**
   * Patient.hospitalisations
   */
  export type Patient$hospitalisationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    where?: HospitalisationWhereInput
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    cursor?: HospitalisationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HospitalisationScalarFieldEnum | HospitalisationScalarFieldEnum[]
  }

  /**
   * Patient.interventions
   */
  export type Patient$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Patient.dossiersMaternite
   */
  export type Patient$dossiersMaterniteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    where?: DossierMaterniteWhereInput
    orderBy?: DossierMaterniteOrderByWithRelationInput | DossierMaterniteOrderByWithRelationInput[]
    cursor?: DossierMaterniteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DossierMaterniteScalarFieldEnum | DossierMaterniteScalarFieldEnum[]
  }

  /**
   * Patient.documentsGED
   */
  export type Patient$documentsGEDArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    where?: DocumentGEDWhereInput
    orderBy?: DocumentGEDOrderByWithRelationInput | DocumentGEDOrderByWithRelationInput[]
    cursor?: DocumentGEDWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentGEDScalarFieldEnum | DocumentGEDScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Antecedent
   */

  export type AggregateAntecedent = {
    _count: AntecedentCountAggregateOutputType | null
    _min: AntecedentMinAggregateOutputType | null
    _max: AntecedentMaxAggregateOutputType | null
  }

  export type AntecedentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    description: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type AntecedentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    description: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type AntecedentCountAggregateOutputType = {
    id: number
    patientId: number
    type: number
    description: number
    date: number
    createdAt: number
    _all: number
  }


  export type AntecedentMinAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    description?: true
    date?: true
    createdAt?: true
  }

  export type AntecedentMaxAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    description?: true
    date?: true
    createdAt?: true
  }

  export type AntecedentCountAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    description?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type AntecedentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Antecedent to aggregate.
     */
    where?: AntecedentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Antecedents to fetch.
     */
    orderBy?: AntecedentOrderByWithRelationInput | AntecedentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AntecedentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Antecedents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Antecedents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Antecedents
    **/
    _count?: true | AntecedentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AntecedentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AntecedentMaxAggregateInputType
  }

  export type GetAntecedentAggregateType<T extends AntecedentAggregateArgs> = {
        [P in keyof T & keyof AggregateAntecedent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAntecedent[P]>
      : GetScalarType<T[P], AggregateAntecedent[P]>
  }




  export type AntecedentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentWhereInput
    orderBy?: AntecedentOrderByWithAggregationInput | AntecedentOrderByWithAggregationInput[]
    by: AntecedentScalarFieldEnum[] | AntecedentScalarFieldEnum
    having?: AntecedentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AntecedentCountAggregateInputType | true
    _min?: AntecedentMinAggregateInputType
    _max?: AntecedentMaxAggregateInputType
  }

  export type AntecedentGroupByOutputType = {
    id: string
    patientId: string
    type: string
    description: string
    date: Date | null
    createdAt: Date
    _count: AntecedentCountAggregateOutputType | null
    _min: AntecedentMinAggregateOutputType | null
    _max: AntecedentMaxAggregateOutputType | null
  }

  type GetAntecedentGroupByPayload<T extends AntecedentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AntecedentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AntecedentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AntecedentGroupByOutputType[P]>
            : GetScalarType<T[P], AntecedentGroupByOutputType[P]>
        }
      >
    >


  export type AntecedentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["antecedent"]>

  export type AntecedentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["antecedent"]>

  export type AntecedentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["antecedent"]>

  export type AntecedentSelectScalar = {
    id?: boolean
    patientId?: boolean
    type?: boolean
    description?: boolean
    date?: boolean
    createdAt?: boolean
  }

  export type AntecedentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "type" | "description" | "date" | "createdAt", ExtArgs["result"]["antecedent"]>
  export type AntecedentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AntecedentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AntecedentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AntecedentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Antecedent"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      type: string
      description: string
      date: Date | null
      createdAt: Date
    }, ExtArgs["result"]["antecedent"]>
    composites: {}
  }

  type AntecedentGetPayload<S extends boolean | null | undefined | AntecedentDefaultArgs> = $Result.GetResult<Prisma.$AntecedentPayload, S>

  type AntecedentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AntecedentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AntecedentCountAggregateInputType | true
    }

  export interface AntecedentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Antecedent'], meta: { name: 'Antecedent' } }
    /**
     * Find zero or one Antecedent that matches the filter.
     * @param {AntecedentFindUniqueArgs} args - Arguments to find a Antecedent
     * @example
     * // Get one Antecedent
     * const antecedent = await prisma.antecedent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AntecedentFindUniqueArgs>(args: SelectSubset<T, AntecedentFindUniqueArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Antecedent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AntecedentFindUniqueOrThrowArgs} args - Arguments to find a Antecedent
     * @example
     * // Get one Antecedent
     * const antecedent = await prisma.antecedent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AntecedentFindUniqueOrThrowArgs>(args: SelectSubset<T, AntecedentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Antecedent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentFindFirstArgs} args - Arguments to find a Antecedent
     * @example
     * // Get one Antecedent
     * const antecedent = await prisma.antecedent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AntecedentFindFirstArgs>(args?: SelectSubset<T, AntecedentFindFirstArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Antecedent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentFindFirstOrThrowArgs} args - Arguments to find a Antecedent
     * @example
     * // Get one Antecedent
     * const antecedent = await prisma.antecedent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AntecedentFindFirstOrThrowArgs>(args?: SelectSubset<T, AntecedentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Antecedents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Antecedents
     * const antecedents = await prisma.antecedent.findMany()
     * 
     * // Get first 10 Antecedents
     * const antecedents = await prisma.antecedent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const antecedentWithIdOnly = await prisma.antecedent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AntecedentFindManyArgs>(args?: SelectSubset<T, AntecedentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Antecedent.
     * @param {AntecedentCreateArgs} args - Arguments to create a Antecedent.
     * @example
     * // Create one Antecedent
     * const Antecedent = await prisma.antecedent.create({
     *   data: {
     *     // ... data to create a Antecedent
     *   }
     * })
     * 
     */
    create<T extends AntecedentCreateArgs>(args: SelectSubset<T, AntecedentCreateArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Antecedents.
     * @param {AntecedentCreateManyArgs} args - Arguments to create many Antecedents.
     * @example
     * // Create many Antecedents
     * const antecedent = await prisma.antecedent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AntecedentCreateManyArgs>(args?: SelectSubset<T, AntecedentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Antecedents and returns the data saved in the database.
     * @param {AntecedentCreateManyAndReturnArgs} args - Arguments to create many Antecedents.
     * @example
     * // Create many Antecedents
     * const antecedent = await prisma.antecedent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Antecedents and only return the `id`
     * const antecedentWithIdOnly = await prisma.antecedent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AntecedentCreateManyAndReturnArgs>(args?: SelectSubset<T, AntecedentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Antecedent.
     * @param {AntecedentDeleteArgs} args - Arguments to delete one Antecedent.
     * @example
     * // Delete one Antecedent
     * const Antecedent = await prisma.antecedent.delete({
     *   where: {
     *     // ... filter to delete one Antecedent
     *   }
     * })
     * 
     */
    delete<T extends AntecedentDeleteArgs>(args: SelectSubset<T, AntecedentDeleteArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Antecedent.
     * @param {AntecedentUpdateArgs} args - Arguments to update one Antecedent.
     * @example
     * // Update one Antecedent
     * const antecedent = await prisma.antecedent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AntecedentUpdateArgs>(args: SelectSubset<T, AntecedentUpdateArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Antecedents.
     * @param {AntecedentDeleteManyArgs} args - Arguments to filter Antecedents to delete.
     * @example
     * // Delete a few Antecedents
     * const { count } = await prisma.antecedent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AntecedentDeleteManyArgs>(args?: SelectSubset<T, AntecedentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Antecedents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Antecedents
     * const antecedent = await prisma.antecedent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AntecedentUpdateManyArgs>(args: SelectSubset<T, AntecedentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Antecedents and returns the data updated in the database.
     * @param {AntecedentUpdateManyAndReturnArgs} args - Arguments to update many Antecedents.
     * @example
     * // Update many Antecedents
     * const antecedent = await prisma.antecedent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Antecedents and only return the `id`
     * const antecedentWithIdOnly = await prisma.antecedent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AntecedentUpdateManyAndReturnArgs>(args: SelectSubset<T, AntecedentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Antecedent.
     * @param {AntecedentUpsertArgs} args - Arguments to update or create a Antecedent.
     * @example
     * // Update or create a Antecedent
     * const antecedent = await prisma.antecedent.upsert({
     *   create: {
     *     // ... data to create a Antecedent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Antecedent we want to update
     *   }
     * })
     */
    upsert<T extends AntecedentUpsertArgs>(args: SelectSubset<T, AntecedentUpsertArgs<ExtArgs>>): Prisma__AntecedentClient<$Result.GetResult<Prisma.$AntecedentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Antecedents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentCountArgs} args - Arguments to filter Antecedents to count.
     * @example
     * // Count the number of Antecedents
     * const count = await prisma.antecedent.count({
     *   where: {
     *     // ... the filter for the Antecedents we want to count
     *   }
     * })
    **/
    count<T extends AntecedentCountArgs>(
      args?: Subset<T, AntecedentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AntecedentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Antecedent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AntecedentAggregateArgs>(args: Subset<T, AntecedentAggregateArgs>): Prisma.PrismaPromise<GetAntecedentAggregateType<T>>

    /**
     * Group by Antecedent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AntecedentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AntecedentGroupByArgs['orderBy'] }
        : { orderBy?: AntecedentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AntecedentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAntecedentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Antecedent model
   */
  readonly fields: AntecedentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Antecedent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AntecedentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Antecedent model
   */ 
  interface AntecedentFieldRefs {
    readonly id: FieldRef<"Antecedent", 'String'>
    readonly patientId: FieldRef<"Antecedent", 'String'>
    readonly type: FieldRef<"Antecedent", 'String'>
    readonly description: FieldRef<"Antecedent", 'String'>
    readonly date: FieldRef<"Antecedent", 'DateTime'>
    readonly createdAt: FieldRef<"Antecedent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Antecedent findUnique
   */
  export type AntecedentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter, which Antecedent to fetch.
     */
    where: AntecedentWhereUniqueInput
  }

  /**
   * Antecedent findUniqueOrThrow
   */
  export type AntecedentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter, which Antecedent to fetch.
     */
    where: AntecedentWhereUniqueInput
  }

  /**
   * Antecedent findFirst
   */
  export type AntecedentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter, which Antecedent to fetch.
     */
    where?: AntecedentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Antecedents to fetch.
     */
    orderBy?: AntecedentOrderByWithRelationInput | AntecedentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Antecedents.
     */
    cursor?: AntecedentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Antecedents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Antecedents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Antecedents.
     */
    distinct?: AntecedentScalarFieldEnum | AntecedentScalarFieldEnum[]
  }

  /**
   * Antecedent findFirstOrThrow
   */
  export type AntecedentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter, which Antecedent to fetch.
     */
    where?: AntecedentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Antecedents to fetch.
     */
    orderBy?: AntecedentOrderByWithRelationInput | AntecedentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Antecedents.
     */
    cursor?: AntecedentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Antecedents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Antecedents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Antecedents.
     */
    distinct?: AntecedentScalarFieldEnum | AntecedentScalarFieldEnum[]
  }

  /**
   * Antecedent findMany
   */
  export type AntecedentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter, which Antecedents to fetch.
     */
    where?: AntecedentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Antecedents to fetch.
     */
    orderBy?: AntecedentOrderByWithRelationInput | AntecedentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Antecedents.
     */
    cursor?: AntecedentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Antecedents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Antecedents.
     */
    skip?: number
    distinct?: AntecedentScalarFieldEnum | AntecedentScalarFieldEnum[]
  }

  /**
   * Antecedent create
   */
  export type AntecedentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * The data needed to create a Antecedent.
     */
    data: XOR<AntecedentCreateInput, AntecedentUncheckedCreateInput>
  }

  /**
   * Antecedent createMany
   */
  export type AntecedentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Antecedents.
     */
    data: AntecedentCreateManyInput | AntecedentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Antecedent createManyAndReturn
   */
  export type AntecedentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * The data used to create many Antecedents.
     */
    data: AntecedentCreateManyInput | AntecedentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Antecedent update
   */
  export type AntecedentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * The data needed to update a Antecedent.
     */
    data: XOR<AntecedentUpdateInput, AntecedentUncheckedUpdateInput>
    /**
     * Choose, which Antecedent to update.
     */
    where: AntecedentWhereUniqueInput
  }

  /**
   * Antecedent updateMany
   */
  export type AntecedentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Antecedents.
     */
    data: XOR<AntecedentUpdateManyMutationInput, AntecedentUncheckedUpdateManyInput>
    /**
     * Filter which Antecedents to update
     */
    where?: AntecedentWhereInput
  }

  /**
   * Antecedent updateManyAndReturn
   */
  export type AntecedentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * The data used to update Antecedents.
     */
    data: XOR<AntecedentUpdateManyMutationInput, AntecedentUncheckedUpdateManyInput>
    /**
     * Filter which Antecedents to update
     */
    where?: AntecedentWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Antecedent upsert
   */
  export type AntecedentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * The filter to search for the Antecedent to update in case it exists.
     */
    where: AntecedentWhereUniqueInput
    /**
     * In case the Antecedent found by the `where` argument doesn't exist, create a new Antecedent with this data.
     */
    create: XOR<AntecedentCreateInput, AntecedentUncheckedCreateInput>
    /**
     * In case the Antecedent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AntecedentUpdateInput, AntecedentUncheckedUpdateInput>
  }

  /**
   * Antecedent delete
   */
  export type AntecedentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
    /**
     * Filter which Antecedent to delete.
     */
    where: AntecedentWhereUniqueInput
  }

  /**
   * Antecedent deleteMany
   */
  export type AntecedentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Antecedents to delete
     */
    where?: AntecedentWhereInput
  }

  /**
   * Antecedent without action
   */
  export type AntecedentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Antecedent
     */
    select?: AntecedentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Antecedent
     */
    omit?: AntecedentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AntecedentInclude<ExtArgs> | null
  }


  /**
   * Model Allergie
   */

  export type AggregateAllergie = {
    _count: AllergieCountAggregateOutputType | null
    _min: AllergieMinAggregateOutputType | null
    _max: AllergieMaxAggregateOutputType | null
  }

  export type AllergieMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    allergene: string | null
    severite: string | null
    reaction: string | null
    createdAt: Date | null
  }

  export type AllergieMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    type: string | null
    allergene: string | null
    severite: string | null
    reaction: string | null
    createdAt: Date | null
  }

  export type AllergieCountAggregateOutputType = {
    id: number
    patientId: number
    type: number
    allergene: number
    severite: number
    reaction: number
    createdAt: number
    _all: number
  }


  export type AllergieMinAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    allergene?: true
    severite?: true
    reaction?: true
    createdAt?: true
  }

  export type AllergieMaxAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    allergene?: true
    severite?: true
    reaction?: true
    createdAt?: true
  }

  export type AllergieCountAggregateInputType = {
    id?: true
    patientId?: true
    type?: true
    allergene?: true
    severite?: true
    reaction?: true
    createdAt?: true
    _all?: true
  }

  export type AllergieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergie to aggregate.
     */
    where?: AllergieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergieOrderByWithRelationInput | AllergieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AllergieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Allergies
    **/
    _count?: true | AllergieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AllergieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AllergieMaxAggregateInputType
  }

  export type GetAllergieAggregateType<T extends AllergieAggregateArgs> = {
        [P in keyof T & keyof AggregateAllergie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAllergie[P]>
      : GetScalarType<T[P], AggregateAllergie[P]>
  }




  export type AllergieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AllergieWhereInput
    orderBy?: AllergieOrderByWithAggregationInput | AllergieOrderByWithAggregationInput[]
    by: AllergieScalarFieldEnum[] | AllergieScalarFieldEnum
    having?: AllergieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AllergieCountAggregateInputType | true
    _min?: AllergieMinAggregateInputType
    _max?: AllergieMaxAggregateInputType
  }

  export type AllergieGroupByOutputType = {
    id: string
    patientId: string
    type: string
    allergene: string
    severite: string
    reaction: string | null
    createdAt: Date
    _count: AllergieCountAggregateOutputType | null
    _min: AllergieMinAggregateOutputType | null
    _max: AllergieMaxAggregateOutputType | null
  }

  type GetAllergieGroupByPayload<T extends AllergieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AllergieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AllergieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AllergieGroupByOutputType[P]>
            : GetScalarType<T[P], AllergieGroupByOutputType[P]>
        }
      >
    >


  export type AllergieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    allergene?: boolean
    severite?: boolean
    reaction?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergie"]>

  export type AllergieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    allergene?: boolean
    severite?: boolean
    reaction?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergie"]>

  export type AllergieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    type?: boolean
    allergene?: boolean
    severite?: boolean
    reaction?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["allergie"]>

  export type AllergieSelectScalar = {
    id?: boolean
    patientId?: boolean
    type?: boolean
    allergene?: boolean
    severite?: boolean
    reaction?: boolean
    createdAt?: boolean
  }

  export type AllergieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "type" | "allergene" | "severite" | "reaction" | "createdAt", ExtArgs["result"]["allergie"]>
  export type AllergieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AllergieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AllergiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Allergie"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      type: string
      allergene: string
      severite: string
      reaction: string | null
      createdAt: Date
    }, ExtArgs["result"]["allergie"]>
    composites: {}
  }

  type AllergieGetPayload<S extends boolean | null | undefined | AllergieDefaultArgs> = $Result.GetResult<Prisma.$AllergiePayload, S>

  type AllergieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AllergieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AllergieCountAggregateInputType | true
    }

  export interface AllergieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Allergie'], meta: { name: 'Allergie' } }
    /**
     * Find zero or one Allergie that matches the filter.
     * @param {AllergieFindUniqueArgs} args - Arguments to find a Allergie
     * @example
     * // Get one Allergie
     * const allergie = await prisma.allergie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AllergieFindUniqueArgs>(args: SelectSubset<T, AllergieFindUniqueArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Allergie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AllergieFindUniqueOrThrowArgs} args - Arguments to find a Allergie
     * @example
     * // Get one Allergie
     * const allergie = await prisma.allergie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AllergieFindUniqueOrThrowArgs>(args: SelectSubset<T, AllergieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Allergie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieFindFirstArgs} args - Arguments to find a Allergie
     * @example
     * // Get one Allergie
     * const allergie = await prisma.allergie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AllergieFindFirstArgs>(args?: SelectSubset<T, AllergieFindFirstArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Allergie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieFindFirstOrThrowArgs} args - Arguments to find a Allergie
     * @example
     * // Get one Allergie
     * const allergie = await prisma.allergie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AllergieFindFirstOrThrowArgs>(args?: SelectSubset<T, AllergieFindFirstOrThrowArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Allergies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Allergies
     * const allergies = await prisma.allergie.findMany()
     * 
     * // Get first 10 Allergies
     * const allergies = await prisma.allergie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const allergieWithIdOnly = await prisma.allergie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AllergieFindManyArgs>(args?: SelectSubset<T, AllergieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Allergie.
     * @param {AllergieCreateArgs} args - Arguments to create a Allergie.
     * @example
     * // Create one Allergie
     * const Allergie = await prisma.allergie.create({
     *   data: {
     *     // ... data to create a Allergie
     *   }
     * })
     * 
     */
    create<T extends AllergieCreateArgs>(args: SelectSubset<T, AllergieCreateArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Allergies.
     * @param {AllergieCreateManyArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergie = await prisma.allergie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AllergieCreateManyArgs>(args?: SelectSubset<T, AllergieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Allergies and returns the data saved in the database.
     * @param {AllergieCreateManyAndReturnArgs} args - Arguments to create many Allergies.
     * @example
     * // Create many Allergies
     * const allergie = await prisma.allergie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Allergies and only return the `id`
     * const allergieWithIdOnly = await prisma.allergie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AllergieCreateManyAndReturnArgs>(args?: SelectSubset<T, AllergieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Allergie.
     * @param {AllergieDeleteArgs} args - Arguments to delete one Allergie.
     * @example
     * // Delete one Allergie
     * const Allergie = await prisma.allergie.delete({
     *   where: {
     *     // ... filter to delete one Allergie
     *   }
     * })
     * 
     */
    delete<T extends AllergieDeleteArgs>(args: SelectSubset<T, AllergieDeleteArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Allergie.
     * @param {AllergieUpdateArgs} args - Arguments to update one Allergie.
     * @example
     * // Update one Allergie
     * const allergie = await prisma.allergie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AllergieUpdateArgs>(args: SelectSubset<T, AllergieUpdateArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Allergies.
     * @param {AllergieDeleteManyArgs} args - Arguments to filter Allergies to delete.
     * @example
     * // Delete a few Allergies
     * const { count } = await prisma.allergie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AllergieDeleteManyArgs>(args?: SelectSubset<T, AllergieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Allergies
     * const allergie = await prisma.allergie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AllergieUpdateManyArgs>(args: SelectSubset<T, AllergieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Allergies and returns the data updated in the database.
     * @param {AllergieUpdateManyAndReturnArgs} args - Arguments to update many Allergies.
     * @example
     * // Update many Allergies
     * const allergie = await prisma.allergie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Allergies and only return the `id`
     * const allergieWithIdOnly = await prisma.allergie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AllergieUpdateManyAndReturnArgs>(args: SelectSubset<T, AllergieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Allergie.
     * @param {AllergieUpsertArgs} args - Arguments to update or create a Allergie.
     * @example
     * // Update or create a Allergie
     * const allergie = await prisma.allergie.upsert({
     *   create: {
     *     // ... data to create a Allergie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Allergie we want to update
     *   }
     * })
     */
    upsert<T extends AllergieUpsertArgs>(args: SelectSubset<T, AllergieUpsertArgs<ExtArgs>>): Prisma__AllergieClient<$Result.GetResult<Prisma.$AllergiePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Allergies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieCountArgs} args - Arguments to filter Allergies to count.
     * @example
     * // Count the number of Allergies
     * const count = await prisma.allergie.count({
     *   where: {
     *     // ... the filter for the Allergies we want to count
     *   }
     * })
    **/
    count<T extends AllergieCountArgs>(
      args?: Subset<T, AllergieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AllergieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Allergie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AllergieAggregateArgs>(args: Subset<T, AllergieAggregateArgs>): Prisma.PrismaPromise<GetAllergieAggregateType<T>>

    /**
     * Group by Allergie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AllergieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AllergieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AllergieGroupByArgs['orderBy'] }
        : { orderBy?: AllergieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AllergieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAllergieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Allergie model
   */
  readonly fields: AllergieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Allergie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AllergieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Allergie model
   */ 
  interface AllergieFieldRefs {
    readonly id: FieldRef<"Allergie", 'String'>
    readonly patientId: FieldRef<"Allergie", 'String'>
    readonly type: FieldRef<"Allergie", 'String'>
    readonly allergene: FieldRef<"Allergie", 'String'>
    readonly severite: FieldRef<"Allergie", 'String'>
    readonly reaction: FieldRef<"Allergie", 'String'>
    readonly createdAt: FieldRef<"Allergie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Allergie findUnique
   */
  export type AllergieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter, which Allergie to fetch.
     */
    where: AllergieWhereUniqueInput
  }

  /**
   * Allergie findUniqueOrThrow
   */
  export type AllergieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter, which Allergie to fetch.
     */
    where: AllergieWhereUniqueInput
  }

  /**
   * Allergie findFirst
   */
  export type AllergieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter, which Allergie to fetch.
     */
    where?: AllergieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergieOrderByWithRelationInput | AllergieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergieScalarFieldEnum | AllergieScalarFieldEnum[]
  }

  /**
   * Allergie findFirstOrThrow
   */
  export type AllergieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter, which Allergie to fetch.
     */
    where?: AllergieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergieOrderByWithRelationInput | AllergieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Allergies.
     */
    cursor?: AllergieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Allergies.
     */
    distinct?: AllergieScalarFieldEnum | AllergieScalarFieldEnum[]
  }

  /**
   * Allergie findMany
   */
  export type AllergieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter, which Allergies to fetch.
     */
    where?: AllergieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Allergies to fetch.
     */
    orderBy?: AllergieOrderByWithRelationInput | AllergieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Allergies.
     */
    cursor?: AllergieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Allergies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Allergies.
     */
    skip?: number
    distinct?: AllergieScalarFieldEnum | AllergieScalarFieldEnum[]
  }

  /**
   * Allergie create
   */
  export type AllergieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * The data needed to create a Allergie.
     */
    data: XOR<AllergieCreateInput, AllergieUncheckedCreateInput>
  }

  /**
   * Allergie createMany
   */
  export type AllergieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Allergies.
     */
    data: AllergieCreateManyInput | AllergieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Allergie createManyAndReturn
   */
  export type AllergieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * The data used to create many Allergies.
     */
    data: AllergieCreateManyInput | AllergieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergie update
   */
  export type AllergieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * The data needed to update a Allergie.
     */
    data: XOR<AllergieUpdateInput, AllergieUncheckedUpdateInput>
    /**
     * Choose, which Allergie to update.
     */
    where: AllergieWhereUniqueInput
  }

  /**
   * Allergie updateMany
   */
  export type AllergieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergieUpdateManyMutationInput, AllergieUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergieWhereInput
  }

  /**
   * Allergie updateManyAndReturn
   */
  export type AllergieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * The data used to update Allergies.
     */
    data: XOR<AllergieUpdateManyMutationInput, AllergieUncheckedUpdateManyInput>
    /**
     * Filter which Allergies to update
     */
    where?: AllergieWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Allergie upsert
   */
  export type AllergieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * The filter to search for the Allergie to update in case it exists.
     */
    where: AllergieWhereUniqueInput
    /**
     * In case the Allergie found by the `where` argument doesn't exist, create a new Allergie with this data.
     */
    create: XOR<AllergieCreateInput, AllergieUncheckedCreateInput>
    /**
     * In case the Allergie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AllergieUpdateInput, AllergieUncheckedUpdateInput>
  }

  /**
   * Allergie delete
   */
  export type AllergieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
    /**
     * Filter which Allergie to delete.
     */
    where: AllergieWhereUniqueInput
  }

  /**
   * Allergie deleteMany
   */
  export type AllergieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Allergies to delete
     */
    where?: AllergieWhereInput
  }

  /**
   * Allergie without action
   */
  export type AllergieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Allergie
     */
    select?: AllergieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Allergie
     */
    omit?: AllergieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AllergieInclude<ExtArgs> | null
  }


  /**
   * Model Vaccination
   */

  export type AggregateVaccination = {
    _count: VaccinationCountAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  export type VaccinationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    vaccin: string | null
    dateVaccin: Date | null
    rappel: Date | null
    lot: string | null
    createdAt: Date | null
  }

  export type VaccinationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    vaccin: string | null
    dateVaccin: Date | null
    rappel: Date | null
    lot: string | null
    createdAt: Date | null
  }

  export type VaccinationCountAggregateOutputType = {
    id: number
    patientId: number
    vaccin: number
    dateVaccin: number
    rappel: number
    lot: number
    createdAt: number
    _all: number
  }


  export type VaccinationMinAggregateInputType = {
    id?: true
    patientId?: true
    vaccin?: true
    dateVaccin?: true
    rappel?: true
    lot?: true
    createdAt?: true
  }

  export type VaccinationMaxAggregateInputType = {
    id?: true
    patientId?: true
    vaccin?: true
    dateVaccin?: true
    rappel?: true
    lot?: true
    createdAt?: true
  }

  export type VaccinationCountAggregateInputType = {
    id?: true
    patientId?: true
    vaccin?: true
    dateVaccin?: true
    rappel?: true
    lot?: true
    createdAt?: true
    _all?: true
  }

  export type VaccinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccination to aggregate.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vaccinations
    **/
    _count?: true | VaccinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationMaxAggregateInputType
  }

  export type GetVaccinationAggregateType<T extends VaccinationAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccination[P]>
      : GetScalarType<T[P], AggregateVaccination[P]>
  }




  export type VaccinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithAggregationInput | VaccinationOrderByWithAggregationInput[]
    by: VaccinationScalarFieldEnum[] | VaccinationScalarFieldEnum
    having?: VaccinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationCountAggregateInputType | true
    _min?: VaccinationMinAggregateInputType
    _max?: VaccinationMaxAggregateInputType
  }

  export type VaccinationGroupByOutputType = {
    id: string
    patientId: string
    vaccin: string
    dateVaccin: Date
    rappel: Date | null
    lot: string | null
    createdAt: Date
    _count: VaccinationCountAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  type GetVaccinationGroupByPayload<T extends VaccinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    vaccin?: boolean
    dateVaccin?: boolean
    rappel?: boolean
    lot?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccination"]>

  export type VaccinationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    vaccin?: boolean
    dateVaccin?: boolean
    rappel?: boolean
    lot?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccination"]>

  export type VaccinationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    vaccin?: boolean
    dateVaccin?: boolean
    rappel?: boolean
    lot?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccination"]>

  export type VaccinationSelectScalar = {
    id?: boolean
    patientId?: boolean
    vaccin?: boolean
    dateVaccin?: boolean
    rappel?: boolean
    lot?: boolean
    createdAt?: boolean
  }

  export type VaccinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "vaccin" | "dateVaccin" | "rappel" | "lot" | "createdAt", ExtArgs["result"]["vaccination"]>
  export type VaccinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type VaccinationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type VaccinationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $VaccinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vaccination"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      vaccin: string
      dateVaccin: Date
      rappel: Date | null
      lot: string | null
      createdAt: Date
    }, ExtArgs["result"]["vaccination"]>
    composites: {}
  }

  type VaccinationGetPayload<S extends boolean | null | undefined | VaccinationDefaultArgs> = $Result.GetResult<Prisma.$VaccinationPayload, S>

  type VaccinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationCountAggregateInputType | true
    }

  export interface VaccinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vaccination'], meta: { name: 'Vaccination' } }
    /**
     * Find zero or one Vaccination that matches the filter.
     * @param {VaccinationFindUniqueArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationFindUniqueArgs>(args: SelectSubset<T, VaccinationFindUniqueArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Vaccination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationFindUniqueOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Vaccination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationFindFirstArgs>(args?: SelectSubset<T, VaccinationFindFirstArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Vaccination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Vaccinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaccinations
     * const vaccinations = await prisma.vaccination.findMany()
     * 
     * // Get first 10 Vaccinations
     * const vaccinations = await prisma.vaccination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationWithIdOnly = await prisma.vaccination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationFindManyArgs>(args?: SelectSubset<T, VaccinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Vaccination.
     * @param {VaccinationCreateArgs} args - Arguments to create a Vaccination.
     * @example
     * // Create one Vaccination
     * const Vaccination = await prisma.vaccination.create({
     *   data: {
     *     // ... data to create a Vaccination
     *   }
     * })
     * 
     */
    create<T extends VaccinationCreateArgs>(args: SelectSubset<T, VaccinationCreateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Vaccinations.
     * @param {VaccinationCreateManyArgs} args - Arguments to create many Vaccinations.
     * @example
     * // Create many Vaccinations
     * const vaccination = await prisma.vaccination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationCreateManyArgs>(args?: SelectSubset<T, VaccinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vaccinations and returns the data saved in the database.
     * @param {VaccinationCreateManyAndReturnArgs} args - Arguments to create many Vaccinations.
     * @example
     * // Create many Vaccinations
     * const vaccination = await prisma.vaccination.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vaccinations and only return the `id`
     * const vaccinationWithIdOnly = await prisma.vaccination.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VaccinationCreateManyAndReturnArgs>(args?: SelectSubset<T, VaccinationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Vaccination.
     * @param {VaccinationDeleteArgs} args - Arguments to delete one Vaccination.
     * @example
     * // Delete one Vaccination
     * const Vaccination = await prisma.vaccination.delete({
     *   where: {
     *     // ... filter to delete one Vaccination
     *   }
     * })
     * 
     */
    delete<T extends VaccinationDeleteArgs>(args: SelectSubset<T, VaccinationDeleteArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Vaccination.
     * @param {VaccinationUpdateArgs} args - Arguments to update one Vaccination.
     * @example
     * // Update one Vaccination
     * const vaccination = await prisma.vaccination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationUpdateArgs>(args: SelectSubset<T, VaccinationUpdateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Vaccinations.
     * @param {VaccinationDeleteManyArgs} args - Arguments to filter Vaccinations to delete.
     * @example
     * // Delete a few Vaccinations
     * const { count } = await prisma.vaccination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationDeleteManyArgs>(args?: SelectSubset<T, VaccinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaccinations
     * const vaccination = await prisma.vaccination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationUpdateManyArgs>(args: SelectSubset<T, VaccinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccinations and returns the data updated in the database.
     * @param {VaccinationUpdateManyAndReturnArgs} args - Arguments to update many Vaccinations.
     * @example
     * // Update many Vaccinations
     * const vaccination = await prisma.vaccination.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vaccinations and only return the `id`
     * const vaccinationWithIdOnly = await prisma.vaccination.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VaccinationUpdateManyAndReturnArgs>(args: SelectSubset<T, VaccinationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Vaccination.
     * @param {VaccinationUpsertArgs} args - Arguments to update or create a Vaccination.
     * @example
     * // Update or create a Vaccination
     * const vaccination = await prisma.vaccination.upsert({
     *   create: {
     *     // ... data to create a Vaccination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaccination we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationUpsertArgs>(args: SelectSubset<T, VaccinationUpsertArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCountArgs} args - Arguments to filter Vaccinations to count.
     * @example
     * // Count the number of Vaccinations
     * const count = await prisma.vaccination.count({
     *   where: {
     *     // ... the filter for the Vaccinations we want to count
     *   }
     * })
    **/
    count<T extends VaccinationCountArgs>(
      args?: Subset<T, VaccinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationAggregateArgs>(args: Subset<T, VaccinationAggregateArgs>): Prisma.PrismaPromise<GetVaccinationAggregateType<T>>

    /**
     * Group by Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vaccination model
   */
  readonly fields: VaccinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vaccination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vaccination model
   */ 
  interface VaccinationFieldRefs {
    readonly id: FieldRef<"Vaccination", 'String'>
    readonly patientId: FieldRef<"Vaccination", 'String'>
    readonly vaccin: FieldRef<"Vaccination", 'String'>
    readonly dateVaccin: FieldRef<"Vaccination", 'DateTime'>
    readonly rappel: FieldRef<"Vaccination", 'DateTime'>
    readonly lot: FieldRef<"Vaccination", 'String'>
    readonly createdAt: FieldRef<"Vaccination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vaccination findUnique
   */
  export type VaccinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findUniqueOrThrow
   */
  export type VaccinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findFirst
   */
  export type VaccinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findFirstOrThrow
   */
  export type VaccinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findMany
   */
  export type VaccinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccinations to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination create
   */
  export type VaccinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Vaccination.
     */
    data: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
  }

  /**
   * Vaccination createMany
   */
  export type VaccinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vaccinations.
     */
    data: VaccinationCreateManyInput | VaccinationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vaccination createManyAndReturn
   */
  export type VaccinationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * The data used to create many Vaccinations.
     */
    data: VaccinationCreateManyInput | VaccinationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vaccination update
   */
  export type VaccinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Vaccination.
     */
    data: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
    /**
     * Choose, which Vaccination to update.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination updateMany
   */
  export type VaccinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vaccinations.
     */
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyInput>
    /**
     * Filter which Vaccinations to update
     */
    where?: VaccinationWhereInput
  }

  /**
   * Vaccination updateManyAndReturn
   */
  export type VaccinationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * The data used to update Vaccinations.
     */
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyInput>
    /**
     * Filter which Vaccinations to update
     */
    where?: VaccinationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vaccination upsert
   */
  export type VaccinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Vaccination to update in case it exists.
     */
    where: VaccinationWhereUniqueInput
    /**
     * In case the Vaccination found by the `where` argument doesn't exist, create a new Vaccination with this data.
     */
    create: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
    /**
     * In case the Vaccination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
  }

  /**
   * Vaccination delete
   */
  export type VaccinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter which Vaccination to delete.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination deleteMany
   */
  export type VaccinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccinations to delete
     */
    where?: VaccinationWhereInput
  }

  /**
   * Vaccination without action
   */
  export type VaccinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
  }


  /**
   * Model RendezVous
   */

  export type AggregateRendezVous = {
    _count: RendezVousCountAggregateOutputType | null
    _avg: RendezVousAvgAggregateOutputType | null
    _sum: RendezVousSumAggregateOutputType | null
    _min: RendezVousMinAggregateOutputType | null
    _max: RendezVousMaxAggregateOutputType | null
  }

  export type RendezVousAvgAggregateOutputType = {
    duree: number | null
  }

  export type RendezVousSumAggregateOutputType = {
    duree: number | null
  }

  export type RendezVousMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    medecinId: string | null
    dateHeure: Date | null
    duree: number | null
    motif: string | null
    statut: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RendezVousMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    medecinId: string | null
    dateHeure: Date | null
    duree: number | null
    motif: string | null
    statut: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RendezVousCountAggregateOutputType = {
    id: number
    patientId: number
    medecinId: number
    dateHeure: number
    duree: number
    motif: number
    statut: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RendezVousAvgAggregateInputType = {
    duree?: true
  }

  export type RendezVousSumAggregateInputType = {
    duree?: true
  }

  export type RendezVousMinAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateHeure?: true
    duree?: true
    motif?: true
    statut?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RendezVousMaxAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateHeure?: true
    duree?: true
    motif?: true
    statut?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RendezVousCountAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateHeure?: true
    duree?: true
    motif?: true
    statut?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RendezVousAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RendezVous to aggregate.
     */
    where?: RendezVousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RendezVous to fetch.
     */
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RendezVousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RendezVous from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RendezVous.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RendezVous
    **/
    _count?: true | RendezVousCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RendezVousAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RendezVousSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RendezVousMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RendezVousMaxAggregateInputType
  }

  export type GetRendezVousAggregateType<T extends RendezVousAggregateArgs> = {
        [P in keyof T & keyof AggregateRendezVous]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRendezVous[P]>
      : GetScalarType<T[P], AggregateRendezVous[P]>
  }




  export type RendezVousGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RendezVousWhereInput
    orderBy?: RendezVousOrderByWithAggregationInput | RendezVousOrderByWithAggregationInput[]
    by: RendezVousScalarFieldEnum[] | RendezVousScalarFieldEnum
    having?: RendezVousScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RendezVousCountAggregateInputType | true
    _avg?: RendezVousAvgAggregateInputType
    _sum?: RendezVousSumAggregateInputType
    _min?: RendezVousMinAggregateInputType
    _max?: RendezVousMaxAggregateInputType
  }

  export type RendezVousGroupByOutputType = {
    id: string
    patientId: string
    medecinId: string
    dateHeure: Date
    duree: number
    motif: string
    statut: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: RendezVousCountAggregateOutputType | null
    _avg: RendezVousAvgAggregateOutputType | null
    _sum: RendezVousSumAggregateOutputType | null
    _min: RendezVousMinAggregateOutputType | null
    _max: RendezVousMaxAggregateOutputType | null
  }

  type GetRendezVousGroupByPayload<T extends RendezVousGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RendezVousGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RendezVousGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RendezVousGroupByOutputType[P]>
            : GetScalarType<T[P], RendezVousGroupByOutputType[P]>
        }
      >
    >


  export type RendezVousSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateHeure?: boolean
    duree?: boolean
    motif?: boolean
    statut?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rendezVous"]>

  export type RendezVousSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateHeure?: boolean
    duree?: boolean
    motif?: boolean
    statut?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rendezVous"]>

  export type RendezVousSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateHeure?: boolean
    duree?: boolean
    motif?: boolean
    statut?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rendezVous"]>

  export type RendezVousSelectScalar = {
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateHeure?: boolean
    duree?: boolean
    motif?: boolean
    statut?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RendezVousOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "medecinId" | "dateHeure" | "duree" | "motif" | "statut" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["rendezVous"]>
  export type RendezVousInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RendezVousIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RendezVousIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RendezVousPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RendezVous"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      medecin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      medecinId: string
      dateHeure: Date
      duree: number
      motif: string
      statut: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rendezVous"]>
    composites: {}
  }

  type RendezVousGetPayload<S extends boolean | null | undefined | RendezVousDefaultArgs> = $Result.GetResult<Prisma.$RendezVousPayload, S>

  type RendezVousCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RendezVousFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RendezVousCountAggregateInputType | true
    }

  export interface RendezVousDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RendezVous'], meta: { name: 'RendezVous' } }
    /**
     * Find zero or one RendezVous that matches the filter.
     * @param {RendezVousFindUniqueArgs} args - Arguments to find a RendezVous
     * @example
     * // Get one RendezVous
     * const rendezVous = await prisma.rendezVous.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RendezVousFindUniqueArgs>(args: SelectSubset<T, RendezVousFindUniqueArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RendezVous that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RendezVousFindUniqueOrThrowArgs} args - Arguments to find a RendezVous
     * @example
     * // Get one RendezVous
     * const rendezVous = await prisma.rendezVous.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RendezVousFindUniqueOrThrowArgs>(args: SelectSubset<T, RendezVousFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RendezVous that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousFindFirstArgs} args - Arguments to find a RendezVous
     * @example
     * // Get one RendezVous
     * const rendezVous = await prisma.rendezVous.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RendezVousFindFirstArgs>(args?: SelectSubset<T, RendezVousFindFirstArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RendezVous that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousFindFirstOrThrowArgs} args - Arguments to find a RendezVous
     * @example
     * // Get one RendezVous
     * const rendezVous = await prisma.rendezVous.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RendezVousFindFirstOrThrowArgs>(args?: SelectSubset<T, RendezVousFindFirstOrThrowArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RendezVous that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RendezVous
     * const rendezVous = await prisma.rendezVous.findMany()
     * 
     * // Get first 10 RendezVous
     * const rendezVous = await prisma.rendezVous.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rendezVousWithIdOnly = await prisma.rendezVous.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RendezVousFindManyArgs>(args?: SelectSubset<T, RendezVousFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RendezVous.
     * @param {RendezVousCreateArgs} args - Arguments to create a RendezVous.
     * @example
     * // Create one RendezVous
     * const RendezVous = await prisma.rendezVous.create({
     *   data: {
     *     // ... data to create a RendezVous
     *   }
     * })
     * 
     */
    create<T extends RendezVousCreateArgs>(args: SelectSubset<T, RendezVousCreateArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RendezVous.
     * @param {RendezVousCreateManyArgs} args - Arguments to create many RendezVous.
     * @example
     * // Create many RendezVous
     * const rendezVous = await prisma.rendezVous.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RendezVousCreateManyArgs>(args?: SelectSubset<T, RendezVousCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RendezVous and returns the data saved in the database.
     * @param {RendezVousCreateManyAndReturnArgs} args - Arguments to create many RendezVous.
     * @example
     * // Create many RendezVous
     * const rendezVous = await prisma.rendezVous.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RendezVous and only return the `id`
     * const rendezVousWithIdOnly = await prisma.rendezVous.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RendezVousCreateManyAndReturnArgs>(args?: SelectSubset<T, RendezVousCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RendezVous.
     * @param {RendezVousDeleteArgs} args - Arguments to delete one RendezVous.
     * @example
     * // Delete one RendezVous
     * const RendezVous = await prisma.rendezVous.delete({
     *   where: {
     *     // ... filter to delete one RendezVous
     *   }
     * })
     * 
     */
    delete<T extends RendezVousDeleteArgs>(args: SelectSubset<T, RendezVousDeleteArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RendezVous.
     * @param {RendezVousUpdateArgs} args - Arguments to update one RendezVous.
     * @example
     * // Update one RendezVous
     * const rendezVous = await prisma.rendezVous.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RendezVousUpdateArgs>(args: SelectSubset<T, RendezVousUpdateArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RendezVous.
     * @param {RendezVousDeleteManyArgs} args - Arguments to filter RendezVous to delete.
     * @example
     * // Delete a few RendezVous
     * const { count } = await prisma.rendezVous.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RendezVousDeleteManyArgs>(args?: SelectSubset<T, RendezVousDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RendezVous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RendezVous
     * const rendezVous = await prisma.rendezVous.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RendezVousUpdateManyArgs>(args: SelectSubset<T, RendezVousUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RendezVous and returns the data updated in the database.
     * @param {RendezVousUpdateManyAndReturnArgs} args - Arguments to update many RendezVous.
     * @example
     * // Update many RendezVous
     * const rendezVous = await prisma.rendezVous.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RendezVous and only return the `id`
     * const rendezVousWithIdOnly = await prisma.rendezVous.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RendezVousUpdateManyAndReturnArgs>(args: SelectSubset<T, RendezVousUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RendezVous.
     * @param {RendezVousUpsertArgs} args - Arguments to update or create a RendezVous.
     * @example
     * // Update or create a RendezVous
     * const rendezVous = await prisma.rendezVous.upsert({
     *   create: {
     *     // ... data to create a RendezVous
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RendezVous we want to update
     *   }
     * })
     */
    upsert<T extends RendezVousUpsertArgs>(args: SelectSubset<T, RendezVousUpsertArgs<ExtArgs>>): Prisma__RendezVousClient<$Result.GetResult<Prisma.$RendezVousPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RendezVous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousCountArgs} args - Arguments to filter RendezVous to count.
     * @example
     * // Count the number of RendezVous
     * const count = await prisma.rendezVous.count({
     *   where: {
     *     // ... the filter for the RendezVous we want to count
     *   }
     * })
    **/
    count<T extends RendezVousCountArgs>(
      args?: Subset<T, RendezVousCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RendezVousCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RendezVous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RendezVousAggregateArgs>(args: Subset<T, RendezVousAggregateArgs>): Prisma.PrismaPromise<GetRendezVousAggregateType<T>>

    /**
     * Group by RendezVous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RendezVousGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RendezVousGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RendezVousGroupByArgs['orderBy'] }
        : { orderBy?: RendezVousGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RendezVousGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRendezVousGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RendezVous model
   */
  readonly fields: RendezVousFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RendezVous.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RendezVousClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    medecin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RendezVous model
   */ 
  interface RendezVousFieldRefs {
    readonly id: FieldRef<"RendezVous", 'String'>
    readonly patientId: FieldRef<"RendezVous", 'String'>
    readonly medecinId: FieldRef<"RendezVous", 'String'>
    readonly dateHeure: FieldRef<"RendezVous", 'DateTime'>
    readonly duree: FieldRef<"RendezVous", 'Int'>
    readonly motif: FieldRef<"RendezVous", 'String'>
    readonly statut: FieldRef<"RendezVous", 'String'>
    readonly notes: FieldRef<"RendezVous", 'String'>
    readonly createdAt: FieldRef<"RendezVous", 'DateTime'>
    readonly updatedAt: FieldRef<"RendezVous", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RendezVous findUnique
   */
  export type RendezVousFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter, which RendezVous to fetch.
     */
    where: RendezVousWhereUniqueInput
  }

  /**
   * RendezVous findUniqueOrThrow
   */
  export type RendezVousFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter, which RendezVous to fetch.
     */
    where: RendezVousWhereUniqueInput
  }

  /**
   * RendezVous findFirst
   */
  export type RendezVousFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter, which RendezVous to fetch.
     */
    where?: RendezVousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RendezVous to fetch.
     */
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RendezVous.
     */
    cursor?: RendezVousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RendezVous from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RendezVous.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RendezVous.
     */
    distinct?: RendezVousScalarFieldEnum | RendezVousScalarFieldEnum[]
  }

  /**
   * RendezVous findFirstOrThrow
   */
  export type RendezVousFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter, which RendezVous to fetch.
     */
    where?: RendezVousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RendezVous to fetch.
     */
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RendezVous.
     */
    cursor?: RendezVousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RendezVous from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RendezVous.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RendezVous.
     */
    distinct?: RendezVousScalarFieldEnum | RendezVousScalarFieldEnum[]
  }

  /**
   * RendezVous findMany
   */
  export type RendezVousFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter, which RendezVous to fetch.
     */
    where?: RendezVousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RendezVous to fetch.
     */
    orderBy?: RendezVousOrderByWithRelationInput | RendezVousOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RendezVous.
     */
    cursor?: RendezVousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RendezVous from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RendezVous.
     */
    skip?: number
    distinct?: RendezVousScalarFieldEnum | RendezVousScalarFieldEnum[]
  }

  /**
   * RendezVous create
   */
  export type RendezVousCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * The data needed to create a RendezVous.
     */
    data: XOR<RendezVousCreateInput, RendezVousUncheckedCreateInput>
  }

  /**
   * RendezVous createMany
   */
  export type RendezVousCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RendezVous.
     */
    data: RendezVousCreateManyInput | RendezVousCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RendezVous createManyAndReturn
   */
  export type RendezVousCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * The data used to create many RendezVous.
     */
    data: RendezVousCreateManyInput | RendezVousCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RendezVous update
   */
  export type RendezVousUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * The data needed to update a RendezVous.
     */
    data: XOR<RendezVousUpdateInput, RendezVousUncheckedUpdateInput>
    /**
     * Choose, which RendezVous to update.
     */
    where: RendezVousWhereUniqueInput
  }

  /**
   * RendezVous updateMany
   */
  export type RendezVousUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RendezVous.
     */
    data: XOR<RendezVousUpdateManyMutationInput, RendezVousUncheckedUpdateManyInput>
    /**
     * Filter which RendezVous to update
     */
    where?: RendezVousWhereInput
  }

  /**
   * RendezVous updateManyAndReturn
   */
  export type RendezVousUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * The data used to update RendezVous.
     */
    data: XOR<RendezVousUpdateManyMutationInput, RendezVousUncheckedUpdateManyInput>
    /**
     * Filter which RendezVous to update
     */
    where?: RendezVousWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RendezVous upsert
   */
  export type RendezVousUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * The filter to search for the RendezVous to update in case it exists.
     */
    where: RendezVousWhereUniqueInput
    /**
     * In case the RendezVous found by the `where` argument doesn't exist, create a new RendezVous with this data.
     */
    create: XOR<RendezVousCreateInput, RendezVousUncheckedCreateInput>
    /**
     * In case the RendezVous was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RendezVousUpdateInput, RendezVousUncheckedUpdateInput>
  }

  /**
   * RendezVous delete
   */
  export type RendezVousDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
    /**
     * Filter which RendezVous to delete.
     */
    where: RendezVousWhereUniqueInput
  }

  /**
   * RendezVous deleteMany
   */
  export type RendezVousDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RendezVous to delete
     */
    where?: RendezVousWhereInput
  }

  /**
   * RendezVous without action
   */
  export type RendezVousDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RendezVous
     */
    select?: RendezVousSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RendezVous
     */
    omit?: RendezVousOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RendezVousInclude<ExtArgs> | null
  }


  /**
   * Model Consultation
   */

  export type AggregateConsultation = {
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  export type ConsultationAvgAggregateOutputType = {
    poids: Decimal | null
    taille: Decimal | null
    temperature: Decimal | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    frequenceCardiaque: number | null
    saturationOxygene: number | null
  }

  export type ConsultationSumAggregateOutputType = {
    poids: Decimal | null
    taille: Decimal | null
    temperature: Decimal | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    frequenceCardiaque: number | null
    saturationOxygene: number | null
  }

  export type ConsultationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    medecinId: string | null
    dateConsultation: Date | null
    motifConsultation: string | null
    anamnese: string | null
    examenClinique: string | null
    diagnostic: string | null
    planTraitement: string | null
    poids: Decimal | null
    taille: Decimal | null
    temperature: Decimal | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    frequenceCardiaque: number | null
    saturationOxygene: number | null
    factureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    medecinId: string | null
    dateConsultation: Date | null
    motifConsultation: string | null
    anamnese: string | null
    examenClinique: string | null
    diagnostic: string | null
    planTraitement: string | null
    poids: Decimal | null
    taille: Decimal | null
    temperature: Decimal | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    frequenceCardiaque: number | null
    saturationOxygene: number | null
    factureId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConsultationCountAggregateOutputType = {
    id: number
    patientId: number
    medecinId: number
    dateConsultation: number
    motifConsultation: number
    anamnese: number
    examenClinique: number
    diagnostic: number
    planTraitement: number
    poids: number
    taille: number
    temperature: number
    tensionSystolique: number
    tensionDiastolique: number
    frequenceCardiaque: number
    saturationOxygene: number
    donneesSpecialite: number
    factureId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConsultationAvgAggregateInputType = {
    poids?: true
    taille?: true
    temperature?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    frequenceCardiaque?: true
    saturationOxygene?: true
  }

  export type ConsultationSumAggregateInputType = {
    poids?: true
    taille?: true
    temperature?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    frequenceCardiaque?: true
    saturationOxygene?: true
  }

  export type ConsultationMinAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateConsultation?: true
    motifConsultation?: true
    anamnese?: true
    examenClinique?: true
    diagnostic?: true
    planTraitement?: true
    poids?: true
    taille?: true
    temperature?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    frequenceCardiaque?: true
    saturationOxygene?: true
    factureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationMaxAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateConsultation?: true
    motifConsultation?: true
    anamnese?: true
    examenClinique?: true
    diagnostic?: true
    planTraitement?: true
    poids?: true
    taille?: true
    temperature?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    frequenceCardiaque?: true
    saturationOxygene?: true
    factureId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConsultationCountAggregateInputType = {
    id?: true
    patientId?: true
    medecinId?: true
    dateConsultation?: true
    motifConsultation?: true
    anamnese?: true
    examenClinique?: true
    diagnostic?: true
    planTraitement?: true
    poids?: true
    taille?: true
    temperature?: true
    tensionSystolique?: true
    tensionDiastolique?: true
    frequenceCardiaque?: true
    saturationOxygene?: true
    donneesSpecialite?: true
    factureId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConsultationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultation to aggregate.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Consultations
    **/
    _count?: true | ConsultationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConsultationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConsultationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConsultationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConsultationMaxAggregateInputType
  }

  export type GetConsultationAggregateType<T extends ConsultationAggregateArgs> = {
        [P in keyof T & keyof AggregateConsultation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsultation[P]>
      : GetScalarType<T[P], AggregateConsultation[P]>
  }




  export type ConsultationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithAggregationInput | ConsultationOrderByWithAggregationInput[]
    by: ConsultationScalarFieldEnum[] | ConsultationScalarFieldEnum
    having?: ConsultationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConsultationCountAggregateInputType | true
    _avg?: ConsultationAvgAggregateInputType
    _sum?: ConsultationSumAggregateInputType
    _min?: ConsultationMinAggregateInputType
    _max?: ConsultationMaxAggregateInputType
  }

  export type ConsultationGroupByOutputType = {
    id: string
    patientId: string
    medecinId: string
    dateConsultation: Date
    motifConsultation: string
    anamnese: string | null
    examenClinique: string | null
    diagnostic: string | null
    planTraitement: string | null
    poids: Decimal | null
    taille: Decimal | null
    temperature: Decimal | null
    tensionSystolique: number | null
    tensionDiastolique: number | null
    frequenceCardiaque: number | null
    saturationOxygene: number | null
    donneesSpecialite: JsonValue | null
    factureId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConsultationCountAggregateOutputType | null
    _avg: ConsultationAvgAggregateOutputType | null
    _sum: ConsultationSumAggregateOutputType | null
    _min: ConsultationMinAggregateOutputType | null
    _max: ConsultationMaxAggregateOutputType | null
  }

  type GetConsultationGroupByPayload<T extends ConsultationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConsultationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConsultationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
            : GetScalarType<T[P], ConsultationGroupByOutputType[P]>
        }
      >
    >


  export type ConsultationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateConsultation?: boolean
    motifConsultation?: boolean
    anamnese?: boolean
    examenClinique?: boolean
    diagnostic?: boolean
    planTraitement?: boolean
    poids?: boolean
    taille?: boolean
    temperature?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    frequenceCardiaque?: boolean
    saturationOxygene?: boolean
    donneesSpecialite?: boolean
    factureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    prescriptions?: boolean | Consultation$prescriptionsArgs<ExtArgs>
    actesRealises?: boolean | Consultation$actesRealisesArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateConsultation?: boolean
    motifConsultation?: boolean
    anamnese?: boolean
    examenClinique?: boolean
    diagnostic?: boolean
    planTraitement?: boolean
    poids?: boolean
    taille?: boolean
    temperature?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    frequenceCardiaque?: boolean
    saturationOxygene?: boolean
    donneesSpecialite?: boolean
    factureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateConsultation?: boolean
    motifConsultation?: boolean
    anamnese?: boolean
    examenClinique?: boolean
    diagnostic?: boolean
    planTraitement?: boolean
    poids?: boolean
    taille?: boolean
    temperature?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    frequenceCardiaque?: boolean
    saturationOxygene?: boolean
    donneesSpecialite?: boolean
    factureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
  }, ExtArgs["result"]["consultation"]>

  export type ConsultationSelectScalar = {
    id?: boolean
    patientId?: boolean
    medecinId?: boolean
    dateConsultation?: boolean
    motifConsultation?: boolean
    anamnese?: boolean
    examenClinique?: boolean
    diagnostic?: boolean
    planTraitement?: boolean
    poids?: boolean
    taille?: boolean
    temperature?: boolean
    tensionSystolique?: boolean
    tensionDiastolique?: boolean
    frequenceCardiaque?: boolean
    saturationOxygene?: boolean
    donneesSpecialite?: boolean
    factureId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConsultationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "medecinId" | "dateConsultation" | "motifConsultation" | "anamnese" | "examenClinique" | "diagnostic" | "planTraitement" | "poids" | "taille" | "temperature" | "tensionSystolique" | "tensionDiastolique" | "frequenceCardiaque" | "saturationOxygene" | "donneesSpecialite" | "factureId" | "createdAt" | "updatedAt", ExtArgs["result"]["consultation"]>
  export type ConsultationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    prescriptions?: boolean | Consultation$prescriptionsArgs<ExtArgs>
    actesRealises?: boolean | Consultation$actesRealisesArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
    _count?: boolean | ConsultationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConsultationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
  }
  export type ConsultationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    medecin?: boolean | UserDefaultArgs<ExtArgs>
    facture?: boolean | Consultation$factureArgs<ExtArgs>
  }

  export type $ConsultationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Consultation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      medecin: Prisma.$UserPayload<ExtArgs>
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      actesRealises: Prisma.$ActeRealisePayload<ExtArgs>[]
      facture: Prisma.$FacturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      medecinId: string
      dateConsultation: Date
      motifConsultation: string
      anamnese: string | null
      examenClinique: string | null
      diagnostic: string | null
      planTraitement: string | null
      poids: Prisma.Decimal | null
      taille: Prisma.Decimal | null
      temperature: Prisma.Decimal | null
      tensionSystolique: number | null
      tensionDiastolique: number | null
      frequenceCardiaque: number | null
      saturationOxygene: number | null
      donneesSpecialite: Prisma.JsonValue | null
      factureId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["consultation"]>
    composites: {}
  }

  type ConsultationGetPayload<S extends boolean | null | undefined | ConsultationDefaultArgs> = $Result.GetResult<Prisma.$ConsultationPayload, S>

  type ConsultationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConsultationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConsultationCountAggregateInputType | true
    }

  export interface ConsultationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Consultation'], meta: { name: 'Consultation' } }
    /**
     * Find zero or one Consultation that matches the filter.
     * @param {ConsultationFindUniqueArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConsultationFindUniqueArgs>(args: SelectSubset<T, ConsultationFindUniqueArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Consultation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConsultationFindUniqueOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConsultationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConsultationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Consultation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConsultationFindFirstArgs>(args?: SelectSubset<T, ConsultationFindFirstArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Consultation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindFirstOrThrowArgs} args - Arguments to find a Consultation
     * @example
     * // Get one Consultation
     * const consultation = await prisma.consultation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConsultationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConsultationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Consultations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consultations
     * const consultations = await prisma.consultation.findMany()
     * 
     * // Get first 10 Consultations
     * const consultations = await prisma.consultation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const consultationWithIdOnly = await prisma.consultation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConsultationFindManyArgs>(args?: SelectSubset<T, ConsultationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Consultation.
     * @param {ConsultationCreateArgs} args - Arguments to create a Consultation.
     * @example
     * // Create one Consultation
     * const Consultation = await prisma.consultation.create({
     *   data: {
     *     // ... data to create a Consultation
     *   }
     * })
     * 
     */
    create<T extends ConsultationCreateArgs>(args: SelectSubset<T, ConsultationCreateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Consultations.
     * @param {ConsultationCreateManyArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConsultationCreateManyArgs>(args?: SelectSubset<T, ConsultationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consultations and returns the data saved in the database.
     * @param {ConsultationCreateManyAndReturnArgs} args - Arguments to create many Consultations.
     * @example
     * // Create many Consultations
     * const consultation = await prisma.consultation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consultations and only return the `id`
     * const consultationWithIdOnly = await prisma.consultation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConsultationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConsultationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Consultation.
     * @param {ConsultationDeleteArgs} args - Arguments to delete one Consultation.
     * @example
     * // Delete one Consultation
     * const Consultation = await prisma.consultation.delete({
     *   where: {
     *     // ... filter to delete one Consultation
     *   }
     * })
     * 
     */
    delete<T extends ConsultationDeleteArgs>(args: SelectSubset<T, ConsultationDeleteArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Consultation.
     * @param {ConsultationUpdateArgs} args - Arguments to update one Consultation.
     * @example
     * // Update one Consultation
     * const consultation = await prisma.consultation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConsultationUpdateArgs>(args: SelectSubset<T, ConsultationUpdateArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Consultations.
     * @param {ConsultationDeleteManyArgs} args - Arguments to filter Consultations to delete.
     * @example
     * // Delete a few Consultations
     * const { count } = await prisma.consultation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConsultationDeleteManyArgs>(args?: SelectSubset<T, ConsultationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConsultationUpdateManyArgs>(args: SelectSubset<T, ConsultationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consultations and returns the data updated in the database.
     * @param {ConsultationUpdateManyAndReturnArgs} args - Arguments to update many Consultations.
     * @example
     * // Update many Consultations
     * const consultation = await prisma.consultation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consultations and only return the `id`
     * const consultationWithIdOnly = await prisma.consultation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConsultationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConsultationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Consultation.
     * @param {ConsultationUpsertArgs} args - Arguments to update or create a Consultation.
     * @example
     * // Update or create a Consultation
     * const consultation = await prisma.consultation.upsert({
     *   create: {
     *     // ... data to create a Consultation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consultation we want to update
     *   }
     * })
     */
    upsert<T extends ConsultationUpsertArgs>(args: SelectSubset<T, ConsultationUpsertArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Consultations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationCountArgs} args - Arguments to filter Consultations to count.
     * @example
     * // Count the number of Consultations
     * const count = await prisma.consultation.count({
     *   where: {
     *     // ... the filter for the Consultations we want to count
     *   }
     * })
    **/
    count<T extends ConsultationCountArgs>(
      args?: Subset<T, ConsultationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConsultationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConsultationAggregateArgs>(args: Subset<T, ConsultationAggregateArgs>): Prisma.PrismaPromise<GetConsultationAggregateType<T>>

    /**
     * Group by Consultation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConsultationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConsultationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConsultationGroupByArgs['orderBy'] }
        : { orderBy?: ConsultationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConsultationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsultationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Consultation model
   */
  readonly fields: ConsultationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Consultation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConsultationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    medecin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    prescriptions<T extends Consultation$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    actesRealises<T extends Consultation$actesRealisesArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$actesRealisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    facture<T extends Consultation$factureArgs<ExtArgs> = {}>(args?: Subset<T, Consultation$factureArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Consultation model
   */ 
  interface ConsultationFieldRefs {
    readonly id: FieldRef<"Consultation", 'String'>
    readonly patientId: FieldRef<"Consultation", 'String'>
    readonly medecinId: FieldRef<"Consultation", 'String'>
    readonly dateConsultation: FieldRef<"Consultation", 'DateTime'>
    readonly motifConsultation: FieldRef<"Consultation", 'String'>
    readonly anamnese: FieldRef<"Consultation", 'String'>
    readonly examenClinique: FieldRef<"Consultation", 'String'>
    readonly diagnostic: FieldRef<"Consultation", 'String'>
    readonly planTraitement: FieldRef<"Consultation", 'String'>
    readonly poids: FieldRef<"Consultation", 'Decimal'>
    readonly taille: FieldRef<"Consultation", 'Decimal'>
    readonly temperature: FieldRef<"Consultation", 'Decimal'>
    readonly tensionSystolique: FieldRef<"Consultation", 'Int'>
    readonly tensionDiastolique: FieldRef<"Consultation", 'Int'>
    readonly frequenceCardiaque: FieldRef<"Consultation", 'Int'>
    readonly saturationOxygene: FieldRef<"Consultation", 'Int'>
    readonly donneesSpecialite: FieldRef<"Consultation", 'Json'>
    readonly factureId: FieldRef<"Consultation", 'String'>
    readonly createdAt: FieldRef<"Consultation", 'DateTime'>
    readonly updatedAt: FieldRef<"Consultation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Consultation findUnique
   */
  export type ConsultationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findUniqueOrThrow
   */
  export type ConsultationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation findFirst
   */
  export type ConsultationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findFirstOrThrow
   */
  export type ConsultationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultation to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Consultations.
     */
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation findMany
   */
  export type ConsultationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter, which Consultations to fetch.
     */
    where?: ConsultationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Consultations to fetch.
     */
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Consultations.
     */
    cursor?: ConsultationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Consultations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Consultations.
     */
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Consultation create
   */
  export type ConsultationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to create a Consultation.
     */
    data: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
  }

  /**
   * Consultation createMany
   */
  export type ConsultationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Consultation createManyAndReturn
   */
  export type ConsultationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * The data used to create many Consultations.
     */
    data: ConsultationCreateManyInput | ConsultationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consultation update
   */
  export type ConsultationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The data needed to update a Consultation.
     */
    data: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
    /**
     * Choose, which Consultation to update.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation updateMany
   */
  export type ConsultationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
  }

  /**
   * Consultation updateManyAndReturn
   */
  export type ConsultationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * The data used to update Consultations.
     */
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyInput>
    /**
     * Filter which Consultations to update
     */
    where?: ConsultationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Consultation upsert
   */
  export type ConsultationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * The filter to search for the Consultation to update in case it exists.
     */
    where: ConsultationWhereUniqueInput
    /**
     * In case the Consultation found by the `where` argument doesn't exist, create a new Consultation with this data.
     */
    create: XOR<ConsultationCreateInput, ConsultationUncheckedCreateInput>
    /**
     * In case the Consultation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConsultationUpdateInput, ConsultationUncheckedUpdateInput>
  }

  /**
   * Consultation delete
   */
  export type ConsultationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    /**
     * Filter which Consultation to delete.
     */
    where: ConsultationWhereUniqueInput
  }

  /**
   * Consultation deleteMany
   */
  export type ConsultationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Consultations to delete
     */
    where?: ConsultationWhereInput
  }

  /**
   * Consultation.prescriptions
   */
  export type Consultation$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Consultation.actesRealises
   */
  export type Consultation$actesRealisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    where?: ActeRealiseWhereInput
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    cursor?: ActeRealiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActeRealiseScalarFieldEnum | ActeRealiseScalarFieldEnum[]
  }

  /**
   * Consultation.facture
   */
  export type Consultation$factureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    where?: FactureWhereInput
  }

  /**
   * Consultation without action
   */
  export type ConsultationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    quantite: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    quantite: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    consultationId: string | null
    medicament: string | null
    dosage: string | null
    forme: string | null
    posologie: string | null
    duree: string | null
    quantite: number | null
    instructions: string | null
    createdAt: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    consultationId: string | null
    medicament: string | null
    dosage: string | null
    forme: string | null
    posologie: string | null
    duree: string | null
    quantite: number | null
    instructions: string | null
    createdAt: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    consultationId: number
    medicament: number
    dosage: number
    forme: number
    posologie: number
    duree: number
    quantite: number
    instructions: number
    createdAt: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    quantite?: true
  }

  export type PrescriptionSumAggregateInputType = {
    quantite?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    consultationId?: true
    medicament?: true
    dosage?: true
    forme?: true
    posologie?: true
    duree?: true
    quantite?: true
    instructions?: true
    createdAt?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    consultationId?: true
    medicament?: true
    dosage?: true
    forme?: true
    posologie?: true
    duree?: true
    quantite?: true
    instructions?: true
    createdAt?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    consultationId?: true
    medicament?: true
    dosage?: true
    forme?: true
    posologie?: true
    duree?: true
    quantite?: true
    instructions?: true
    createdAt?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    consultationId: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions: string | null
    createdAt: Date
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    medicament?: boolean
    dosage?: boolean
    forme?: boolean
    posologie?: boolean
    duree?: boolean
    quantite?: boolean
    instructions?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    medicament?: boolean
    dosage?: boolean
    forme?: boolean
    posologie?: boolean
    duree?: boolean
    quantite?: boolean
    instructions?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    medicament?: boolean
    dosage?: boolean
    forme?: boolean
    posologie?: boolean
    duree?: boolean
    quantite?: boolean
    instructions?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    consultationId?: boolean
    medicament?: boolean
    dosage?: boolean
    forme?: boolean
    posologie?: boolean
    duree?: boolean
    quantite?: boolean
    instructions?: boolean
    createdAt?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "medicament" | "dosage" | "forme" | "posologie" | "duree" | "quantite" | "instructions" | "createdAt", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      consultation: Prisma.$ConsultationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationId: string
      medicament: string
      dosage: string
      forme: string
      posologie: string
      duree: string
      quantite: number
      instructions: string | null
      createdAt: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends ConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationDefaultArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly consultationId: FieldRef<"Prescription", 'String'>
    readonly medicament: FieldRef<"Prescription", 'String'>
    readonly dosage: FieldRef<"Prescription", 'String'>
    readonly forme: FieldRef<"Prescription", 'String'>
    readonly posologie: FieldRef<"Prescription", 'String'>
    readonly duree: FieldRef<"Prescription", 'String'>
    readonly quantite: FieldRef<"Prescription", 'Int'>
    readonly instructions: FieldRef<"Prescription", 'String'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model NomenclatureActe
   */

  export type AggregateNomenclatureActe = {
    _count: NomenclatureActeCountAggregateOutputType | null
    _avg: NomenclatureActeAvgAggregateOutputType | null
    _sum: NomenclatureActeSumAggregateOutputType | null
    _min: NomenclatureActeMinAggregateOutputType | null
    _max: NomenclatureActeMaxAggregateOutputType | null
  }

  export type NomenclatureActeAvgAggregateOutputType = {
    tarif: Decimal | null
    duree: number | null
  }

  export type NomenclatureActeSumAggregateOutputType = {
    tarif: Decimal | null
    duree: number | null
  }

  export type NomenclatureActeMinAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    specialite: string | null
    tarif: Decimal | null
    duree: number | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type NomenclatureActeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    libelle: string | null
    specialite: string | null
    tarif: Decimal | null
    duree: number | null
    actif: boolean | null
    createdAt: Date | null
  }

  export type NomenclatureActeCountAggregateOutputType = {
    id: number
    code: number
    libelle: number
    specialite: number
    tarif: number
    duree: number
    actif: number
    createdAt: number
    _all: number
  }


  export type NomenclatureActeAvgAggregateInputType = {
    tarif?: true
    duree?: true
  }

  export type NomenclatureActeSumAggregateInputType = {
    tarif?: true
    duree?: true
  }

  export type NomenclatureActeMinAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    specialite?: true
    tarif?: true
    duree?: true
    actif?: true
    createdAt?: true
  }

  export type NomenclatureActeMaxAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    specialite?: true
    tarif?: true
    duree?: true
    actif?: true
    createdAt?: true
  }

  export type NomenclatureActeCountAggregateInputType = {
    id?: true
    code?: true
    libelle?: true
    specialite?: true
    tarif?: true
    duree?: true
    actif?: true
    createdAt?: true
    _all?: true
  }

  export type NomenclatureActeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NomenclatureActe to aggregate.
     */
    where?: NomenclatureActeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NomenclatureActes to fetch.
     */
    orderBy?: NomenclatureActeOrderByWithRelationInput | NomenclatureActeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NomenclatureActeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NomenclatureActes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NomenclatureActes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NomenclatureActes
    **/
    _count?: true | NomenclatureActeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NomenclatureActeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NomenclatureActeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NomenclatureActeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NomenclatureActeMaxAggregateInputType
  }

  export type GetNomenclatureActeAggregateType<T extends NomenclatureActeAggregateArgs> = {
        [P in keyof T & keyof AggregateNomenclatureActe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNomenclatureActe[P]>
      : GetScalarType<T[P], AggregateNomenclatureActe[P]>
  }




  export type NomenclatureActeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NomenclatureActeWhereInput
    orderBy?: NomenclatureActeOrderByWithAggregationInput | NomenclatureActeOrderByWithAggregationInput[]
    by: NomenclatureActeScalarFieldEnum[] | NomenclatureActeScalarFieldEnum
    having?: NomenclatureActeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NomenclatureActeCountAggregateInputType | true
    _avg?: NomenclatureActeAvgAggregateInputType
    _sum?: NomenclatureActeSumAggregateInputType
    _min?: NomenclatureActeMinAggregateInputType
    _max?: NomenclatureActeMaxAggregateInputType
  }

  export type NomenclatureActeGroupByOutputType = {
    id: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal
    duree: number | null
    actif: boolean
    createdAt: Date
    _count: NomenclatureActeCountAggregateOutputType | null
    _avg: NomenclatureActeAvgAggregateOutputType | null
    _sum: NomenclatureActeSumAggregateOutputType | null
    _min: NomenclatureActeMinAggregateOutputType | null
    _max: NomenclatureActeMaxAggregateOutputType | null
  }

  type GetNomenclatureActeGroupByPayload<T extends NomenclatureActeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NomenclatureActeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NomenclatureActeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NomenclatureActeGroupByOutputType[P]>
            : GetScalarType<T[P], NomenclatureActeGroupByOutputType[P]>
        }
      >
    >


  export type NomenclatureActeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    specialite?: boolean
    tarif?: boolean
    duree?: boolean
    actif?: boolean
    createdAt?: boolean
    actes?: boolean | NomenclatureActe$actesArgs<ExtArgs>
    _count?: boolean | NomenclatureActeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nomenclatureActe"]>

  export type NomenclatureActeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    specialite?: boolean
    tarif?: boolean
    duree?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nomenclatureActe"]>

  export type NomenclatureActeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    libelle?: boolean
    specialite?: boolean
    tarif?: boolean
    duree?: boolean
    actif?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nomenclatureActe"]>

  export type NomenclatureActeSelectScalar = {
    id?: boolean
    code?: boolean
    libelle?: boolean
    specialite?: boolean
    tarif?: boolean
    duree?: boolean
    actif?: boolean
    createdAt?: boolean
  }

  export type NomenclatureActeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "libelle" | "specialite" | "tarif" | "duree" | "actif" | "createdAt", ExtArgs["result"]["nomenclatureActe"]>
  export type NomenclatureActeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actes?: boolean | NomenclatureActe$actesArgs<ExtArgs>
    _count?: boolean | NomenclatureActeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NomenclatureActeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NomenclatureActeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NomenclatureActePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NomenclatureActe"
    objects: {
      actes: Prisma.$ActeRealisePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      libelle: string
      specialite: string
      tarif: Prisma.Decimal
      duree: number | null
      actif: boolean
      createdAt: Date
    }, ExtArgs["result"]["nomenclatureActe"]>
    composites: {}
  }

  type NomenclatureActeGetPayload<S extends boolean | null | undefined | NomenclatureActeDefaultArgs> = $Result.GetResult<Prisma.$NomenclatureActePayload, S>

  type NomenclatureActeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NomenclatureActeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NomenclatureActeCountAggregateInputType | true
    }

  export interface NomenclatureActeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NomenclatureActe'], meta: { name: 'NomenclatureActe' } }
    /**
     * Find zero or one NomenclatureActe that matches the filter.
     * @param {NomenclatureActeFindUniqueArgs} args - Arguments to find a NomenclatureActe
     * @example
     * // Get one NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NomenclatureActeFindUniqueArgs>(args: SelectSubset<T, NomenclatureActeFindUniqueArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NomenclatureActe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NomenclatureActeFindUniqueOrThrowArgs} args - Arguments to find a NomenclatureActe
     * @example
     * // Get one NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NomenclatureActeFindUniqueOrThrowArgs>(args: SelectSubset<T, NomenclatureActeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NomenclatureActe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeFindFirstArgs} args - Arguments to find a NomenclatureActe
     * @example
     * // Get one NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NomenclatureActeFindFirstArgs>(args?: SelectSubset<T, NomenclatureActeFindFirstArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NomenclatureActe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeFindFirstOrThrowArgs} args - Arguments to find a NomenclatureActe
     * @example
     * // Get one NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NomenclatureActeFindFirstOrThrowArgs>(args?: SelectSubset<T, NomenclatureActeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NomenclatureActes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NomenclatureActes
     * const nomenclatureActes = await prisma.nomenclatureActe.findMany()
     * 
     * // Get first 10 NomenclatureActes
     * const nomenclatureActes = await prisma.nomenclatureActe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nomenclatureActeWithIdOnly = await prisma.nomenclatureActe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NomenclatureActeFindManyArgs>(args?: SelectSubset<T, NomenclatureActeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NomenclatureActe.
     * @param {NomenclatureActeCreateArgs} args - Arguments to create a NomenclatureActe.
     * @example
     * // Create one NomenclatureActe
     * const NomenclatureActe = await prisma.nomenclatureActe.create({
     *   data: {
     *     // ... data to create a NomenclatureActe
     *   }
     * })
     * 
     */
    create<T extends NomenclatureActeCreateArgs>(args: SelectSubset<T, NomenclatureActeCreateArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NomenclatureActes.
     * @param {NomenclatureActeCreateManyArgs} args - Arguments to create many NomenclatureActes.
     * @example
     * // Create many NomenclatureActes
     * const nomenclatureActe = await prisma.nomenclatureActe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NomenclatureActeCreateManyArgs>(args?: SelectSubset<T, NomenclatureActeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NomenclatureActes and returns the data saved in the database.
     * @param {NomenclatureActeCreateManyAndReturnArgs} args - Arguments to create many NomenclatureActes.
     * @example
     * // Create many NomenclatureActes
     * const nomenclatureActe = await prisma.nomenclatureActe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NomenclatureActes and only return the `id`
     * const nomenclatureActeWithIdOnly = await prisma.nomenclatureActe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NomenclatureActeCreateManyAndReturnArgs>(args?: SelectSubset<T, NomenclatureActeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NomenclatureActe.
     * @param {NomenclatureActeDeleteArgs} args - Arguments to delete one NomenclatureActe.
     * @example
     * // Delete one NomenclatureActe
     * const NomenclatureActe = await prisma.nomenclatureActe.delete({
     *   where: {
     *     // ... filter to delete one NomenclatureActe
     *   }
     * })
     * 
     */
    delete<T extends NomenclatureActeDeleteArgs>(args: SelectSubset<T, NomenclatureActeDeleteArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NomenclatureActe.
     * @param {NomenclatureActeUpdateArgs} args - Arguments to update one NomenclatureActe.
     * @example
     * // Update one NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NomenclatureActeUpdateArgs>(args: SelectSubset<T, NomenclatureActeUpdateArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NomenclatureActes.
     * @param {NomenclatureActeDeleteManyArgs} args - Arguments to filter NomenclatureActes to delete.
     * @example
     * // Delete a few NomenclatureActes
     * const { count } = await prisma.nomenclatureActe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NomenclatureActeDeleteManyArgs>(args?: SelectSubset<T, NomenclatureActeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NomenclatureActes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NomenclatureActes
     * const nomenclatureActe = await prisma.nomenclatureActe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NomenclatureActeUpdateManyArgs>(args: SelectSubset<T, NomenclatureActeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NomenclatureActes and returns the data updated in the database.
     * @param {NomenclatureActeUpdateManyAndReturnArgs} args - Arguments to update many NomenclatureActes.
     * @example
     * // Update many NomenclatureActes
     * const nomenclatureActe = await prisma.nomenclatureActe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NomenclatureActes and only return the `id`
     * const nomenclatureActeWithIdOnly = await prisma.nomenclatureActe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NomenclatureActeUpdateManyAndReturnArgs>(args: SelectSubset<T, NomenclatureActeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NomenclatureActe.
     * @param {NomenclatureActeUpsertArgs} args - Arguments to update or create a NomenclatureActe.
     * @example
     * // Update or create a NomenclatureActe
     * const nomenclatureActe = await prisma.nomenclatureActe.upsert({
     *   create: {
     *     // ... data to create a NomenclatureActe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NomenclatureActe we want to update
     *   }
     * })
     */
    upsert<T extends NomenclatureActeUpsertArgs>(args: SelectSubset<T, NomenclatureActeUpsertArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NomenclatureActes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeCountArgs} args - Arguments to filter NomenclatureActes to count.
     * @example
     * // Count the number of NomenclatureActes
     * const count = await prisma.nomenclatureActe.count({
     *   where: {
     *     // ... the filter for the NomenclatureActes we want to count
     *   }
     * })
    **/
    count<T extends NomenclatureActeCountArgs>(
      args?: Subset<T, NomenclatureActeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NomenclatureActeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NomenclatureActe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NomenclatureActeAggregateArgs>(args: Subset<T, NomenclatureActeAggregateArgs>): Prisma.PrismaPromise<GetNomenclatureActeAggregateType<T>>

    /**
     * Group by NomenclatureActe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NomenclatureActeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NomenclatureActeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NomenclatureActeGroupByArgs['orderBy'] }
        : { orderBy?: NomenclatureActeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NomenclatureActeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNomenclatureActeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NomenclatureActe model
   */
  readonly fields: NomenclatureActeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NomenclatureActe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NomenclatureActeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actes<T extends NomenclatureActe$actesArgs<ExtArgs> = {}>(args?: Subset<T, NomenclatureActe$actesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NomenclatureActe model
   */ 
  interface NomenclatureActeFieldRefs {
    readonly id: FieldRef<"NomenclatureActe", 'String'>
    readonly code: FieldRef<"NomenclatureActe", 'String'>
    readonly libelle: FieldRef<"NomenclatureActe", 'String'>
    readonly specialite: FieldRef<"NomenclatureActe", 'String'>
    readonly tarif: FieldRef<"NomenclatureActe", 'Decimal'>
    readonly duree: FieldRef<"NomenclatureActe", 'Int'>
    readonly actif: FieldRef<"NomenclatureActe", 'Boolean'>
    readonly createdAt: FieldRef<"NomenclatureActe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NomenclatureActe findUnique
   */
  export type NomenclatureActeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter, which NomenclatureActe to fetch.
     */
    where: NomenclatureActeWhereUniqueInput
  }

  /**
   * NomenclatureActe findUniqueOrThrow
   */
  export type NomenclatureActeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter, which NomenclatureActe to fetch.
     */
    where: NomenclatureActeWhereUniqueInput
  }

  /**
   * NomenclatureActe findFirst
   */
  export type NomenclatureActeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter, which NomenclatureActe to fetch.
     */
    where?: NomenclatureActeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NomenclatureActes to fetch.
     */
    orderBy?: NomenclatureActeOrderByWithRelationInput | NomenclatureActeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NomenclatureActes.
     */
    cursor?: NomenclatureActeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NomenclatureActes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NomenclatureActes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NomenclatureActes.
     */
    distinct?: NomenclatureActeScalarFieldEnum | NomenclatureActeScalarFieldEnum[]
  }

  /**
   * NomenclatureActe findFirstOrThrow
   */
  export type NomenclatureActeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter, which NomenclatureActe to fetch.
     */
    where?: NomenclatureActeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NomenclatureActes to fetch.
     */
    orderBy?: NomenclatureActeOrderByWithRelationInput | NomenclatureActeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NomenclatureActes.
     */
    cursor?: NomenclatureActeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NomenclatureActes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NomenclatureActes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NomenclatureActes.
     */
    distinct?: NomenclatureActeScalarFieldEnum | NomenclatureActeScalarFieldEnum[]
  }

  /**
   * NomenclatureActe findMany
   */
  export type NomenclatureActeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter, which NomenclatureActes to fetch.
     */
    where?: NomenclatureActeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NomenclatureActes to fetch.
     */
    orderBy?: NomenclatureActeOrderByWithRelationInput | NomenclatureActeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NomenclatureActes.
     */
    cursor?: NomenclatureActeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NomenclatureActes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NomenclatureActes.
     */
    skip?: number
    distinct?: NomenclatureActeScalarFieldEnum | NomenclatureActeScalarFieldEnum[]
  }

  /**
   * NomenclatureActe create
   */
  export type NomenclatureActeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * The data needed to create a NomenclatureActe.
     */
    data: XOR<NomenclatureActeCreateInput, NomenclatureActeUncheckedCreateInput>
  }

  /**
   * NomenclatureActe createMany
   */
  export type NomenclatureActeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NomenclatureActes.
     */
    data: NomenclatureActeCreateManyInput | NomenclatureActeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NomenclatureActe createManyAndReturn
   */
  export type NomenclatureActeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * The data used to create many NomenclatureActes.
     */
    data: NomenclatureActeCreateManyInput | NomenclatureActeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NomenclatureActe update
   */
  export type NomenclatureActeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * The data needed to update a NomenclatureActe.
     */
    data: XOR<NomenclatureActeUpdateInput, NomenclatureActeUncheckedUpdateInput>
    /**
     * Choose, which NomenclatureActe to update.
     */
    where: NomenclatureActeWhereUniqueInput
  }

  /**
   * NomenclatureActe updateMany
   */
  export type NomenclatureActeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NomenclatureActes.
     */
    data: XOR<NomenclatureActeUpdateManyMutationInput, NomenclatureActeUncheckedUpdateManyInput>
    /**
     * Filter which NomenclatureActes to update
     */
    where?: NomenclatureActeWhereInput
  }

  /**
   * NomenclatureActe updateManyAndReturn
   */
  export type NomenclatureActeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * The data used to update NomenclatureActes.
     */
    data: XOR<NomenclatureActeUpdateManyMutationInput, NomenclatureActeUncheckedUpdateManyInput>
    /**
     * Filter which NomenclatureActes to update
     */
    where?: NomenclatureActeWhereInput
  }

  /**
   * NomenclatureActe upsert
   */
  export type NomenclatureActeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * The filter to search for the NomenclatureActe to update in case it exists.
     */
    where: NomenclatureActeWhereUniqueInput
    /**
     * In case the NomenclatureActe found by the `where` argument doesn't exist, create a new NomenclatureActe with this data.
     */
    create: XOR<NomenclatureActeCreateInput, NomenclatureActeUncheckedCreateInput>
    /**
     * In case the NomenclatureActe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NomenclatureActeUpdateInput, NomenclatureActeUncheckedUpdateInput>
  }

  /**
   * NomenclatureActe delete
   */
  export type NomenclatureActeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
    /**
     * Filter which NomenclatureActe to delete.
     */
    where: NomenclatureActeWhereUniqueInput
  }

  /**
   * NomenclatureActe deleteMany
   */
  export type NomenclatureActeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NomenclatureActes to delete
     */
    where?: NomenclatureActeWhereInput
  }

  /**
   * NomenclatureActe.actes
   */
  export type NomenclatureActe$actesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    where?: ActeRealiseWhereInput
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    cursor?: ActeRealiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActeRealiseScalarFieldEnum | ActeRealiseScalarFieldEnum[]
  }

  /**
   * NomenclatureActe without action
   */
  export type NomenclatureActeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NomenclatureActe
     */
    select?: NomenclatureActeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NomenclatureActe
     */
    omit?: NomenclatureActeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NomenclatureActeInclude<ExtArgs> | null
  }


  /**
   * Model ActeRealise
   */

  export type AggregateActeRealise = {
    _count: ActeRealiseCountAggregateOutputType | null
    _avg: ActeRealiseAvgAggregateOutputType | null
    _sum: ActeRealiseSumAggregateOutputType | null
    _min: ActeRealiseMinAggregateOutputType | null
    _max: ActeRealiseMaxAggregateOutputType | null
  }

  export type ActeRealiseAvgAggregateOutputType = {
    quantite: number | null
    tarif: Decimal | null
    montant: Decimal | null
  }

  export type ActeRealiseSumAggregateOutputType = {
    quantite: number | null
    tarif: Decimal | null
    montant: Decimal | null
  }

  export type ActeRealiseMinAggregateOutputType = {
    id: string | null
    consultationId: string | null
    acteId: string | null
    quantite: number | null
    tarif: Decimal | null
    montant: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type ActeRealiseMaxAggregateOutputType = {
    id: string | null
    consultationId: string | null
    acteId: string | null
    quantite: number | null
    tarif: Decimal | null
    montant: Decimal | null
    notes: string | null
    createdAt: Date | null
  }

  export type ActeRealiseCountAggregateOutputType = {
    id: number
    consultationId: number
    acteId: number
    quantite: number
    tarif: number
    montant: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ActeRealiseAvgAggregateInputType = {
    quantite?: true
    tarif?: true
    montant?: true
  }

  export type ActeRealiseSumAggregateInputType = {
    quantite?: true
    tarif?: true
    montant?: true
  }

  export type ActeRealiseMinAggregateInputType = {
    id?: true
    consultationId?: true
    acteId?: true
    quantite?: true
    tarif?: true
    montant?: true
    notes?: true
    createdAt?: true
  }

  export type ActeRealiseMaxAggregateInputType = {
    id?: true
    consultationId?: true
    acteId?: true
    quantite?: true
    tarif?: true
    montant?: true
    notes?: true
    createdAt?: true
  }

  export type ActeRealiseCountAggregateInputType = {
    id?: true
    consultationId?: true
    acteId?: true
    quantite?: true
    tarif?: true
    montant?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ActeRealiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActeRealise to aggregate.
     */
    where?: ActeRealiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActeRealises to fetch.
     */
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActeRealiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActeRealises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActeRealises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActeRealises
    **/
    _count?: true | ActeRealiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActeRealiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActeRealiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActeRealiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActeRealiseMaxAggregateInputType
  }

  export type GetActeRealiseAggregateType<T extends ActeRealiseAggregateArgs> = {
        [P in keyof T & keyof AggregateActeRealise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActeRealise[P]>
      : GetScalarType<T[P], AggregateActeRealise[P]>
  }




  export type ActeRealiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActeRealiseWhereInput
    orderBy?: ActeRealiseOrderByWithAggregationInput | ActeRealiseOrderByWithAggregationInput[]
    by: ActeRealiseScalarFieldEnum[] | ActeRealiseScalarFieldEnum
    having?: ActeRealiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActeRealiseCountAggregateInputType | true
    _avg?: ActeRealiseAvgAggregateInputType
    _sum?: ActeRealiseSumAggregateInputType
    _min?: ActeRealiseMinAggregateInputType
    _max?: ActeRealiseMaxAggregateInputType
  }

  export type ActeRealiseGroupByOutputType = {
    id: string
    consultationId: string
    acteId: string
    quantite: number
    tarif: Decimal
    montant: Decimal
    notes: string | null
    createdAt: Date
    _count: ActeRealiseCountAggregateOutputType | null
    _avg: ActeRealiseAvgAggregateOutputType | null
    _sum: ActeRealiseSumAggregateOutputType | null
    _min: ActeRealiseMinAggregateOutputType | null
    _max: ActeRealiseMaxAggregateOutputType | null
  }

  type GetActeRealiseGroupByPayload<T extends ActeRealiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActeRealiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActeRealiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActeRealiseGroupByOutputType[P]>
            : GetScalarType<T[P], ActeRealiseGroupByOutputType[P]>
        }
      >
    >


  export type ActeRealiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    acteId?: boolean
    quantite?: boolean
    tarif?: boolean
    montant?: boolean
    notes?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
    resultat?: boolean | ActeRealise$resultatArgs<ExtArgs>
  }, ExtArgs["result"]["acteRealise"]>

  export type ActeRealiseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    acteId?: boolean
    quantite?: boolean
    tarif?: boolean
    montant?: boolean
    notes?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acteRealise"]>

  export type ActeRealiseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    consultationId?: boolean
    acteId?: boolean
    quantite?: boolean
    tarif?: boolean
    montant?: boolean
    notes?: boolean
    createdAt?: boolean
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acteRealise"]>

  export type ActeRealiseSelectScalar = {
    id?: boolean
    consultationId?: boolean
    acteId?: boolean
    quantite?: boolean
    tarif?: boolean
    montant?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ActeRealiseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "consultationId" | "acteId" | "quantite" | "tarif" | "montant" | "notes" | "createdAt", ExtArgs["result"]["acteRealise"]>
  export type ActeRealiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
    resultat?: boolean | ActeRealise$resultatArgs<ExtArgs>
  }
  export type ActeRealiseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
  }
  export type ActeRealiseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    consultation?: boolean | ConsultationDefaultArgs<ExtArgs>
    acte?: boolean | NomenclatureActeDefaultArgs<ExtArgs>
  }

  export type $ActeRealisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActeRealise"
    objects: {
      consultation: Prisma.$ConsultationPayload<ExtArgs>
      acte: Prisma.$NomenclatureActePayload<ExtArgs>
      resultat: Prisma.$ResultatExamenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      consultationId: string
      acteId: string
      quantite: number
      tarif: Prisma.Decimal
      montant: Prisma.Decimal
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["acteRealise"]>
    composites: {}
  }

  type ActeRealiseGetPayload<S extends boolean | null | undefined | ActeRealiseDefaultArgs> = $Result.GetResult<Prisma.$ActeRealisePayload, S>

  type ActeRealiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActeRealiseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActeRealiseCountAggregateInputType | true
    }

  export interface ActeRealiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActeRealise'], meta: { name: 'ActeRealise' } }
    /**
     * Find zero or one ActeRealise that matches the filter.
     * @param {ActeRealiseFindUniqueArgs} args - Arguments to find a ActeRealise
     * @example
     * // Get one ActeRealise
     * const acteRealise = await prisma.acteRealise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActeRealiseFindUniqueArgs>(args: SelectSubset<T, ActeRealiseFindUniqueArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ActeRealise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActeRealiseFindUniqueOrThrowArgs} args - Arguments to find a ActeRealise
     * @example
     * // Get one ActeRealise
     * const acteRealise = await prisma.acteRealise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActeRealiseFindUniqueOrThrowArgs>(args: SelectSubset<T, ActeRealiseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ActeRealise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseFindFirstArgs} args - Arguments to find a ActeRealise
     * @example
     * // Get one ActeRealise
     * const acteRealise = await prisma.acteRealise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActeRealiseFindFirstArgs>(args?: SelectSubset<T, ActeRealiseFindFirstArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ActeRealise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseFindFirstOrThrowArgs} args - Arguments to find a ActeRealise
     * @example
     * // Get one ActeRealise
     * const acteRealise = await prisma.acteRealise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActeRealiseFindFirstOrThrowArgs>(args?: SelectSubset<T, ActeRealiseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ActeRealises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActeRealises
     * const acteRealises = await prisma.acteRealise.findMany()
     * 
     * // Get first 10 ActeRealises
     * const acteRealises = await prisma.acteRealise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const acteRealiseWithIdOnly = await prisma.acteRealise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActeRealiseFindManyArgs>(args?: SelectSubset<T, ActeRealiseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ActeRealise.
     * @param {ActeRealiseCreateArgs} args - Arguments to create a ActeRealise.
     * @example
     * // Create one ActeRealise
     * const ActeRealise = await prisma.acteRealise.create({
     *   data: {
     *     // ... data to create a ActeRealise
     *   }
     * })
     * 
     */
    create<T extends ActeRealiseCreateArgs>(args: SelectSubset<T, ActeRealiseCreateArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ActeRealises.
     * @param {ActeRealiseCreateManyArgs} args - Arguments to create many ActeRealises.
     * @example
     * // Create many ActeRealises
     * const acteRealise = await prisma.acteRealise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActeRealiseCreateManyArgs>(args?: SelectSubset<T, ActeRealiseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActeRealises and returns the data saved in the database.
     * @param {ActeRealiseCreateManyAndReturnArgs} args - Arguments to create many ActeRealises.
     * @example
     * // Create many ActeRealises
     * const acteRealise = await prisma.acteRealise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActeRealises and only return the `id`
     * const acteRealiseWithIdOnly = await prisma.acteRealise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActeRealiseCreateManyAndReturnArgs>(args?: SelectSubset<T, ActeRealiseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ActeRealise.
     * @param {ActeRealiseDeleteArgs} args - Arguments to delete one ActeRealise.
     * @example
     * // Delete one ActeRealise
     * const ActeRealise = await prisma.acteRealise.delete({
     *   where: {
     *     // ... filter to delete one ActeRealise
     *   }
     * })
     * 
     */
    delete<T extends ActeRealiseDeleteArgs>(args: SelectSubset<T, ActeRealiseDeleteArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ActeRealise.
     * @param {ActeRealiseUpdateArgs} args - Arguments to update one ActeRealise.
     * @example
     * // Update one ActeRealise
     * const acteRealise = await prisma.acteRealise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActeRealiseUpdateArgs>(args: SelectSubset<T, ActeRealiseUpdateArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ActeRealises.
     * @param {ActeRealiseDeleteManyArgs} args - Arguments to filter ActeRealises to delete.
     * @example
     * // Delete a few ActeRealises
     * const { count } = await prisma.acteRealise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActeRealiseDeleteManyArgs>(args?: SelectSubset<T, ActeRealiseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActeRealises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActeRealises
     * const acteRealise = await prisma.acteRealise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActeRealiseUpdateManyArgs>(args: SelectSubset<T, ActeRealiseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActeRealises and returns the data updated in the database.
     * @param {ActeRealiseUpdateManyAndReturnArgs} args - Arguments to update many ActeRealises.
     * @example
     * // Update many ActeRealises
     * const acteRealise = await prisma.acteRealise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActeRealises and only return the `id`
     * const acteRealiseWithIdOnly = await prisma.acteRealise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActeRealiseUpdateManyAndReturnArgs>(args: SelectSubset<T, ActeRealiseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ActeRealise.
     * @param {ActeRealiseUpsertArgs} args - Arguments to update or create a ActeRealise.
     * @example
     * // Update or create a ActeRealise
     * const acteRealise = await prisma.acteRealise.upsert({
     *   create: {
     *     // ... data to create a ActeRealise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActeRealise we want to update
     *   }
     * })
     */
    upsert<T extends ActeRealiseUpsertArgs>(args: SelectSubset<T, ActeRealiseUpsertArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ActeRealises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseCountArgs} args - Arguments to filter ActeRealises to count.
     * @example
     * // Count the number of ActeRealises
     * const count = await prisma.acteRealise.count({
     *   where: {
     *     // ... the filter for the ActeRealises we want to count
     *   }
     * })
    **/
    count<T extends ActeRealiseCountArgs>(
      args?: Subset<T, ActeRealiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActeRealiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActeRealise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActeRealiseAggregateArgs>(args: Subset<T, ActeRealiseAggregateArgs>): Prisma.PrismaPromise<GetActeRealiseAggregateType<T>>

    /**
     * Group by ActeRealise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActeRealiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActeRealiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActeRealiseGroupByArgs['orderBy'] }
        : { orderBy?: ActeRealiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActeRealiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActeRealiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActeRealise model
   */
  readonly fields: ActeRealiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActeRealise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActeRealiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    consultation<T extends ConsultationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConsultationDefaultArgs<ExtArgs>>): Prisma__ConsultationClient<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    acte<T extends NomenclatureActeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NomenclatureActeDefaultArgs<ExtArgs>>): Prisma__NomenclatureActeClient<$Result.GetResult<Prisma.$NomenclatureActePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    resultat<T extends ActeRealise$resultatArgs<ExtArgs> = {}>(args?: Subset<T, ActeRealise$resultatArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActeRealise model
   */ 
  interface ActeRealiseFieldRefs {
    readonly id: FieldRef<"ActeRealise", 'String'>
    readonly consultationId: FieldRef<"ActeRealise", 'String'>
    readonly acteId: FieldRef<"ActeRealise", 'String'>
    readonly quantite: FieldRef<"ActeRealise", 'Int'>
    readonly tarif: FieldRef<"ActeRealise", 'Decimal'>
    readonly montant: FieldRef<"ActeRealise", 'Decimal'>
    readonly notes: FieldRef<"ActeRealise", 'String'>
    readonly createdAt: FieldRef<"ActeRealise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActeRealise findUnique
   */
  export type ActeRealiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter, which ActeRealise to fetch.
     */
    where: ActeRealiseWhereUniqueInput
  }

  /**
   * ActeRealise findUniqueOrThrow
   */
  export type ActeRealiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter, which ActeRealise to fetch.
     */
    where: ActeRealiseWhereUniqueInput
  }

  /**
   * ActeRealise findFirst
   */
  export type ActeRealiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter, which ActeRealise to fetch.
     */
    where?: ActeRealiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActeRealises to fetch.
     */
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActeRealises.
     */
    cursor?: ActeRealiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActeRealises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActeRealises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActeRealises.
     */
    distinct?: ActeRealiseScalarFieldEnum | ActeRealiseScalarFieldEnum[]
  }

  /**
   * ActeRealise findFirstOrThrow
   */
  export type ActeRealiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter, which ActeRealise to fetch.
     */
    where?: ActeRealiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActeRealises to fetch.
     */
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActeRealises.
     */
    cursor?: ActeRealiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActeRealises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActeRealises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActeRealises.
     */
    distinct?: ActeRealiseScalarFieldEnum | ActeRealiseScalarFieldEnum[]
  }

  /**
   * ActeRealise findMany
   */
  export type ActeRealiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter, which ActeRealises to fetch.
     */
    where?: ActeRealiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActeRealises to fetch.
     */
    orderBy?: ActeRealiseOrderByWithRelationInput | ActeRealiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActeRealises.
     */
    cursor?: ActeRealiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActeRealises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActeRealises.
     */
    skip?: number
    distinct?: ActeRealiseScalarFieldEnum | ActeRealiseScalarFieldEnum[]
  }

  /**
   * ActeRealise create
   */
  export type ActeRealiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * The data needed to create a ActeRealise.
     */
    data: XOR<ActeRealiseCreateInput, ActeRealiseUncheckedCreateInput>
  }

  /**
   * ActeRealise createMany
   */
  export type ActeRealiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActeRealises.
     */
    data: ActeRealiseCreateManyInput | ActeRealiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActeRealise createManyAndReturn
   */
  export type ActeRealiseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * The data used to create many ActeRealises.
     */
    data: ActeRealiseCreateManyInput | ActeRealiseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActeRealise update
   */
  export type ActeRealiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * The data needed to update a ActeRealise.
     */
    data: XOR<ActeRealiseUpdateInput, ActeRealiseUncheckedUpdateInput>
    /**
     * Choose, which ActeRealise to update.
     */
    where: ActeRealiseWhereUniqueInput
  }

  /**
   * ActeRealise updateMany
   */
  export type ActeRealiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActeRealises.
     */
    data: XOR<ActeRealiseUpdateManyMutationInput, ActeRealiseUncheckedUpdateManyInput>
    /**
     * Filter which ActeRealises to update
     */
    where?: ActeRealiseWhereInput
  }

  /**
   * ActeRealise updateManyAndReturn
   */
  export type ActeRealiseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * The data used to update ActeRealises.
     */
    data: XOR<ActeRealiseUpdateManyMutationInput, ActeRealiseUncheckedUpdateManyInput>
    /**
     * Filter which ActeRealises to update
     */
    where?: ActeRealiseWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActeRealise upsert
   */
  export type ActeRealiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * The filter to search for the ActeRealise to update in case it exists.
     */
    where: ActeRealiseWhereUniqueInput
    /**
     * In case the ActeRealise found by the `where` argument doesn't exist, create a new ActeRealise with this data.
     */
    create: XOR<ActeRealiseCreateInput, ActeRealiseUncheckedCreateInput>
    /**
     * In case the ActeRealise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActeRealiseUpdateInput, ActeRealiseUncheckedUpdateInput>
  }

  /**
   * ActeRealise delete
   */
  export type ActeRealiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
    /**
     * Filter which ActeRealise to delete.
     */
    where: ActeRealiseWhereUniqueInput
  }

  /**
   * ActeRealise deleteMany
   */
  export type ActeRealiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActeRealises to delete
     */
    where?: ActeRealiseWhereInput
  }

  /**
   * ActeRealise.resultat
   */
  export type ActeRealise$resultatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    where?: ResultatExamenWhereInput
  }

  /**
   * ActeRealise without action
   */
  export type ActeRealiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActeRealise
     */
    select?: ActeRealiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActeRealise
     */
    omit?: ActeRealiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActeRealiseInclude<ExtArgs> | null
  }


  /**
   * Model ResultatExamen
   */

  export type AggregateResultatExamen = {
    _count: ResultatExamenCountAggregateOutputType | null
    _min: ResultatExamenMinAggregateOutputType | null
    _max: ResultatExamenMaxAggregateOutputType | null
  }

  export type ResultatExamenMinAggregateOutputType = {
    id: string | null
    acteRealiseId: string | null
    conclusion: string | null
    compteRendu: string | null
    dateExamen: Date | null
    validePar: string | null
    dateValidation: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultatExamenMaxAggregateOutputType = {
    id: string | null
    acteRealiseId: string | null
    conclusion: string | null
    compteRendu: string | null
    dateExamen: Date | null
    validePar: string | null
    dateValidation: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultatExamenCountAggregateOutputType = {
    id: number
    acteRealiseId: number
    valeurs: number
    conclusion: number
    compteRendu: number
    images: number
    dateExamen: number
    validePar: number
    dateValidation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultatExamenMinAggregateInputType = {
    id?: true
    acteRealiseId?: true
    conclusion?: true
    compteRendu?: true
    dateExamen?: true
    validePar?: true
    dateValidation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultatExamenMaxAggregateInputType = {
    id?: true
    acteRealiseId?: true
    conclusion?: true
    compteRendu?: true
    dateExamen?: true
    validePar?: true
    dateValidation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultatExamenCountAggregateInputType = {
    id?: true
    acteRealiseId?: true
    valeurs?: true
    conclusion?: true
    compteRendu?: true
    images?: true
    dateExamen?: true
    validePar?: true
    dateValidation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultatExamenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultatExamen to aggregate.
     */
    where?: ResultatExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatExamen to fetch.
     */
    orderBy?: ResultatExamenOrderByWithRelationInput | ResultatExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultatExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatExamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatExamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultatExamen
    **/
    _count?: true | ResultatExamenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultatExamenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultatExamenMaxAggregateInputType
  }

  export type GetResultatExamenAggregateType<T extends ResultatExamenAggregateArgs> = {
        [P in keyof T & keyof AggregateResultatExamen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultatExamen[P]>
      : GetScalarType<T[P], AggregateResultatExamen[P]>
  }




  export type ResultatExamenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatExamenWhereInput
    orderBy?: ResultatExamenOrderByWithAggregationInput | ResultatExamenOrderByWithAggregationInput[]
    by: ResultatExamenScalarFieldEnum[] | ResultatExamenScalarFieldEnum
    having?: ResultatExamenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultatExamenCountAggregateInputType | true
    _min?: ResultatExamenMinAggregateInputType
    _max?: ResultatExamenMaxAggregateInputType
  }

  export type ResultatExamenGroupByOutputType = {
    id: string
    acteRealiseId: string
    valeurs: JsonValue | null
    conclusion: string | null
    compteRendu: string | null
    images: string[]
    dateExamen: Date
    validePar: string | null
    dateValidation: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ResultatExamenCountAggregateOutputType | null
    _min: ResultatExamenMinAggregateOutputType | null
    _max: ResultatExamenMaxAggregateOutputType | null
  }

  type GetResultatExamenGroupByPayload<T extends ResultatExamenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultatExamenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultatExamenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultatExamenGroupByOutputType[P]>
            : GetScalarType<T[P], ResultatExamenGroupByOutputType[P]>
        }
      >
    >


  export type ResultatExamenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acteRealiseId?: boolean
    valeurs?: boolean
    conclusion?: boolean
    compteRendu?: boolean
    images?: boolean
    dateExamen?: boolean
    validePar?: boolean
    dateValidation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultatExamen"]>

  export type ResultatExamenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acteRealiseId?: boolean
    valeurs?: boolean
    conclusion?: boolean
    compteRendu?: boolean
    images?: boolean
    dateExamen?: boolean
    validePar?: boolean
    dateValidation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultatExamen"]>

  export type ResultatExamenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acteRealiseId?: boolean
    valeurs?: boolean
    conclusion?: boolean
    compteRendu?: boolean
    images?: boolean
    dateExamen?: boolean
    validePar?: boolean
    dateValidation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultatExamen"]>

  export type ResultatExamenSelectScalar = {
    id?: boolean
    acteRealiseId?: boolean
    valeurs?: boolean
    conclusion?: boolean
    compteRendu?: boolean
    images?: boolean
    dateExamen?: boolean
    validePar?: boolean
    dateValidation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultatExamenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "acteRealiseId" | "valeurs" | "conclusion" | "compteRendu" | "images" | "dateExamen" | "validePar" | "dateValidation" | "createdAt" | "updatedAt", ExtArgs["result"]["resultatExamen"]>
  export type ResultatExamenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }
  export type ResultatExamenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }
  export type ResultatExamenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    acteRealise?: boolean | ActeRealiseDefaultArgs<ExtArgs>
  }

  export type $ResultatExamenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultatExamen"
    objects: {
      acteRealise: Prisma.$ActeRealisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acteRealiseId: string
      valeurs: Prisma.JsonValue | null
      conclusion: string | null
      compteRendu: string | null
      images: string[]
      dateExamen: Date
      validePar: string | null
      dateValidation: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resultatExamen"]>
    composites: {}
  }

  type ResultatExamenGetPayload<S extends boolean | null | undefined | ResultatExamenDefaultArgs> = $Result.GetResult<Prisma.$ResultatExamenPayload, S>

  type ResultatExamenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResultatExamenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResultatExamenCountAggregateInputType | true
    }

  export interface ResultatExamenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultatExamen'], meta: { name: 'ResultatExamen' } }
    /**
     * Find zero or one ResultatExamen that matches the filter.
     * @param {ResultatExamenFindUniqueArgs} args - Arguments to find a ResultatExamen
     * @example
     * // Get one ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultatExamenFindUniqueArgs>(args: SelectSubset<T, ResultatExamenFindUniqueArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ResultatExamen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResultatExamenFindUniqueOrThrowArgs} args - Arguments to find a ResultatExamen
     * @example
     * // Get one ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultatExamenFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultatExamenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ResultatExamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenFindFirstArgs} args - Arguments to find a ResultatExamen
     * @example
     * // Get one ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultatExamenFindFirstArgs>(args?: SelectSubset<T, ResultatExamenFindFirstArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ResultatExamen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenFindFirstOrThrowArgs} args - Arguments to find a ResultatExamen
     * @example
     * // Get one ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultatExamenFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultatExamenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ResultatExamen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findMany()
     * 
     * // Get first 10 ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultatExamenWithIdOnly = await prisma.resultatExamen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultatExamenFindManyArgs>(args?: SelectSubset<T, ResultatExamenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ResultatExamen.
     * @param {ResultatExamenCreateArgs} args - Arguments to create a ResultatExamen.
     * @example
     * // Create one ResultatExamen
     * const ResultatExamen = await prisma.resultatExamen.create({
     *   data: {
     *     // ... data to create a ResultatExamen
     *   }
     * })
     * 
     */
    create<T extends ResultatExamenCreateArgs>(args: SelectSubset<T, ResultatExamenCreateArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ResultatExamen.
     * @param {ResultatExamenCreateManyArgs} args - Arguments to create many ResultatExamen.
     * @example
     * // Create many ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultatExamenCreateManyArgs>(args?: SelectSubset<T, ResultatExamenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultatExamen and returns the data saved in the database.
     * @param {ResultatExamenCreateManyAndReturnArgs} args - Arguments to create many ResultatExamen.
     * @example
     * // Create many ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultatExamen and only return the `id`
     * const resultatExamenWithIdOnly = await prisma.resultatExamen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultatExamenCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultatExamenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ResultatExamen.
     * @param {ResultatExamenDeleteArgs} args - Arguments to delete one ResultatExamen.
     * @example
     * // Delete one ResultatExamen
     * const ResultatExamen = await prisma.resultatExamen.delete({
     *   where: {
     *     // ... filter to delete one ResultatExamen
     *   }
     * })
     * 
     */
    delete<T extends ResultatExamenDeleteArgs>(args: SelectSubset<T, ResultatExamenDeleteArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ResultatExamen.
     * @param {ResultatExamenUpdateArgs} args - Arguments to update one ResultatExamen.
     * @example
     * // Update one ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultatExamenUpdateArgs>(args: SelectSubset<T, ResultatExamenUpdateArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ResultatExamen.
     * @param {ResultatExamenDeleteManyArgs} args - Arguments to filter ResultatExamen to delete.
     * @example
     * // Delete a few ResultatExamen
     * const { count } = await prisma.resultatExamen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultatExamenDeleteManyArgs>(args?: SelectSubset<T, ResultatExamenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultatExamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultatExamenUpdateManyArgs>(args: SelectSubset<T, ResultatExamenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultatExamen and returns the data updated in the database.
     * @param {ResultatExamenUpdateManyAndReturnArgs} args - Arguments to update many ResultatExamen.
     * @example
     * // Update many ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResultatExamen and only return the `id`
     * const resultatExamenWithIdOnly = await prisma.resultatExamen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResultatExamenUpdateManyAndReturnArgs>(args: SelectSubset<T, ResultatExamenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ResultatExamen.
     * @param {ResultatExamenUpsertArgs} args - Arguments to update or create a ResultatExamen.
     * @example
     * // Update or create a ResultatExamen
     * const resultatExamen = await prisma.resultatExamen.upsert({
     *   create: {
     *     // ... data to create a ResultatExamen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultatExamen we want to update
     *   }
     * })
     */
    upsert<T extends ResultatExamenUpsertArgs>(args: SelectSubset<T, ResultatExamenUpsertArgs<ExtArgs>>): Prisma__ResultatExamenClient<$Result.GetResult<Prisma.$ResultatExamenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ResultatExamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenCountArgs} args - Arguments to filter ResultatExamen to count.
     * @example
     * // Count the number of ResultatExamen
     * const count = await prisma.resultatExamen.count({
     *   where: {
     *     // ... the filter for the ResultatExamen we want to count
     *   }
     * })
    **/
    count<T extends ResultatExamenCountArgs>(
      args?: Subset<T, ResultatExamenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultatExamenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultatExamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultatExamenAggregateArgs>(args: Subset<T, ResultatExamenAggregateArgs>): Prisma.PrismaPromise<GetResultatExamenAggregateType<T>>

    /**
     * Group by ResultatExamen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatExamenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultatExamenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultatExamenGroupByArgs['orderBy'] }
        : { orderBy?: ResultatExamenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultatExamenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultatExamenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultatExamen model
   */
  readonly fields: ResultatExamenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultatExamen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultatExamenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    acteRealise<T extends ActeRealiseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActeRealiseDefaultArgs<ExtArgs>>): Prisma__ActeRealiseClient<$Result.GetResult<Prisma.$ActeRealisePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultatExamen model
   */ 
  interface ResultatExamenFieldRefs {
    readonly id: FieldRef<"ResultatExamen", 'String'>
    readonly acteRealiseId: FieldRef<"ResultatExamen", 'String'>
    readonly valeurs: FieldRef<"ResultatExamen", 'Json'>
    readonly conclusion: FieldRef<"ResultatExamen", 'String'>
    readonly compteRendu: FieldRef<"ResultatExamen", 'String'>
    readonly images: FieldRef<"ResultatExamen", 'String[]'>
    readonly dateExamen: FieldRef<"ResultatExamen", 'DateTime'>
    readonly validePar: FieldRef<"ResultatExamen", 'String'>
    readonly dateValidation: FieldRef<"ResultatExamen", 'DateTime'>
    readonly createdAt: FieldRef<"ResultatExamen", 'DateTime'>
    readonly updatedAt: FieldRef<"ResultatExamen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResultatExamen findUnique
   */
  export type ResultatExamenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter, which ResultatExamen to fetch.
     */
    where: ResultatExamenWhereUniqueInput
  }

  /**
   * ResultatExamen findUniqueOrThrow
   */
  export type ResultatExamenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter, which ResultatExamen to fetch.
     */
    where: ResultatExamenWhereUniqueInput
  }

  /**
   * ResultatExamen findFirst
   */
  export type ResultatExamenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter, which ResultatExamen to fetch.
     */
    where?: ResultatExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatExamen to fetch.
     */
    orderBy?: ResultatExamenOrderByWithRelationInput | ResultatExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultatExamen.
     */
    cursor?: ResultatExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatExamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatExamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultatExamen.
     */
    distinct?: ResultatExamenScalarFieldEnum | ResultatExamenScalarFieldEnum[]
  }

  /**
   * ResultatExamen findFirstOrThrow
   */
  export type ResultatExamenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter, which ResultatExamen to fetch.
     */
    where?: ResultatExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatExamen to fetch.
     */
    orderBy?: ResultatExamenOrderByWithRelationInput | ResultatExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultatExamen.
     */
    cursor?: ResultatExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatExamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatExamen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultatExamen.
     */
    distinct?: ResultatExamenScalarFieldEnum | ResultatExamenScalarFieldEnum[]
  }

  /**
   * ResultatExamen findMany
   */
  export type ResultatExamenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter, which ResultatExamen to fetch.
     */
    where?: ResultatExamenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatExamen to fetch.
     */
    orderBy?: ResultatExamenOrderByWithRelationInput | ResultatExamenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultatExamen.
     */
    cursor?: ResultatExamenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatExamen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatExamen.
     */
    skip?: number
    distinct?: ResultatExamenScalarFieldEnum | ResultatExamenScalarFieldEnum[]
  }

  /**
   * ResultatExamen create
   */
  export type ResultatExamenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultatExamen.
     */
    data: XOR<ResultatExamenCreateInput, ResultatExamenUncheckedCreateInput>
  }

  /**
   * ResultatExamen createMany
   */
  export type ResultatExamenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultatExamen.
     */
    data: ResultatExamenCreateManyInput | ResultatExamenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultatExamen createManyAndReturn
   */
  export type ResultatExamenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * The data used to create many ResultatExamen.
     */
    data: ResultatExamenCreateManyInput | ResultatExamenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultatExamen update
   */
  export type ResultatExamenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultatExamen.
     */
    data: XOR<ResultatExamenUpdateInput, ResultatExamenUncheckedUpdateInput>
    /**
     * Choose, which ResultatExamen to update.
     */
    where: ResultatExamenWhereUniqueInput
  }

  /**
   * ResultatExamen updateMany
   */
  export type ResultatExamenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultatExamen.
     */
    data: XOR<ResultatExamenUpdateManyMutationInput, ResultatExamenUncheckedUpdateManyInput>
    /**
     * Filter which ResultatExamen to update
     */
    where?: ResultatExamenWhereInput
  }

  /**
   * ResultatExamen updateManyAndReturn
   */
  export type ResultatExamenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * The data used to update ResultatExamen.
     */
    data: XOR<ResultatExamenUpdateManyMutationInput, ResultatExamenUncheckedUpdateManyInput>
    /**
     * Filter which ResultatExamen to update
     */
    where?: ResultatExamenWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultatExamen upsert
   */
  export type ResultatExamenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultatExamen to update in case it exists.
     */
    where: ResultatExamenWhereUniqueInput
    /**
     * In case the ResultatExamen found by the `where` argument doesn't exist, create a new ResultatExamen with this data.
     */
    create: XOR<ResultatExamenCreateInput, ResultatExamenUncheckedCreateInput>
    /**
     * In case the ResultatExamen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultatExamenUpdateInput, ResultatExamenUncheckedUpdateInput>
  }

  /**
   * ResultatExamen delete
   */
  export type ResultatExamenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
    /**
     * Filter which ResultatExamen to delete.
     */
    where: ResultatExamenWhereUniqueInput
  }

  /**
   * ResultatExamen deleteMany
   */
  export type ResultatExamenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultatExamen to delete
     */
    where?: ResultatExamenWhereInput
  }

  /**
   * ResultatExamen without action
   */
  export type ResultatExamenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatExamen
     */
    select?: ResultatExamenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResultatExamen
     */
    omit?: ResultatExamenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatExamenInclude<ExtArgs> | null
  }


  /**
   * Model Medicament
   */

  export type AggregateMedicament = {
    _count: MedicamentCountAggregateOutputType | null
    _avg: MedicamentAvgAggregateOutputType | null
    _sum: MedicamentSumAggregateOutputType | null
    _min: MedicamentMinAggregateOutputType | null
    _max: MedicamentMaxAggregateOutputType | null
  }

  export type MedicamentAvgAggregateOutputType = {
    prixAchat: Decimal | null
    prixVente: Decimal | null
    stockMinimum: number | null
  }

  export type MedicamentSumAggregateOutputType = {
    prixAchat: Decimal | null
    prixVente: Decimal | null
    stockMinimum: number | null
  }

  export type MedicamentMinAggregateOutputType = {
    id: string | null
    codeANIS: string | null
    dci: string | null
    nomCommercial: string | null
    forme: string | null
    dosage: string | null
    fabricant: string | null
    prixAchat: Decimal | null
    prixVente: Decimal | null
    stockMinimum: number | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicamentMaxAggregateOutputType = {
    id: string | null
    codeANIS: string | null
    dci: string | null
    nomCommercial: string | null
    forme: string | null
    dosage: string | null
    fabricant: string | null
    prixAchat: Decimal | null
    prixVente: Decimal | null
    stockMinimum: number | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicamentCountAggregateOutputType = {
    id: number
    codeANIS: number
    dci: number
    nomCommercial: number
    forme: number
    dosage: number
    fabricant: number
    prixAchat: number
    prixVente: number
    stockMinimum: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicamentAvgAggregateInputType = {
    prixAchat?: true
    prixVente?: true
    stockMinimum?: true
  }

  export type MedicamentSumAggregateInputType = {
    prixAchat?: true
    prixVente?: true
    stockMinimum?: true
  }

  export type MedicamentMinAggregateInputType = {
    id?: true
    codeANIS?: true
    dci?: true
    nomCommercial?: true
    forme?: true
    dosage?: true
    fabricant?: true
    prixAchat?: true
    prixVente?: true
    stockMinimum?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicamentMaxAggregateInputType = {
    id?: true
    codeANIS?: true
    dci?: true
    nomCommercial?: true
    forme?: true
    dosage?: true
    fabricant?: true
    prixAchat?: true
    prixVente?: true
    stockMinimum?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicamentCountAggregateInputType = {
    id?: true
    codeANIS?: true
    dci?: true
    nomCommercial?: true
    forme?: true
    dosage?: true
    fabricant?: true
    prixAchat?: true
    prixVente?: true
    stockMinimum?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicament to aggregate.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicaments
    **/
    _count?: true | MedicamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicamentMaxAggregateInputType
  }

  export type GetMedicamentAggregateType<T extends MedicamentAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicament[P]>
      : GetScalarType<T[P], AggregateMedicament[P]>
  }




  export type MedicamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicamentWhereInput
    orderBy?: MedicamentOrderByWithAggregationInput | MedicamentOrderByWithAggregationInput[]
    by: MedicamentScalarFieldEnum[] | MedicamentScalarFieldEnum
    having?: MedicamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicamentCountAggregateInputType | true
    _avg?: MedicamentAvgAggregateInputType
    _sum?: MedicamentSumAggregateInputType
    _min?: MedicamentMinAggregateInputType
    _max?: MedicamentMaxAggregateInputType
  }

  export type MedicamentGroupByOutputType = {
    id: string
    codeANIS: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant: string | null
    prixAchat: Decimal
    prixVente: Decimal
    stockMinimum: number
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicamentCountAggregateOutputType | null
    _avg: MedicamentAvgAggregateOutputType | null
    _sum: MedicamentSumAggregateOutputType | null
    _min: MedicamentMinAggregateOutputType | null
    _max: MedicamentMaxAggregateOutputType | null
  }

  type GetMedicamentGroupByPayload<T extends MedicamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicamentGroupByOutputType[P]>
            : GetScalarType<T[P], MedicamentGroupByOutputType[P]>
        }
      >
    >


  export type MedicamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codeANIS?: boolean
    dci?: boolean
    nomCommercial?: boolean
    forme?: boolean
    dosage?: boolean
    fabricant?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    stockMinimum?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    stocks?: boolean | Medicament$stocksArgs<ExtArgs>
    mouvements?: boolean | Medicament$mouvementsArgs<ExtArgs>
    dispensations?: boolean | Medicament$dispensationsArgs<ExtArgs>
    commandes?: boolean | Medicament$commandesArgs<ExtArgs>
    _count?: boolean | MedicamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicament"]>

  export type MedicamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codeANIS?: boolean
    dci?: boolean
    nomCommercial?: boolean
    forme?: boolean
    dosage?: boolean
    fabricant?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    stockMinimum?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicament"]>

  export type MedicamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codeANIS?: boolean
    dci?: boolean
    nomCommercial?: boolean
    forme?: boolean
    dosage?: boolean
    fabricant?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    stockMinimum?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["medicament"]>

  export type MedicamentSelectScalar = {
    id?: boolean
    codeANIS?: boolean
    dci?: boolean
    nomCommercial?: boolean
    forme?: boolean
    dosage?: boolean
    fabricant?: boolean
    prixAchat?: boolean
    prixVente?: boolean
    stockMinimum?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codeANIS" | "dci" | "nomCommercial" | "forme" | "dosage" | "fabricant" | "prixAchat" | "prixVente" | "stockMinimum" | "actif" | "createdAt" | "updatedAt", ExtArgs["result"]["medicament"]>
  export type MedicamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stocks?: boolean | Medicament$stocksArgs<ExtArgs>
    mouvements?: boolean | Medicament$mouvementsArgs<ExtArgs>
    dispensations?: boolean | Medicament$dispensationsArgs<ExtArgs>
    commandes?: boolean | Medicament$commandesArgs<ExtArgs>
    _count?: boolean | MedicamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MedicamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicament"
    objects: {
      stocks: Prisma.$StockPayload<ExtArgs>[]
      mouvements: Prisma.$MouvementStockPayload<ExtArgs>[]
      dispensations: Prisma.$DispensationPayload<ExtArgs>[]
      commandes: Prisma.$LigneCommandePharmaciePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codeANIS: string | null
      dci: string
      nomCommercial: string
      forme: string
      dosage: string
      fabricant: string | null
      prixAchat: Prisma.Decimal
      prixVente: Prisma.Decimal
      stockMinimum: number
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicament"]>
    composites: {}
  }

  type MedicamentGetPayload<S extends boolean | null | undefined | MedicamentDefaultArgs> = $Result.GetResult<Prisma.$MedicamentPayload, S>

  type MedicamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicamentCountAggregateInputType | true
    }

  export interface MedicamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicament'], meta: { name: 'Medicament' } }
    /**
     * Find zero or one Medicament that matches the filter.
     * @param {MedicamentFindUniqueArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicamentFindUniqueArgs>(args: SelectSubset<T, MedicamentFindUniqueArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Medicament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicamentFindUniqueOrThrowArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicamentFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Medicament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindFirstArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicamentFindFirstArgs>(args?: SelectSubset<T, MedicamentFindFirstArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Medicament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindFirstOrThrowArgs} args - Arguments to find a Medicament
     * @example
     * // Get one Medicament
     * const medicament = await prisma.medicament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicamentFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Medicaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicaments
     * const medicaments = await prisma.medicament.findMany()
     * 
     * // Get first 10 Medicaments
     * const medicaments = await prisma.medicament.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicamentWithIdOnly = await prisma.medicament.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicamentFindManyArgs>(args?: SelectSubset<T, MedicamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Medicament.
     * @param {MedicamentCreateArgs} args - Arguments to create a Medicament.
     * @example
     * // Create one Medicament
     * const Medicament = await prisma.medicament.create({
     *   data: {
     *     // ... data to create a Medicament
     *   }
     * })
     * 
     */
    create<T extends MedicamentCreateArgs>(args: SelectSubset<T, MedicamentCreateArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Medicaments.
     * @param {MedicamentCreateManyArgs} args - Arguments to create many Medicaments.
     * @example
     * // Create many Medicaments
     * const medicament = await prisma.medicament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicamentCreateManyArgs>(args?: SelectSubset<T, MedicamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicaments and returns the data saved in the database.
     * @param {MedicamentCreateManyAndReturnArgs} args - Arguments to create many Medicaments.
     * @example
     * // Create many Medicaments
     * const medicament = await prisma.medicament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicaments and only return the `id`
     * const medicamentWithIdOnly = await prisma.medicament.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicamentCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Medicament.
     * @param {MedicamentDeleteArgs} args - Arguments to delete one Medicament.
     * @example
     * // Delete one Medicament
     * const Medicament = await prisma.medicament.delete({
     *   where: {
     *     // ... filter to delete one Medicament
     *   }
     * })
     * 
     */
    delete<T extends MedicamentDeleteArgs>(args: SelectSubset<T, MedicamentDeleteArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Medicament.
     * @param {MedicamentUpdateArgs} args - Arguments to update one Medicament.
     * @example
     * // Update one Medicament
     * const medicament = await prisma.medicament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicamentUpdateArgs>(args: SelectSubset<T, MedicamentUpdateArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Medicaments.
     * @param {MedicamentDeleteManyArgs} args - Arguments to filter Medicaments to delete.
     * @example
     * // Delete a few Medicaments
     * const { count } = await prisma.medicament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicamentDeleteManyArgs>(args?: SelectSubset<T, MedicamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicaments
     * const medicament = await prisma.medicament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicamentUpdateManyArgs>(args: SelectSubset<T, MedicamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicaments and returns the data updated in the database.
     * @param {MedicamentUpdateManyAndReturnArgs} args - Arguments to update many Medicaments.
     * @example
     * // Update many Medicaments
     * const medicament = await prisma.medicament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicaments and only return the `id`
     * const medicamentWithIdOnly = await prisma.medicament.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicamentUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Medicament.
     * @param {MedicamentUpsertArgs} args - Arguments to update or create a Medicament.
     * @example
     * // Update or create a Medicament
     * const medicament = await prisma.medicament.upsert({
     *   create: {
     *     // ... data to create a Medicament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicament we want to update
     *   }
     * })
     */
    upsert<T extends MedicamentUpsertArgs>(args: SelectSubset<T, MedicamentUpsertArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Medicaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentCountArgs} args - Arguments to filter Medicaments to count.
     * @example
     * // Count the number of Medicaments
     * const count = await prisma.medicament.count({
     *   where: {
     *     // ... the filter for the Medicaments we want to count
     *   }
     * })
    **/
    count<T extends MedicamentCountArgs>(
      args?: Subset<T, MedicamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicamentAggregateArgs>(args: Subset<T, MedicamentAggregateArgs>): Prisma.PrismaPromise<GetMedicamentAggregateType<T>>

    /**
     * Group by Medicament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicamentGroupByArgs['orderBy'] }
        : { orderBy?: MedicamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicament model
   */
  readonly fields: MedicamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stocks<T extends Medicament$stocksArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$stocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    mouvements<T extends Medicament$mouvementsArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$mouvementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    dispensations<T extends Medicament$dispensationsArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$dispensationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    commandes<T extends Medicament$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Medicament$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicament model
   */ 
  interface MedicamentFieldRefs {
    readonly id: FieldRef<"Medicament", 'String'>
    readonly codeANIS: FieldRef<"Medicament", 'String'>
    readonly dci: FieldRef<"Medicament", 'String'>
    readonly nomCommercial: FieldRef<"Medicament", 'String'>
    readonly forme: FieldRef<"Medicament", 'String'>
    readonly dosage: FieldRef<"Medicament", 'String'>
    readonly fabricant: FieldRef<"Medicament", 'String'>
    readonly prixAchat: FieldRef<"Medicament", 'Decimal'>
    readonly prixVente: FieldRef<"Medicament", 'Decimal'>
    readonly stockMinimum: FieldRef<"Medicament", 'Int'>
    readonly actif: FieldRef<"Medicament", 'Boolean'>
    readonly createdAt: FieldRef<"Medicament", 'DateTime'>
    readonly updatedAt: FieldRef<"Medicament", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicament findUnique
   */
  export type MedicamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament findUniqueOrThrow
   */
  export type MedicamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament findFirst
   */
  export type MedicamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicaments.
     */
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament findFirstOrThrow
   */
  export type MedicamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicament to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicaments.
     */
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament findMany
   */
  export type MedicamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter, which Medicaments to fetch.
     */
    where?: MedicamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicaments to fetch.
     */
    orderBy?: MedicamentOrderByWithRelationInput | MedicamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicaments.
     */
    cursor?: MedicamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicaments.
     */
    skip?: number
    distinct?: MedicamentScalarFieldEnum | MedicamentScalarFieldEnum[]
  }

  /**
   * Medicament create
   */
  export type MedicamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicament.
     */
    data: XOR<MedicamentCreateInput, MedicamentUncheckedCreateInput>
  }

  /**
   * Medicament createMany
   */
  export type MedicamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicaments.
     */
    data: MedicamentCreateManyInput | MedicamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicament createManyAndReturn
   */
  export type MedicamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * The data used to create many Medicaments.
     */
    data: MedicamentCreateManyInput | MedicamentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicament update
   */
  export type MedicamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicament.
     */
    data: XOR<MedicamentUpdateInput, MedicamentUncheckedUpdateInput>
    /**
     * Choose, which Medicament to update.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament updateMany
   */
  export type MedicamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicaments.
     */
    data: XOR<MedicamentUpdateManyMutationInput, MedicamentUncheckedUpdateManyInput>
    /**
     * Filter which Medicaments to update
     */
    where?: MedicamentWhereInput
  }

  /**
   * Medicament updateManyAndReturn
   */
  export type MedicamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * The data used to update Medicaments.
     */
    data: XOR<MedicamentUpdateManyMutationInput, MedicamentUncheckedUpdateManyInput>
    /**
     * Filter which Medicaments to update
     */
    where?: MedicamentWhereInput
  }

  /**
   * Medicament upsert
   */
  export type MedicamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicament to update in case it exists.
     */
    where: MedicamentWhereUniqueInput
    /**
     * In case the Medicament found by the `where` argument doesn't exist, create a new Medicament with this data.
     */
    create: XOR<MedicamentCreateInput, MedicamentUncheckedCreateInput>
    /**
     * In case the Medicament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicamentUpdateInput, MedicamentUncheckedUpdateInput>
  }

  /**
   * Medicament delete
   */
  export type MedicamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
    /**
     * Filter which Medicament to delete.
     */
    where: MedicamentWhereUniqueInput
  }

  /**
   * Medicament deleteMany
   */
  export type MedicamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicaments to delete
     */
    where?: MedicamentWhereInput
  }

  /**
   * Medicament.stocks
   */
  export type Medicament$stocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    where?: StockWhereInput
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    cursor?: StockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Medicament.mouvements
   */
  export type Medicament$mouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    where?: MouvementStockWhereInput
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    cursor?: MouvementStockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * Medicament.dispensations
   */
  export type Medicament$dispensationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    where?: DispensationWhereInput
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    cursor?: DispensationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DispensationScalarFieldEnum | DispensationScalarFieldEnum[]
  }

  /**
   * Medicament.commandes
   */
  export type Medicament$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    where?: LigneCommandePharmacieWhereInput
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    cursor?: LigneCommandePharmacieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneCommandePharmacieScalarFieldEnum | LigneCommandePharmacieScalarFieldEnum[]
  }

  /**
   * Medicament without action
   */
  export type MedicamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicament
     */
    select?: MedicamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicament
     */
    omit?: MedicamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicamentInclude<ExtArgs> | null
  }


  /**
   * Model Fournisseur
   */

  export type AggregateFournisseur = {
    _count: FournisseurCountAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  export type FournisseurMinAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    contact: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    ninea: string | null
    rccm: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    code: string | null
    contact: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    ninea: string | null
    rccm: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    contact: number
    email: number
    telephone: number
    adresse: number
    ninea: number
    rccm: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FournisseurMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    contact?: true
    email?: true
    telephone?: true
    adresse?: true
    ninea?: true
    rccm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    contact?: true
    email?: true
    telephone?: true
    adresse?: true
    ninea?: true
    rccm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    contact?: true
    email?: true
    telephone?: true
    adresse?: true
    ninea?: true
    rccm?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FournisseurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseur to aggregate.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fournisseurs
    **/
    _count?: true | FournisseurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FournisseurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FournisseurMaxAggregateInputType
  }

  export type GetFournisseurAggregateType<T extends FournisseurAggregateArgs> = {
        [P in keyof T & keyof AggregateFournisseur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFournisseur[P]>
      : GetScalarType<T[P], AggregateFournisseur[P]>
  }




  export type FournisseurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FournisseurWhereInput
    orderBy?: FournisseurOrderByWithAggregationInput | FournisseurOrderByWithAggregationInput[]
    by: FournisseurScalarFieldEnum[] | FournisseurScalarFieldEnum
    having?: FournisseurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FournisseurCountAggregateInputType | true
    _min?: FournisseurMinAggregateInputType
    _max?: FournisseurMaxAggregateInputType
  }

  export type FournisseurGroupByOutputType = {
    id: string
    nom: string
    code: string | null
    contact: string | null
    email: string | null
    telephone: string | null
    adresse: string | null
    ninea: string | null
    rccm: string | null
    createdAt: Date
    updatedAt: Date
    _count: FournisseurCountAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  type GetFournisseurGroupByPayload<T extends FournisseurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FournisseurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FournisseurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
            : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
        }
      >
    >


  export type FournisseurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    contact?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    ninea?: boolean
    rccm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commandes?: boolean | Fournisseur$commandesArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    contact?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    ninea?: boolean
    rccm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    contact?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    ninea?: boolean
    rccm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    contact?: boolean
    email?: boolean
    telephone?: boolean
    adresse?: boolean
    ninea?: boolean
    rccm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FournisseurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "code" | "contact" | "email" | "telephone" | "adresse" | "ninea" | "rccm" | "createdAt" | "updatedAt", ExtArgs["result"]["fournisseur"]>
  export type FournisseurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commandes?: boolean | Fournisseur$commandesArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FournisseurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FournisseurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FournisseurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fournisseur"
    objects: {
      commandes: Prisma.$CommandePharmaciePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      code: string | null
      contact: string | null
      email: string | null
      telephone: string | null
      adresse: string | null
      ninea: string | null
      rccm: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fournisseur"]>
    composites: {}
  }

  type FournisseurGetPayload<S extends boolean | null | undefined | FournisseurDefaultArgs> = $Result.GetResult<Prisma.$FournisseurPayload, S>

  type FournisseurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FournisseurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FournisseurCountAggregateInputType | true
    }

  export interface FournisseurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fournisseur'], meta: { name: 'Fournisseur' } }
    /**
     * Find zero or one Fournisseur that matches the filter.
     * @param {FournisseurFindUniqueArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FournisseurFindUniqueArgs>(args: SelectSubset<T, FournisseurFindUniqueArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Fournisseur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FournisseurFindUniqueOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FournisseurFindUniqueOrThrowArgs>(args: SelectSubset<T, FournisseurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Fournisseur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FournisseurFindFirstArgs>(args?: SelectSubset<T, FournisseurFindFirstArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Fournisseur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FournisseurFindFirstOrThrowArgs>(args?: SelectSubset<T, FournisseurFindFirstOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Fournisseurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany()
     * 
     * // Get first 10 Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FournisseurFindManyArgs>(args?: SelectSubset<T, FournisseurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Fournisseur.
     * @param {FournisseurCreateArgs} args - Arguments to create a Fournisseur.
     * @example
     * // Create one Fournisseur
     * const Fournisseur = await prisma.fournisseur.create({
     *   data: {
     *     // ... data to create a Fournisseur
     *   }
     * })
     * 
     */
    create<T extends FournisseurCreateArgs>(args: SelectSubset<T, FournisseurCreateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Fournisseurs.
     * @param {FournisseurCreateManyArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FournisseurCreateManyArgs>(args?: SelectSubset<T, FournisseurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fournisseurs and returns the data saved in the database.
     * @param {FournisseurCreateManyAndReturnArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FournisseurCreateManyAndReturnArgs>(args?: SelectSubset<T, FournisseurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Fournisseur.
     * @param {FournisseurDeleteArgs} args - Arguments to delete one Fournisseur.
     * @example
     * // Delete one Fournisseur
     * const Fournisseur = await prisma.fournisseur.delete({
     *   where: {
     *     // ... filter to delete one Fournisseur
     *   }
     * })
     * 
     */
    delete<T extends FournisseurDeleteArgs>(args: SelectSubset<T, FournisseurDeleteArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Fournisseur.
     * @param {FournisseurUpdateArgs} args - Arguments to update one Fournisseur.
     * @example
     * // Update one Fournisseur
     * const fournisseur = await prisma.fournisseur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FournisseurUpdateArgs>(args: SelectSubset<T, FournisseurUpdateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Fournisseurs.
     * @param {FournisseurDeleteManyArgs} args - Arguments to filter Fournisseurs to delete.
     * @example
     * // Delete a few Fournisseurs
     * const { count } = await prisma.fournisseur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FournisseurDeleteManyArgs>(args?: SelectSubset<T, FournisseurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FournisseurUpdateManyArgs>(args: SelectSubset<T, FournisseurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs and returns the data updated in the database.
     * @param {FournisseurUpdateManyAndReturnArgs} args - Arguments to update many Fournisseurs.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FournisseurUpdateManyAndReturnArgs>(args: SelectSubset<T, FournisseurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Fournisseur.
     * @param {FournisseurUpsertArgs} args - Arguments to update or create a Fournisseur.
     * @example
     * // Update or create a Fournisseur
     * const fournisseur = await prisma.fournisseur.upsert({
     *   create: {
     *     // ... data to create a Fournisseur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fournisseur we want to update
     *   }
     * })
     */
    upsert<T extends FournisseurUpsertArgs>(args: SelectSubset<T, FournisseurUpsertArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurCountArgs} args - Arguments to filter Fournisseurs to count.
     * @example
     * // Count the number of Fournisseurs
     * const count = await prisma.fournisseur.count({
     *   where: {
     *     // ... the filter for the Fournisseurs we want to count
     *   }
     * })
    **/
    count<T extends FournisseurCountArgs>(
      args?: Subset<T, FournisseurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FournisseurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FournisseurAggregateArgs>(args: Subset<T, FournisseurAggregateArgs>): Prisma.PrismaPromise<GetFournisseurAggregateType<T>>

    /**
     * Group by Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FournisseurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FournisseurGroupByArgs['orderBy'] }
        : { orderBy?: FournisseurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FournisseurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFournisseurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fournisseur model
   */
  readonly fields: FournisseurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fournisseur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FournisseurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commandes<T extends Fournisseur$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fournisseur model
   */ 
  interface FournisseurFieldRefs {
    readonly id: FieldRef<"Fournisseur", 'String'>
    readonly nom: FieldRef<"Fournisseur", 'String'>
    readonly code: FieldRef<"Fournisseur", 'String'>
    readonly contact: FieldRef<"Fournisseur", 'String'>
    readonly email: FieldRef<"Fournisseur", 'String'>
    readonly telephone: FieldRef<"Fournisseur", 'String'>
    readonly adresse: FieldRef<"Fournisseur", 'String'>
    readonly ninea: FieldRef<"Fournisseur", 'String'>
    readonly rccm: FieldRef<"Fournisseur", 'String'>
    readonly createdAt: FieldRef<"Fournisseur", 'DateTime'>
    readonly updatedAt: FieldRef<"Fournisseur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fournisseur findUnique
   */
  export type FournisseurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findUniqueOrThrow
   */
  export type FournisseurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findFirst
   */
  export type FournisseurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findFirstOrThrow
   */
  export type FournisseurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findMany
   */
  export type FournisseurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseurs to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur create
   */
  export type FournisseurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to create a Fournisseur.
     */
    data: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
  }

  /**
   * Fournisseur createMany
   */
  export type FournisseurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fournisseur createManyAndReturn
   */
  export type FournisseurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fournisseur update
   */
  export type FournisseurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to update a Fournisseur.
     */
    data: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
    /**
     * Choose, which Fournisseur to update.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur updateMany
   */
  export type FournisseurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
  }

  /**
   * Fournisseur updateManyAndReturn
   */
  export type FournisseurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
  }

  /**
   * Fournisseur upsert
   */
  export type FournisseurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The filter to search for the Fournisseur to update in case it exists.
     */
    where: FournisseurWhereUniqueInput
    /**
     * In case the Fournisseur found by the `where` argument doesn't exist, create a new Fournisseur with this data.
     */
    create: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
    /**
     * In case the Fournisseur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
  }

  /**
   * Fournisseur delete
   */
  export type FournisseurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter which Fournisseur to delete.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur deleteMany
   */
  export type FournisseurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseurs to delete
     */
    where?: FournisseurWhereInput
  }

  /**
   * Fournisseur.commandes
   */
  export type Fournisseur$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    where?: CommandePharmacieWhereInput
    orderBy?: CommandePharmacieOrderByWithRelationInput | CommandePharmacieOrderByWithRelationInput[]
    cursor?: CommandePharmacieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandePharmacieScalarFieldEnum | CommandePharmacieScalarFieldEnum[]
  }

  /**
   * Fournisseur without action
   */
  export type FournisseurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
  }


  /**
   * Model CommandePharmacie
   */

  export type AggregateCommandePharmacie = {
    _count: CommandePharmacieCountAggregateOutputType | null
    _avg: CommandePharmacieAvgAggregateOutputType | null
    _sum: CommandePharmacieSumAggregateOutputType | null
    _min: CommandePharmacieMinAggregateOutputType | null
    _max: CommandePharmacieMaxAggregateOutputType | null
  }

  export type CommandePharmacieAvgAggregateOutputType = {
    montantTotal: Decimal | null
  }

  export type CommandePharmacieSumAggregateOutputType = {
    montantTotal: Decimal | null
  }

  export type CommandePharmacieMinAggregateOutputType = {
    id: string | null
    numeroCommande: string | null
    fournisseurId: string | null
    dateCommande: Date | null
    dateLivraison: Date | null
    montantTotal: Decimal | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandePharmacieMaxAggregateOutputType = {
    id: string | null
    numeroCommande: string | null
    fournisseurId: string | null
    dateCommande: Date | null
    dateLivraison: Date | null
    montantTotal: Decimal | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandePharmacieCountAggregateOutputType = {
    id: number
    numeroCommande: number
    fournisseurId: number
    dateCommande: number
    dateLivraison: number
    montantTotal: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandePharmacieAvgAggregateInputType = {
    montantTotal?: true
  }

  export type CommandePharmacieSumAggregateInputType = {
    montantTotal?: true
  }

  export type CommandePharmacieMinAggregateInputType = {
    id?: true
    numeroCommande?: true
    fournisseurId?: true
    dateCommande?: true
    dateLivraison?: true
    montantTotal?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandePharmacieMaxAggregateInputType = {
    id?: true
    numeroCommande?: true
    fournisseurId?: true
    dateCommande?: true
    dateLivraison?: true
    montantTotal?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandePharmacieCountAggregateInputType = {
    id?: true
    numeroCommande?: true
    fournisseurId?: true
    dateCommande?: true
    dateLivraison?: true
    montantTotal?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandePharmacieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandePharmacie to aggregate.
     */
    where?: CommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandePharmacies to fetch.
     */
    orderBy?: CommandePharmacieOrderByWithRelationInput | CommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommandePharmacies
    **/
    _count?: true | CommandePharmacieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandePharmacieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandePharmacieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandePharmacieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandePharmacieMaxAggregateInputType
  }

  export type GetCommandePharmacieAggregateType<T extends CommandePharmacieAggregateArgs> = {
        [P in keyof T & keyof AggregateCommandePharmacie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommandePharmacie[P]>
      : GetScalarType<T[P], AggregateCommandePharmacie[P]>
  }




  export type CommandePharmacieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandePharmacieWhereInput
    orderBy?: CommandePharmacieOrderByWithAggregationInput | CommandePharmacieOrderByWithAggregationInput[]
    by: CommandePharmacieScalarFieldEnum[] | CommandePharmacieScalarFieldEnum
    having?: CommandePharmacieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandePharmacieCountAggregateInputType | true
    _avg?: CommandePharmacieAvgAggregateInputType
    _sum?: CommandePharmacieSumAggregateInputType
    _min?: CommandePharmacieMinAggregateInputType
    _max?: CommandePharmacieMaxAggregateInputType
  }

  export type CommandePharmacieGroupByOutputType = {
    id: string
    numeroCommande: string
    fournisseurId: string
    dateCommande: Date
    dateLivraison: Date | null
    montantTotal: Decimal
    statut: string
    createdAt: Date
    updatedAt: Date
    _count: CommandePharmacieCountAggregateOutputType | null
    _avg: CommandePharmacieAvgAggregateOutputType | null
    _sum: CommandePharmacieSumAggregateOutputType | null
    _min: CommandePharmacieMinAggregateOutputType | null
    _max: CommandePharmacieMaxAggregateOutputType | null
  }

  type GetCommandePharmacieGroupByPayload<T extends CommandePharmacieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandePharmacieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandePharmacieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandePharmacieGroupByOutputType[P]>
            : GetScalarType<T[P], CommandePharmacieGroupByOutputType[P]>
        }
      >
    >


  export type CommandePharmacieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroCommande?: boolean
    fournisseurId?: boolean
    dateCommande?: boolean
    dateLivraison?: boolean
    montantTotal?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    lignes?: boolean | CommandePharmacie$lignesArgs<ExtArgs>
    _count?: boolean | CommandePharmacieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandePharmacie"]>

  export type CommandePharmacieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroCommande?: boolean
    fournisseurId?: boolean
    dateCommande?: boolean
    dateLivraison?: boolean
    montantTotal?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandePharmacie"]>

  export type CommandePharmacieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroCommande?: boolean
    fournisseurId?: boolean
    dateCommande?: boolean
    dateLivraison?: boolean
    montantTotal?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commandePharmacie"]>

  export type CommandePharmacieSelectScalar = {
    id?: boolean
    numeroCommande?: boolean
    fournisseurId?: boolean
    dateCommande?: boolean
    dateLivraison?: boolean
    montantTotal?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandePharmacieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroCommande" | "fournisseurId" | "dateCommande" | "dateLivraison" | "montantTotal" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["commandePharmacie"]>
  export type CommandePharmacieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    lignes?: boolean | CommandePharmacie$lignesArgs<ExtArgs>
    _count?: boolean | CommandePharmacieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandePharmacieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
  }
  export type CommandePharmacieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
  }

  export type $CommandePharmaciePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommandePharmacie"
    objects: {
      fournisseur: Prisma.$FournisseurPayload<ExtArgs>
      lignes: Prisma.$LigneCommandePharmaciePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroCommande: string
      fournisseurId: string
      dateCommande: Date
      dateLivraison: Date | null
      montantTotal: Prisma.Decimal
      statut: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commandePharmacie"]>
    composites: {}
  }

  type CommandePharmacieGetPayload<S extends boolean | null | undefined | CommandePharmacieDefaultArgs> = $Result.GetResult<Prisma.$CommandePharmaciePayload, S>

  type CommandePharmacieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandePharmacieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandePharmacieCountAggregateInputType | true
    }

  export interface CommandePharmacieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommandePharmacie'], meta: { name: 'CommandePharmacie' } }
    /**
     * Find zero or one CommandePharmacie that matches the filter.
     * @param {CommandePharmacieFindUniqueArgs} args - Arguments to find a CommandePharmacie
     * @example
     * // Get one CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandePharmacieFindUniqueArgs>(args: SelectSubset<T, CommandePharmacieFindUniqueArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one CommandePharmacie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandePharmacieFindUniqueOrThrowArgs} args - Arguments to find a CommandePharmacie
     * @example
     * // Get one CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandePharmacieFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandePharmacieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first CommandePharmacie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieFindFirstArgs} args - Arguments to find a CommandePharmacie
     * @example
     * // Get one CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandePharmacieFindFirstArgs>(args?: SelectSubset<T, CommandePharmacieFindFirstArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first CommandePharmacie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieFindFirstOrThrowArgs} args - Arguments to find a CommandePharmacie
     * @example
     * // Get one CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandePharmacieFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandePharmacieFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more CommandePharmacies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommandePharmacies
     * const commandePharmacies = await prisma.commandePharmacie.findMany()
     * 
     * // Get first 10 CommandePharmacies
     * const commandePharmacies = await prisma.commandePharmacie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandePharmacieWithIdOnly = await prisma.commandePharmacie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandePharmacieFindManyArgs>(args?: SelectSubset<T, CommandePharmacieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a CommandePharmacie.
     * @param {CommandePharmacieCreateArgs} args - Arguments to create a CommandePharmacie.
     * @example
     * // Create one CommandePharmacie
     * const CommandePharmacie = await prisma.commandePharmacie.create({
     *   data: {
     *     // ... data to create a CommandePharmacie
     *   }
     * })
     * 
     */
    create<T extends CommandePharmacieCreateArgs>(args: SelectSubset<T, CommandePharmacieCreateArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many CommandePharmacies.
     * @param {CommandePharmacieCreateManyArgs} args - Arguments to create many CommandePharmacies.
     * @example
     * // Create many CommandePharmacies
     * const commandePharmacie = await prisma.commandePharmacie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandePharmacieCreateManyArgs>(args?: SelectSubset<T, CommandePharmacieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommandePharmacies and returns the data saved in the database.
     * @param {CommandePharmacieCreateManyAndReturnArgs} args - Arguments to create many CommandePharmacies.
     * @example
     * // Create many CommandePharmacies
     * const commandePharmacie = await prisma.commandePharmacie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommandePharmacies and only return the `id`
     * const commandePharmacieWithIdOnly = await prisma.commandePharmacie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandePharmacieCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandePharmacieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a CommandePharmacie.
     * @param {CommandePharmacieDeleteArgs} args - Arguments to delete one CommandePharmacie.
     * @example
     * // Delete one CommandePharmacie
     * const CommandePharmacie = await prisma.commandePharmacie.delete({
     *   where: {
     *     // ... filter to delete one CommandePharmacie
     *   }
     * })
     * 
     */
    delete<T extends CommandePharmacieDeleteArgs>(args: SelectSubset<T, CommandePharmacieDeleteArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one CommandePharmacie.
     * @param {CommandePharmacieUpdateArgs} args - Arguments to update one CommandePharmacie.
     * @example
     * // Update one CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandePharmacieUpdateArgs>(args: SelectSubset<T, CommandePharmacieUpdateArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more CommandePharmacies.
     * @param {CommandePharmacieDeleteManyArgs} args - Arguments to filter CommandePharmacies to delete.
     * @example
     * // Delete a few CommandePharmacies
     * const { count } = await prisma.commandePharmacie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandePharmacieDeleteManyArgs>(args?: SelectSubset<T, CommandePharmacieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandePharmacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommandePharmacies
     * const commandePharmacie = await prisma.commandePharmacie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandePharmacieUpdateManyArgs>(args: SelectSubset<T, CommandePharmacieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommandePharmacies and returns the data updated in the database.
     * @param {CommandePharmacieUpdateManyAndReturnArgs} args - Arguments to update many CommandePharmacies.
     * @example
     * // Update many CommandePharmacies
     * const commandePharmacie = await prisma.commandePharmacie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommandePharmacies and only return the `id`
     * const commandePharmacieWithIdOnly = await prisma.commandePharmacie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommandePharmacieUpdateManyAndReturnArgs>(args: SelectSubset<T, CommandePharmacieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one CommandePharmacie.
     * @param {CommandePharmacieUpsertArgs} args - Arguments to update or create a CommandePharmacie.
     * @example
     * // Update or create a CommandePharmacie
     * const commandePharmacie = await prisma.commandePharmacie.upsert({
     *   create: {
     *     // ... data to create a CommandePharmacie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommandePharmacie we want to update
     *   }
     * })
     */
    upsert<T extends CommandePharmacieUpsertArgs>(args: SelectSubset<T, CommandePharmacieUpsertArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of CommandePharmacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieCountArgs} args - Arguments to filter CommandePharmacies to count.
     * @example
     * // Count the number of CommandePharmacies
     * const count = await prisma.commandePharmacie.count({
     *   where: {
     *     // ... the filter for the CommandePharmacies we want to count
     *   }
     * })
    **/
    count<T extends CommandePharmacieCountArgs>(
      args?: Subset<T, CommandePharmacieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandePharmacieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommandePharmacie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandePharmacieAggregateArgs>(args: Subset<T, CommandePharmacieAggregateArgs>): Prisma.PrismaPromise<GetCommandePharmacieAggregateType<T>>

    /**
     * Group by CommandePharmacie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandePharmacieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandePharmacieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandePharmacieGroupByArgs['orderBy'] }
        : { orderBy?: CommandePharmacieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandePharmacieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandePharmacieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommandePharmacie model
   */
  readonly fields: CommandePharmacieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommandePharmacie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandePharmacieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fournisseur<T extends FournisseurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FournisseurDefaultArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    lignes<T extends CommandePharmacie$lignesArgs<ExtArgs> = {}>(args?: Subset<T, CommandePharmacie$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommandePharmacie model
   */ 
  interface CommandePharmacieFieldRefs {
    readonly id: FieldRef<"CommandePharmacie", 'String'>
    readonly numeroCommande: FieldRef<"CommandePharmacie", 'String'>
    readonly fournisseurId: FieldRef<"CommandePharmacie", 'String'>
    readonly dateCommande: FieldRef<"CommandePharmacie", 'DateTime'>
    readonly dateLivraison: FieldRef<"CommandePharmacie", 'DateTime'>
    readonly montantTotal: FieldRef<"CommandePharmacie", 'Decimal'>
    readonly statut: FieldRef<"CommandePharmacie", 'String'>
    readonly createdAt: FieldRef<"CommandePharmacie", 'DateTime'>
    readonly updatedAt: FieldRef<"CommandePharmacie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommandePharmacie findUnique
   */
  export type CommandePharmacieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which CommandePharmacie to fetch.
     */
    where: CommandePharmacieWhereUniqueInput
  }

  /**
   * CommandePharmacie findUniqueOrThrow
   */
  export type CommandePharmacieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which CommandePharmacie to fetch.
     */
    where: CommandePharmacieWhereUniqueInput
  }

  /**
   * CommandePharmacie findFirst
   */
  export type CommandePharmacieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which CommandePharmacie to fetch.
     */
    where?: CommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandePharmacies to fetch.
     */
    orderBy?: CommandePharmacieOrderByWithRelationInput | CommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandePharmacies.
     */
    cursor?: CommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandePharmacies.
     */
    distinct?: CommandePharmacieScalarFieldEnum | CommandePharmacieScalarFieldEnum[]
  }

  /**
   * CommandePharmacie findFirstOrThrow
   */
  export type CommandePharmacieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which CommandePharmacie to fetch.
     */
    where?: CommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandePharmacies to fetch.
     */
    orderBy?: CommandePharmacieOrderByWithRelationInput | CommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommandePharmacies.
     */
    cursor?: CommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommandePharmacies.
     */
    distinct?: CommandePharmacieScalarFieldEnum | CommandePharmacieScalarFieldEnum[]
  }

  /**
   * CommandePharmacie findMany
   */
  export type CommandePharmacieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which CommandePharmacies to fetch.
     */
    where?: CommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommandePharmacies to fetch.
     */
    orderBy?: CommandePharmacieOrderByWithRelationInput | CommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommandePharmacies.
     */
    cursor?: CommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommandePharmacies.
     */
    skip?: number
    distinct?: CommandePharmacieScalarFieldEnum | CommandePharmacieScalarFieldEnum[]
  }

  /**
   * CommandePharmacie create
   */
  export type CommandePharmacieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * The data needed to create a CommandePharmacie.
     */
    data: XOR<CommandePharmacieCreateInput, CommandePharmacieUncheckedCreateInput>
  }

  /**
   * CommandePharmacie createMany
   */
  export type CommandePharmacieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommandePharmacies.
     */
    data: CommandePharmacieCreateManyInput | CommandePharmacieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommandePharmacie createManyAndReturn
   */
  export type CommandePharmacieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * The data used to create many CommandePharmacies.
     */
    data: CommandePharmacieCreateManyInput | CommandePharmacieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommandePharmacie update
   */
  export type CommandePharmacieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * The data needed to update a CommandePharmacie.
     */
    data: XOR<CommandePharmacieUpdateInput, CommandePharmacieUncheckedUpdateInput>
    /**
     * Choose, which CommandePharmacie to update.
     */
    where: CommandePharmacieWhereUniqueInput
  }

  /**
   * CommandePharmacie updateMany
   */
  export type CommandePharmacieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommandePharmacies.
     */
    data: XOR<CommandePharmacieUpdateManyMutationInput, CommandePharmacieUncheckedUpdateManyInput>
    /**
     * Filter which CommandePharmacies to update
     */
    where?: CommandePharmacieWhereInput
  }

  /**
   * CommandePharmacie updateManyAndReturn
   */
  export type CommandePharmacieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * The data used to update CommandePharmacies.
     */
    data: XOR<CommandePharmacieUpdateManyMutationInput, CommandePharmacieUncheckedUpdateManyInput>
    /**
     * Filter which CommandePharmacies to update
     */
    where?: CommandePharmacieWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommandePharmacie upsert
   */
  export type CommandePharmacieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * The filter to search for the CommandePharmacie to update in case it exists.
     */
    where: CommandePharmacieWhereUniqueInput
    /**
     * In case the CommandePharmacie found by the `where` argument doesn't exist, create a new CommandePharmacie with this data.
     */
    create: XOR<CommandePharmacieCreateInput, CommandePharmacieUncheckedCreateInput>
    /**
     * In case the CommandePharmacie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandePharmacieUpdateInput, CommandePharmacieUncheckedUpdateInput>
  }

  /**
   * CommandePharmacie delete
   */
  export type CommandePharmacieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter which CommandePharmacie to delete.
     */
    where: CommandePharmacieWhereUniqueInput
  }

  /**
   * CommandePharmacie deleteMany
   */
  export type CommandePharmacieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommandePharmacies to delete
     */
    where?: CommandePharmacieWhereInput
  }

  /**
   * CommandePharmacie.lignes
   */
  export type CommandePharmacie$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    where?: LigneCommandePharmacieWhereInput
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    cursor?: LigneCommandePharmacieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneCommandePharmacieScalarFieldEnum | LigneCommandePharmacieScalarFieldEnum[]
  }

  /**
   * CommandePharmacie without action
   */
  export type CommandePharmacieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandePharmacie
     */
    select?: CommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommandePharmacie
     */
    omit?: CommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandePharmacieInclude<ExtArgs> | null
  }


  /**
   * Model LigneCommandePharmacie
   */

  export type AggregateLigneCommandePharmacie = {
    _count: LigneCommandePharmacieCountAggregateOutputType | null
    _avg: LigneCommandePharmacieAvgAggregateOutputType | null
    _sum: LigneCommandePharmacieSumAggregateOutputType | null
    _min: LigneCommandePharmacieMinAggregateOutputType | null
    _max: LigneCommandePharmacieMaxAggregateOutputType | null
  }

  export type LigneCommandePharmacieAvgAggregateOutputType = {
    quantiteCommandee: number | null
    quantiteRecue: number | null
    prixUnitaire: Decimal | null
  }

  export type LigneCommandePharmacieSumAggregateOutputType = {
    quantiteCommandee: number | null
    quantiteRecue: number | null
    prixUnitaire: Decimal | null
  }

  export type LigneCommandePharmacieMinAggregateOutputType = {
    id: string | null
    commandeId: string | null
    medicamentId: string | null
    quantiteCommandee: number | null
    quantiteRecue: number | null
    prixUnitaire: Decimal | null
    createdAt: Date | null
  }

  export type LigneCommandePharmacieMaxAggregateOutputType = {
    id: string | null
    commandeId: string | null
    medicamentId: string | null
    quantiteCommandee: number | null
    quantiteRecue: number | null
    prixUnitaire: Decimal | null
    createdAt: Date | null
  }

  export type LigneCommandePharmacieCountAggregateOutputType = {
    id: number
    commandeId: number
    medicamentId: number
    quantiteCommandee: number
    quantiteRecue: number
    prixUnitaire: number
    createdAt: number
    _all: number
  }


  export type LigneCommandePharmacieAvgAggregateInputType = {
    quantiteCommandee?: true
    quantiteRecue?: true
    prixUnitaire?: true
  }

  export type LigneCommandePharmacieSumAggregateInputType = {
    quantiteCommandee?: true
    quantiteRecue?: true
    prixUnitaire?: true
  }

  export type LigneCommandePharmacieMinAggregateInputType = {
    id?: true
    commandeId?: true
    medicamentId?: true
    quantiteCommandee?: true
    quantiteRecue?: true
    prixUnitaire?: true
    createdAt?: true
  }

  export type LigneCommandePharmacieMaxAggregateInputType = {
    id?: true
    commandeId?: true
    medicamentId?: true
    quantiteCommandee?: true
    quantiteRecue?: true
    prixUnitaire?: true
    createdAt?: true
  }

  export type LigneCommandePharmacieCountAggregateInputType = {
    id?: true
    commandeId?: true
    medicamentId?: true
    quantiteCommandee?: true
    quantiteRecue?: true
    prixUnitaire?: true
    createdAt?: true
    _all?: true
  }

  export type LigneCommandePharmacieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommandePharmacie to aggregate.
     */
    where?: LigneCommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandePharmacies to fetch.
     */
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneCommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneCommandePharmacies
    **/
    _count?: true | LigneCommandePharmacieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneCommandePharmacieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneCommandePharmacieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneCommandePharmacieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneCommandePharmacieMaxAggregateInputType
  }

  export type GetLigneCommandePharmacieAggregateType<T extends LigneCommandePharmacieAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneCommandePharmacie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneCommandePharmacie[P]>
      : GetScalarType<T[P], AggregateLigneCommandePharmacie[P]>
  }




  export type LigneCommandePharmacieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneCommandePharmacieWhereInput
    orderBy?: LigneCommandePharmacieOrderByWithAggregationInput | LigneCommandePharmacieOrderByWithAggregationInput[]
    by: LigneCommandePharmacieScalarFieldEnum[] | LigneCommandePharmacieScalarFieldEnum
    having?: LigneCommandePharmacieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneCommandePharmacieCountAggregateInputType | true
    _avg?: LigneCommandePharmacieAvgAggregateInputType
    _sum?: LigneCommandePharmacieSumAggregateInputType
    _min?: LigneCommandePharmacieMinAggregateInputType
    _max?: LigneCommandePharmacieMaxAggregateInputType
  }

  export type LigneCommandePharmacieGroupByOutputType = {
    id: string
    commandeId: string
    medicamentId: string
    quantiteCommandee: number
    quantiteRecue: number
    prixUnitaire: Decimal
    createdAt: Date
    _count: LigneCommandePharmacieCountAggregateOutputType | null
    _avg: LigneCommandePharmacieAvgAggregateOutputType | null
    _sum: LigneCommandePharmacieSumAggregateOutputType | null
    _min: LigneCommandePharmacieMinAggregateOutputType | null
    _max: LigneCommandePharmacieMaxAggregateOutputType | null
  }

  type GetLigneCommandePharmacieGroupByPayload<T extends LigneCommandePharmacieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneCommandePharmacieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneCommandePharmacieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneCommandePharmacieGroupByOutputType[P]>
            : GetScalarType<T[P], LigneCommandePharmacieGroupByOutputType[P]>
        }
      >
    >


  export type LigneCommandePharmacieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandeId?: boolean
    medicamentId?: boolean
    quantiteCommandee?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    createdAt?: boolean
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCommandePharmacie"]>

  export type LigneCommandePharmacieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandeId?: boolean
    medicamentId?: boolean
    quantiteCommandee?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    createdAt?: boolean
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCommandePharmacie"]>

  export type LigneCommandePharmacieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commandeId?: boolean
    medicamentId?: boolean
    quantiteCommandee?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    createdAt?: boolean
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneCommandePharmacie"]>

  export type LigneCommandePharmacieSelectScalar = {
    id?: boolean
    commandeId?: boolean
    medicamentId?: boolean
    quantiteCommandee?: boolean
    quantiteRecue?: boolean
    prixUnitaire?: boolean
    createdAt?: boolean
  }

  export type LigneCommandePharmacieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commandeId" | "medicamentId" | "quantiteCommandee" | "quantiteRecue" | "prixUnitaire" | "createdAt", ExtArgs["result"]["ligneCommandePharmacie"]>
  export type LigneCommandePharmacieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type LigneCommandePharmacieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type LigneCommandePharmacieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commande?: boolean | CommandePharmacieDefaultArgs<ExtArgs>
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }

  export type $LigneCommandePharmaciePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneCommandePharmacie"
    objects: {
      commande: Prisma.$CommandePharmaciePayload<ExtArgs>
      medicament: Prisma.$MedicamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commandeId: string
      medicamentId: string
      quantiteCommandee: number
      quantiteRecue: number
      prixUnitaire: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["ligneCommandePharmacie"]>
    composites: {}
  }

  type LigneCommandePharmacieGetPayload<S extends boolean | null | undefined | LigneCommandePharmacieDefaultArgs> = $Result.GetResult<Prisma.$LigneCommandePharmaciePayload, S>

  type LigneCommandePharmacieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneCommandePharmacieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneCommandePharmacieCountAggregateInputType | true
    }

  export interface LigneCommandePharmacieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneCommandePharmacie'], meta: { name: 'LigneCommandePharmacie' } }
    /**
     * Find zero or one LigneCommandePharmacie that matches the filter.
     * @param {LigneCommandePharmacieFindUniqueArgs} args - Arguments to find a LigneCommandePharmacie
     * @example
     * // Get one LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneCommandePharmacieFindUniqueArgs>(args: SelectSubset<T, LigneCommandePharmacieFindUniqueArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LigneCommandePharmacie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneCommandePharmacieFindUniqueOrThrowArgs} args - Arguments to find a LigneCommandePharmacie
     * @example
     * // Get one LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneCommandePharmacieFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneCommandePharmacieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LigneCommandePharmacie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieFindFirstArgs} args - Arguments to find a LigneCommandePharmacie
     * @example
     * // Get one LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneCommandePharmacieFindFirstArgs>(args?: SelectSubset<T, LigneCommandePharmacieFindFirstArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LigneCommandePharmacie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieFindFirstOrThrowArgs} args - Arguments to find a LigneCommandePharmacie
     * @example
     * // Get one LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneCommandePharmacieFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneCommandePharmacieFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LigneCommandePharmacies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneCommandePharmacies
     * const ligneCommandePharmacies = await prisma.ligneCommandePharmacie.findMany()
     * 
     * // Get first 10 LigneCommandePharmacies
     * const ligneCommandePharmacies = await prisma.ligneCommandePharmacie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneCommandePharmacieWithIdOnly = await prisma.ligneCommandePharmacie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneCommandePharmacieFindManyArgs>(args?: SelectSubset<T, LigneCommandePharmacieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LigneCommandePharmacie.
     * @param {LigneCommandePharmacieCreateArgs} args - Arguments to create a LigneCommandePharmacie.
     * @example
     * // Create one LigneCommandePharmacie
     * const LigneCommandePharmacie = await prisma.ligneCommandePharmacie.create({
     *   data: {
     *     // ... data to create a LigneCommandePharmacie
     *   }
     * })
     * 
     */
    create<T extends LigneCommandePharmacieCreateArgs>(args: SelectSubset<T, LigneCommandePharmacieCreateArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LigneCommandePharmacies.
     * @param {LigneCommandePharmacieCreateManyArgs} args - Arguments to create many LigneCommandePharmacies.
     * @example
     * // Create many LigneCommandePharmacies
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneCommandePharmacieCreateManyArgs>(args?: SelectSubset<T, LigneCommandePharmacieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LigneCommandePharmacies and returns the data saved in the database.
     * @param {LigneCommandePharmacieCreateManyAndReturnArgs} args - Arguments to create many LigneCommandePharmacies.
     * @example
     * // Create many LigneCommandePharmacies
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LigneCommandePharmacies and only return the `id`
     * const ligneCommandePharmacieWithIdOnly = await prisma.ligneCommandePharmacie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneCommandePharmacieCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneCommandePharmacieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LigneCommandePharmacie.
     * @param {LigneCommandePharmacieDeleteArgs} args - Arguments to delete one LigneCommandePharmacie.
     * @example
     * // Delete one LigneCommandePharmacie
     * const LigneCommandePharmacie = await prisma.ligneCommandePharmacie.delete({
     *   where: {
     *     // ... filter to delete one LigneCommandePharmacie
     *   }
     * })
     * 
     */
    delete<T extends LigneCommandePharmacieDeleteArgs>(args: SelectSubset<T, LigneCommandePharmacieDeleteArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LigneCommandePharmacie.
     * @param {LigneCommandePharmacieUpdateArgs} args - Arguments to update one LigneCommandePharmacie.
     * @example
     * // Update one LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneCommandePharmacieUpdateArgs>(args: SelectSubset<T, LigneCommandePharmacieUpdateArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LigneCommandePharmacies.
     * @param {LigneCommandePharmacieDeleteManyArgs} args - Arguments to filter LigneCommandePharmacies to delete.
     * @example
     * // Delete a few LigneCommandePharmacies
     * const { count } = await prisma.ligneCommandePharmacie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneCommandePharmacieDeleteManyArgs>(args?: SelectSubset<T, LigneCommandePharmacieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneCommandePharmacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneCommandePharmacies
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneCommandePharmacieUpdateManyArgs>(args: SelectSubset<T, LigneCommandePharmacieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneCommandePharmacies and returns the data updated in the database.
     * @param {LigneCommandePharmacieUpdateManyAndReturnArgs} args - Arguments to update many LigneCommandePharmacies.
     * @example
     * // Update many LigneCommandePharmacies
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LigneCommandePharmacies and only return the `id`
     * const ligneCommandePharmacieWithIdOnly = await prisma.ligneCommandePharmacie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LigneCommandePharmacieUpdateManyAndReturnArgs>(args: SelectSubset<T, LigneCommandePharmacieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LigneCommandePharmacie.
     * @param {LigneCommandePharmacieUpsertArgs} args - Arguments to update or create a LigneCommandePharmacie.
     * @example
     * // Update or create a LigneCommandePharmacie
     * const ligneCommandePharmacie = await prisma.ligneCommandePharmacie.upsert({
     *   create: {
     *     // ... data to create a LigneCommandePharmacie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneCommandePharmacie we want to update
     *   }
     * })
     */
    upsert<T extends LigneCommandePharmacieUpsertArgs>(args: SelectSubset<T, LigneCommandePharmacieUpsertArgs<ExtArgs>>): Prisma__LigneCommandePharmacieClient<$Result.GetResult<Prisma.$LigneCommandePharmaciePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LigneCommandePharmacies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieCountArgs} args - Arguments to filter LigneCommandePharmacies to count.
     * @example
     * // Count the number of LigneCommandePharmacies
     * const count = await prisma.ligneCommandePharmacie.count({
     *   where: {
     *     // ... the filter for the LigneCommandePharmacies we want to count
     *   }
     * })
    **/
    count<T extends LigneCommandePharmacieCountArgs>(
      args?: Subset<T, LigneCommandePharmacieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneCommandePharmacieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneCommandePharmacie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneCommandePharmacieAggregateArgs>(args: Subset<T, LigneCommandePharmacieAggregateArgs>): Prisma.PrismaPromise<GetLigneCommandePharmacieAggregateType<T>>

    /**
     * Group by LigneCommandePharmacie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneCommandePharmacieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneCommandePharmacieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneCommandePharmacieGroupByArgs['orderBy'] }
        : { orderBy?: LigneCommandePharmacieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneCommandePharmacieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneCommandePharmacieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneCommandePharmacie model
   */
  readonly fields: LigneCommandePharmacieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneCommandePharmacie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneCommandePharmacieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commande<T extends CommandePharmacieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommandePharmacieDefaultArgs<ExtArgs>>): Prisma__CommandePharmacieClient<$Result.GetResult<Prisma.$CommandePharmaciePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneCommandePharmacie model
   */ 
  interface LigneCommandePharmacieFieldRefs {
    readonly id: FieldRef<"LigneCommandePharmacie", 'String'>
    readonly commandeId: FieldRef<"LigneCommandePharmacie", 'String'>
    readonly medicamentId: FieldRef<"LigneCommandePharmacie", 'String'>
    readonly quantiteCommandee: FieldRef<"LigneCommandePharmacie", 'Int'>
    readonly quantiteRecue: FieldRef<"LigneCommandePharmacie", 'Int'>
    readonly prixUnitaire: FieldRef<"LigneCommandePharmacie", 'Decimal'>
    readonly createdAt: FieldRef<"LigneCommandePharmacie", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneCommandePharmacie findUnique
   */
  export type LigneCommandePharmacieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandePharmacie to fetch.
     */
    where: LigneCommandePharmacieWhereUniqueInput
  }

  /**
   * LigneCommandePharmacie findUniqueOrThrow
   */
  export type LigneCommandePharmacieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandePharmacie to fetch.
     */
    where: LigneCommandePharmacieWhereUniqueInput
  }

  /**
   * LigneCommandePharmacie findFirst
   */
  export type LigneCommandePharmacieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandePharmacie to fetch.
     */
    where?: LigneCommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandePharmacies to fetch.
     */
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandePharmacies.
     */
    cursor?: LigneCommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandePharmacies.
     */
    distinct?: LigneCommandePharmacieScalarFieldEnum | LigneCommandePharmacieScalarFieldEnum[]
  }

  /**
   * LigneCommandePharmacie findFirstOrThrow
   */
  export type LigneCommandePharmacieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandePharmacie to fetch.
     */
    where?: LigneCommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandePharmacies to fetch.
     */
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneCommandePharmacies.
     */
    cursor?: LigneCommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandePharmacies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneCommandePharmacies.
     */
    distinct?: LigneCommandePharmacieScalarFieldEnum | LigneCommandePharmacieScalarFieldEnum[]
  }

  /**
   * LigneCommandePharmacie findMany
   */
  export type LigneCommandePharmacieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter, which LigneCommandePharmacies to fetch.
     */
    where?: LigneCommandePharmacieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneCommandePharmacies to fetch.
     */
    orderBy?: LigneCommandePharmacieOrderByWithRelationInput | LigneCommandePharmacieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneCommandePharmacies.
     */
    cursor?: LigneCommandePharmacieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneCommandePharmacies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneCommandePharmacies.
     */
    skip?: number
    distinct?: LigneCommandePharmacieScalarFieldEnum | LigneCommandePharmacieScalarFieldEnum[]
  }

  /**
   * LigneCommandePharmacie create
   */
  export type LigneCommandePharmacieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneCommandePharmacie.
     */
    data: XOR<LigneCommandePharmacieCreateInput, LigneCommandePharmacieUncheckedCreateInput>
  }

  /**
   * LigneCommandePharmacie createMany
   */
  export type LigneCommandePharmacieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneCommandePharmacies.
     */
    data: LigneCommandePharmacieCreateManyInput | LigneCommandePharmacieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneCommandePharmacie createManyAndReturn
   */
  export type LigneCommandePharmacieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * The data used to create many LigneCommandePharmacies.
     */
    data: LigneCommandePharmacieCreateManyInput | LigneCommandePharmacieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneCommandePharmacie update
   */
  export type LigneCommandePharmacieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneCommandePharmacie.
     */
    data: XOR<LigneCommandePharmacieUpdateInput, LigneCommandePharmacieUncheckedUpdateInput>
    /**
     * Choose, which LigneCommandePharmacie to update.
     */
    where: LigneCommandePharmacieWhereUniqueInput
  }

  /**
   * LigneCommandePharmacie updateMany
   */
  export type LigneCommandePharmacieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneCommandePharmacies.
     */
    data: XOR<LigneCommandePharmacieUpdateManyMutationInput, LigneCommandePharmacieUncheckedUpdateManyInput>
    /**
     * Filter which LigneCommandePharmacies to update
     */
    where?: LigneCommandePharmacieWhereInput
  }

  /**
   * LigneCommandePharmacie updateManyAndReturn
   */
  export type LigneCommandePharmacieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * The data used to update LigneCommandePharmacies.
     */
    data: XOR<LigneCommandePharmacieUpdateManyMutationInput, LigneCommandePharmacieUncheckedUpdateManyInput>
    /**
     * Filter which LigneCommandePharmacies to update
     */
    where?: LigneCommandePharmacieWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneCommandePharmacie upsert
   */
  export type LigneCommandePharmacieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneCommandePharmacie to update in case it exists.
     */
    where: LigneCommandePharmacieWhereUniqueInput
    /**
     * In case the LigneCommandePharmacie found by the `where` argument doesn't exist, create a new LigneCommandePharmacie with this data.
     */
    create: XOR<LigneCommandePharmacieCreateInput, LigneCommandePharmacieUncheckedCreateInput>
    /**
     * In case the LigneCommandePharmacie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneCommandePharmacieUpdateInput, LigneCommandePharmacieUncheckedUpdateInput>
  }

  /**
   * LigneCommandePharmacie delete
   */
  export type LigneCommandePharmacieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
    /**
     * Filter which LigneCommandePharmacie to delete.
     */
    where: LigneCommandePharmacieWhereUniqueInput
  }

  /**
   * LigneCommandePharmacie deleteMany
   */
  export type LigneCommandePharmacieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneCommandePharmacies to delete
     */
    where?: LigneCommandePharmacieWhereInput
  }

  /**
   * LigneCommandePharmacie without action
   */
  export type LigneCommandePharmacieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneCommandePharmacie
     */
    select?: LigneCommandePharmacieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneCommandePharmacie
     */
    omit?: LigneCommandePharmacieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneCommandePharmacieInclude<ExtArgs> | null
  }


  /**
   * Model Stock
   */

  export type AggregateStock = {
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  export type StockAvgAggregateOutputType = {
    quantite: number | null
  }

  export type StockSumAggregateOutputType = {
    quantite: number | null
  }

  export type StockMinAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    lot: string | null
    datePeremption: Date | null
    quantite: number | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockMaxAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    lot: string | null
    datePeremption: Date | null
    quantite: number | null
    emplacement: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockCountAggregateOutputType = {
    id: number
    medicamentId: number
    lot: number
    datePeremption: number
    quantite: number
    emplacement: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockAvgAggregateInputType = {
    quantite?: true
  }

  export type StockSumAggregateInputType = {
    quantite?: true
  }

  export type StockMinAggregateInputType = {
    id?: true
    medicamentId?: true
    lot?: true
    datePeremption?: true
    quantite?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockMaxAggregateInputType = {
    id?: true
    medicamentId?: true
    lot?: true
    datePeremption?: true
    quantite?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockCountAggregateInputType = {
    id?: true
    medicamentId?: true
    lot?: true
    datePeremption?: true
    quantite?: true
    emplacement?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stock to aggregate.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stocks
    **/
    _count?: true | StockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMaxAggregateInputType
  }

  export type GetStockAggregateType<T extends StockAggregateArgs> = {
        [P in keyof T & keyof AggregateStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStock[P]>
      : GetScalarType<T[P], AggregateStock[P]>
  }




  export type StockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockWhereInput
    orderBy?: StockOrderByWithAggregationInput | StockOrderByWithAggregationInput[]
    by: StockScalarFieldEnum[] | StockScalarFieldEnum
    having?: StockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockCountAggregateInputType | true
    _avg?: StockAvgAggregateInputType
    _sum?: StockSumAggregateInputType
    _min?: StockMinAggregateInputType
    _max?: StockMaxAggregateInputType
  }

  export type StockGroupByOutputType = {
    id: string
    medicamentId: string
    lot: string
    datePeremption: Date
    quantite: number
    emplacement: string | null
    createdAt: Date
    updatedAt: Date
    _count: StockCountAggregateOutputType | null
    _avg: StockAvgAggregateOutputType | null
    _sum: StockSumAggregateOutputType | null
    _min: StockMinAggregateOutputType | null
    _max: StockMaxAggregateOutputType | null
  }

  type GetStockGroupByPayload<T extends StockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockGroupByOutputType[P]>
            : GetScalarType<T[P], StockGroupByOutputType[P]>
        }
      >
    >


  export type StockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    lot?: boolean
    datePeremption?: boolean
    quantite?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    lot?: boolean
    datePeremption?: boolean
    quantite?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    lot?: boolean
    datePeremption?: boolean
    quantite?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stock"]>

  export type StockSelectScalar = {
    id?: boolean
    medicamentId?: boolean
    lot?: boolean
    datePeremption?: boolean
    quantite?: boolean
    emplacement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicamentId" | "lot" | "datePeremption" | "quantite" | "emplacement" | "createdAt" | "updatedAt", ExtArgs["result"]["stock"]>
  export type StockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type StockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type StockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }

  export type $StockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stock"
    objects: {
      medicament: Prisma.$MedicamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicamentId: string
      lot: string
      datePeremption: Date
      quantite: number
      emplacement: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stock"]>
    composites: {}
  }

  type StockGetPayload<S extends boolean | null | undefined | StockDefaultArgs> = $Result.GetResult<Prisma.$StockPayload, S>

  type StockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockCountAggregateInputType | true
    }

  export interface StockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stock'], meta: { name: 'Stock' } }
    /**
     * Find zero or one Stock that matches the filter.
     * @param {StockFindUniqueArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockFindUniqueArgs>(args: SelectSubset<T, StockFindUniqueArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Stock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockFindUniqueOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockFindUniqueOrThrowArgs>(args: SelectSubset<T, StockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Stock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockFindFirstArgs>(args?: SelectSubset<T, StockFindFirstArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Stock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindFirstOrThrowArgs} args - Arguments to find a Stock
     * @example
     * // Get one Stock
     * const stock = await prisma.stock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockFindFirstOrThrowArgs>(args?: SelectSubset<T, StockFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Stocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stocks
     * const stocks = await prisma.stock.findMany()
     * 
     * // Get first 10 Stocks
     * const stocks = await prisma.stock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockWithIdOnly = await prisma.stock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockFindManyArgs>(args?: SelectSubset<T, StockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Stock.
     * @param {StockCreateArgs} args - Arguments to create a Stock.
     * @example
     * // Create one Stock
     * const Stock = await prisma.stock.create({
     *   data: {
     *     // ... data to create a Stock
     *   }
     * })
     * 
     */
    create<T extends StockCreateArgs>(args: SelectSubset<T, StockCreateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Stocks.
     * @param {StockCreateManyArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockCreateManyArgs>(args?: SelectSubset<T, StockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stocks and returns the data saved in the database.
     * @param {StockCreateManyAndReturnArgs} args - Arguments to create many Stocks.
     * @example
     * // Create many Stocks
     * const stock = await prisma.stock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockCreateManyAndReturnArgs>(args?: SelectSubset<T, StockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Stock.
     * @param {StockDeleteArgs} args - Arguments to delete one Stock.
     * @example
     * // Delete one Stock
     * const Stock = await prisma.stock.delete({
     *   where: {
     *     // ... filter to delete one Stock
     *   }
     * })
     * 
     */
    delete<T extends StockDeleteArgs>(args: SelectSubset<T, StockDeleteArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Stock.
     * @param {StockUpdateArgs} args - Arguments to update one Stock.
     * @example
     * // Update one Stock
     * const stock = await prisma.stock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockUpdateArgs>(args: SelectSubset<T, StockUpdateArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Stocks.
     * @param {StockDeleteManyArgs} args - Arguments to filter Stocks to delete.
     * @example
     * // Delete a few Stocks
     * const { count } = await prisma.stock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDeleteManyArgs>(args?: SelectSubset<T, StockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockUpdateManyArgs>(args: SelectSubset<T, StockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stocks and returns the data updated in the database.
     * @param {StockUpdateManyAndReturnArgs} args - Arguments to update many Stocks.
     * @example
     * // Update many Stocks
     * const stock = await prisma.stock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stocks and only return the `id`
     * const stockWithIdOnly = await prisma.stock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockUpdateManyAndReturnArgs>(args: SelectSubset<T, StockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Stock.
     * @param {StockUpsertArgs} args - Arguments to update or create a Stock.
     * @example
     * // Update or create a Stock
     * const stock = await prisma.stock.upsert({
     *   create: {
     *     // ... data to create a Stock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stock we want to update
     *   }
     * })
     */
    upsert<T extends StockUpsertArgs>(args: SelectSubset<T, StockUpsertArgs<ExtArgs>>): Prisma__StockClient<$Result.GetResult<Prisma.$StockPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Stocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockCountArgs} args - Arguments to filter Stocks to count.
     * @example
     * // Count the number of Stocks
     * const count = await prisma.stock.count({
     *   where: {
     *     // ... the filter for the Stocks we want to count
     *   }
     * })
    **/
    count<T extends StockCountArgs>(
      args?: Subset<T, StockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAggregateArgs>(args: Subset<T, StockAggregateArgs>): Prisma.PrismaPromise<GetStockAggregateType<T>>

    /**
     * Group by Stock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockGroupByArgs['orderBy'] }
        : { orderBy?: StockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stock model
   */
  readonly fields: StockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stock model
   */ 
  interface StockFieldRefs {
    readonly id: FieldRef<"Stock", 'String'>
    readonly medicamentId: FieldRef<"Stock", 'String'>
    readonly lot: FieldRef<"Stock", 'String'>
    readonly datePeremption: FieldRef<"Stock", 'DateTime'>
    readonly quantite: FieldRef<"Stock", 'Int'>
    readonly emplacement: FieldRef<"Stock", 'String'>
    readonly createdAt: FieldRef<"Stock", 'DateTime'>
    readonly updatedAt: FieldRef<"Stock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stock findUnique
   */
  export type StockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findUniqueOrThrow
   */
  export type StockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock findFirst
   */
  export type StockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findFirstOrThrow
   */
  export type StockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stock to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stocks.
     */
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock findMany
   */
  export type StockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter, which Stocks to fetch.
     */
    where?: StockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stocks to fetch.
     */
    orderBy?: StockOrderByWithRelationInput | StockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stocks.
     */
    cursor?: StockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stocks.
     */
    skip?: number
    distinct?: StockScalarFieldEnum | StockScalarFieldEnum[]
  }

  /**
   * Stock create
   */
  export type StockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to create a Stock.
     */
    data: XOR<StockCreateInput, StockUncheckedCreateInput>
  }

  /**
   * Stock createMany
   */
  export type StockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stock createManyAndReturn
   */
  export type StockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to create many Stocks.
     */
    data: StockCreateManyInput | StockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock update
   */
  export type StockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The data needed to update a Stock.
     */
    data: XOR<StockUpdateInput, StockUncheckedUpdateInput>
    /**
     * Choose, which Stock to update.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock updateMany
   */
  export type StockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
  }

  /**
   * Stock updateManyAndReturn
   */
  export type StockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * The data used to update Stocks.
     */
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyInput>
    /**
     * Filter which Stocks to update
     */
    where?: StockWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stock upsert
   */
  export type StockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * The filter to search for the Stock to update in case it exists.
     */
    where: StockWhereUniqueInput
    /**
     * In case the Stock found by the `where` argument doesn't exist, create a new Stock with this data.
     */
    create: XOR<StockCreateInput, StockUncheckedCreateInput>
    /**
     * In case the Stock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockUpdateInput, StockUncheckedUpdateInput>
  }

  /**
   * Stock delete
   */
  export type StockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
    /**
     * Filter which Stock to delete.
     */
    where: StockWhereUniqueInput
  }

  /**
   * Stock deleteMany
   */
  export type StockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stocks to delete
     */
    where?: StockWhereInput
  }

  /**
   * Stock without action
   */
  export type StockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stock
     */
    select?: StockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stock
     */
    omit?: StockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockInclude<ExtArgs> | null
  }


  /**
   * Model MouvementStock
   */

  export type AggregateMouvementStock = {
    _count: MouvementStockCountAggregateOutputType | null
    _avg: MouvementStockAvgAggregateOutputType | null
    _sum: MouvementStockSumAggregateOutputType | null
    _min: MouvementStockMinAggregateOutputType | null
    _max: MouvementStockMaxAggregateOutputType | null
  }

  export type MouvementStockAvgAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementStockSumAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementStockMinAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    type: string | null
    quantite: number | null
    motif: string | null
    reference: string | null
    utilisateur: string | null
    createdAt: Date | null
  }

  export type MouvementStockMaxAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    type: string | null
    quantite: number | null
    motif: string | null
    reference: string | null
    utilisateur: string | null
    createdAt: Date | null
  }

  export type MouvementStockCountAggregateOutputType = {
    id: number
    medicamentId: number
    type: number
    quantite: number
    motif: number
    reference: number
    utilisateur: number
    createdAt: number
    _all: number
  }


  export type MouvementStockAvgAggregateInputType = {
    quantite?: true
  }

  export type MouvementStockSumAggregateInputType = {
    quantite?: true
  }

  export type MouvementStockMinAggregateInputType = {
    id?: true
    medicamentId?: true
    type?: true
    quantite?: true
    motif?: true
    reference?: true
    utilisateur?: true
    createdAt?: true
  }

  export type MouvementStockMaxAggregateInputType = {
    id?: true
    medicamentId?: true
    type?: true
    quantite?: true
    motif?: true
    reference?: true
    utilisateur?: true
    createdAt?: true
  }

  export type MouvementStockCountAggregateInputType = {
    id?: true
    medicamentId?: true
    type?: true
    quantite?: true
    motif?: true
    reference?: true
    utilisateur?: true
    createdAt?: true
    _all?: true
  }

  export type MouvementStockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementStock to aggregate.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MouvementStocks
    **/
    _count?: true | MouvementStockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MouvementStockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MouvementStockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MouvementStockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MouvementStockMaxAggregateInputType
  }

  export type GetMouvementStockAggregateType<T extends MouvementStockAggregateArgs> = {
        [P in keyof T & keyof AggregateMouvementStock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMouvementStock[P]>
      : GetScalarType<T[P], AggregateMouvementStock[P]>
  }




  export type MouvementStockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementStockWhereInput
    orderBy?: MouvementStockOrderByWithAggregationInput | MouvementStockOrderByWithAggregationInput[]
    by: MouvementStockScalarFieldEnum[] | MouvementStockScalarFieldEnum
    having?: MouvementStockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MouvementStockCountAggregateInputType | true
    _avg?: MouvementStockAvgAggregateInputType
    _sum?: MouvementStockSumAggregateInputType
    _min?: MouvementStockMinAggregateInputType
    _max?: MouvementStockMaxAggregateInputType
  }

  export type MouvementStockGroupByOutputType = {
    id: string
    medicamentId: string
    type: string
    quantite: number
    motif: string
    reference: string | null
    utilisateur: string
    createdAt: Date
    _count: MouvementStockCountAggregateOutputType | null
    _avg: MouvementStockAvgAggregateOutputType | null
    _sum: MouvementStockSumAggregateOutputType | null
    _min: MouvementStockMinAggregateOutputType | null
    _max: MouvementStockMaxAggregateOutputType | null
  }

  type GetMouvementStockGroupByPayload<T extends MouvementStockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MouvementStockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MouvementStockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MouvementStockGroupByOutputType[P]>
            : GetScalarType<T[P], MouvementStockGroupByOutputType[P]>
        }
      >
    >


  export type MouvementStockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    type?: boolean
    quantite?: boolean
    motif?: boolean
    reference?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementStock"]>

  export type MouvementStockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    type?: boolean
    quantite?: boolean
    motif?: boolean
    reference?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementStock"]>

  export type MouvementStockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    type?: boolean
    quantite?: boolean
    motif?: boolean
    reference?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementStock"]>

  export type MouvementStockSelectScalar = {
    id?: boolean
    medicamentId?: boolean
    type?: boolean
    quantite?: boolean
    motif?: boolean
    reference?: boolean
    utilisateur?: boolean
    createdAt?: boolean
  }

  export type MouvementStockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicamentId" | "type" | "quantite" | "motif" | "reference" | "utilisateur" | "createdAt", ExtArgs["result"]["mouvementStock"]>
  export type MouvementStockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type MouvementStockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }
  export type MouvementStockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
  }

  export type $MouvementStockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MouvementStock"
    objects: {
      medicament: Prisma.$MedicamentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicamentId: string
      type: string
      quantite: number
      motif: string
      reference: string | null
      utilisateur: string
      createdAt: Date
    }, ExtArgs["result"]["mouvementStock"]>
    composites: {}
  }

  type MouvementStockGetPayload<S extends boolean | null | undefined | MouvementStockDefaultArgs> = $Result.GetResult<Prisma.$MouvementStockPayload, S>

  type MouvementStockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MouvementStockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MouvementStockCountAggregateInputType | true
    }

  export interface MouvementStockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MouvementStock'], meta: { name: 'MouvementStock' } }
    /**
     * Find zero or one MouvementStock that matches the filter.
     * @param {MouvementStockFindUniqueArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MouvementStockFindUniqueArgs>(args: SelectSubset<T, MouvementStockFindUniqueArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MouvementStock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MouvementStockFindUniqueOrThrowArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MouvementStockFindUniqueOrThrowArgs>(args: SelectSubset<T, MouvementStockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MouvementStock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindFirstArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MouvementStockFindFirstArgs>(args?: SelectSubset<T, MouvementStockFindFirstArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MouvementStock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindFirstOrThrowArgs} args - Arguments to find a MouvementStock
     * @example
     * // Get one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MouvementStockFindFirstOrThrowArgs>(args?: SelectSubset<T, MouvementStockFindFirstOrThrowArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MouvementStocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MouvementStocks
     * const mouvementStocks = await prisma.mouvementStock.findMany()
     * 
     * // Get first 10 MouvementStocks
     * const mouvementStocks = await prisma.mouvementStock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mouvementStockWithIdOnly = await prisma.mouvementStock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MouvementStockFindManyArgs>(args?: SelectSubset<T, MouvementStockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MouvementStock.
     * @param {MouvementStockCreateArgs} args - Arguments to create a MouvementStock.
     * @example
     * // Create one MouvementStock
     * const MouvementStock = await prisma.mouvementStock.create({
     *   data: {
     *     // ... data to create a MouvementStock
     *   }
     * })
     * 
     */
    create<T extends MouvementStockCreateArgs>(args: SelectSubset<T, MouvementStockCreateArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MouvementStocks.
     * @param {MouvementStockCreateManyArgs} args - Arguments to create many MouvementStocks.
     * @example
     * // Create many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MouvementStockCreateManyArgs>(args?: SelectSubset<T, MouvementStockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MouvementStocks and returns the data saved in the database.
     * @param {MouvementStockCreateManyAndReturnArgs} args - Arguments to create many MouvementStocks.
     * @example
     * // Create many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MouvementStocks and only return the `id`
     * const mouvementStockWithIdOnly = await prisma.mouvementStock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MouvementStockCreateManyAndReturnArgs>(args?: SelectSubset<T, MouvementStockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MouvementStock.
     * @param {MouvementStockDeleteArgs} args - Arguments to delete one MouvementStock.
     * @example
     * // Delete one MouvementStock
     * const MouvementStock = await prisma.mouvementStock.delete({
     *   where: {
     *     // ... filter to delete one MouvementStock
     *   }
     * })
     * 
     */
    delete<T extends MouvementStockDeleteArgs>(args: SelectSubset<T, MouvementStockDeleteArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MouvementStock.
     * @param {MouvementStockUpdateArgs} args - Arguments to update one MouvementStock.
     * @example
     * // Update one MouvementStock
     * const mouvementStock = await prisma.mouvementStock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MouvementStockUpdateArgs>(args: SelectSubset<T, MouvementStockUpdateArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MouvementStocks.
     * @param {MouvementStockDeleteManyArgs} args - Arguments to filter MouvementStocks to delete.
     * @example
     * // Delete a few MouvementStocks
     * const { count } = await prisma.mouvementStock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MouvementStockDeleteManyArgs>(args?: SelectSubset<T, MouvementStockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MouvementStockUpdateManyArgs>(args: SelectSubset<T, MouvementStockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementStocks and returns the data updated in the database.
     * @param {MouvementStockUpdateManyAndReturnArgs} args - Arguments to update many MouvementStocks.
     * @example
     * // Update many MouvementStocks
     * const mouvementStock = await prisma.mouvementStock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MouvementStocks and only return the `id`
     * const mouvementStockWithIdOnly = await prisma.mouvementStock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MouvementStockUpdateManyAndReturnArgs>(args: SelectSubset<T, MouvementStockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MouvementStock.
     * @param {MouvementStockUpsertArgs} args - Arguments to update or create a MouvementStock.
     * @example
     * // Update or create a MouvementStock
     * const mouvementStock = await prisma.mouvementStock.upsert({
     *   create: {
     *     // ... data to create a MouvementStock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MouvementStock we want to update
     *   }
     * })
     */
    upsert<T extends MouvementStockUpsertArgs>(args: SelectSubset<T, MouvementStockUpsertArgs<ExtArgs>>): Prisma__MouvementStockClient<$Result.GetResult<Prisma.$MouvementStockPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MouvementStocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockCountArgs} args - Arguments to filter MouvementStocks to count.
     * @example
     * // Count the number of MouvementStocks
     * const count = await prisma.mouvementStock.count({
     *   where: {
     *     // ... the filter for the MouvementStocks we want to count
     *   }
     * })
    **/
    count<T extends MouvementStockCountArgs>(
      args?: Subset<T, MouvementStockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MouvementStockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MouvementStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MouvementStockAggregateArgs>(args: Subset<T, MouvementStockAggregateArgs>): Prisma.PrismaPromise<GetMouvementStockAggregateType<T>>

    /**
     * Group by MouvementStock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementStockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MouvementStockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MouvementStockGroupByArgs['orderBy'] }
        : { orderBy?: MouvementStockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MouvementStockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMouvementStockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MouvementStock model
   */
  readonly fields: MouvementStockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MouvementStock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MouvementStockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MouvementStock model
   */ 
  interface MouvementStockFieldRefs {
    readonly id: FieldRef<"MouvementStock", 'String'>
    readonly medicamentId: FieldRef<"MouvementStock", 'String'>
    readonly type: FieldRef<"MouvementStock", 'String'>
    readonly quantite: FieldRef<"MouvementStock", 'Int'>
    readonly motif: FieldRef<"MouvementStock", 'String'>
    readonly reference: FieldRef<"MouvementStock", 'String'>
    readonly utilisateur: FieldRef<"MouvementStock", 'String'>
    readonly createdAt: FieldRef<"MouvementStock", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MouvementStock findUnique
   */
  export type MouvementStockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock findUniqueOrThrow
   */
  export type MouvementStockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock findFirst
   */
  export type MouvementStockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementStocks.
     */
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock findFirstOrThrow
   */
  export type MouvementStockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStock to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementStocks.
     */
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock findMany
   */
  export type MouvementStockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter, which MouvementStocks to fetch.
     */
    where?: MouvementStockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementStocks to fetch.
     */
    orderBy?: MouvementStockOrderByWithRelationInput | MouvementStockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MouvementStocks.
     */
    cursor?: MouvementStockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementStocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementStocks.
     */
    skip?: number
    distinct?: MouvementStockScalarFieldEnum | MouvementStockScalarFieldEnum[]
  }

  /**
   * MouvementStock create
   */
  export type MouvementStockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The data needed to create a MouvementStock.
     */
    data: XOR<MouvementStockCreateInput, MouvementStockUncheckedCreateInput>
  }

  /**
   * MouvementStock createMany
   */
  export type MouvementStockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MouvementStocks.
     */
    data: MouvementStockCreateManyInput | MouvementStockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MouvementStock createManyAndReturn
   */
  export type MouvementStockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * The data used to create many MouvementStocks.
     */
    data: MouvementStockCreateManyInput | MouvementStockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementStock update
   */
  export type MouvementStockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The data needed to update a MouvementStock.
     */
    data: XOR<MouvementStockUpdateInput, MouvementStockUncheckedUpdateInput>
    /**
     * Choose, which MouvementStock to update.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock updateMany
   */
  export type MouvementStockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MouvementStocks.
     */
    data: XOR<MouvementStockUpdateManyMutationInput, MouvementStockUncheckedUpdateManyInput>
    /**
     * Filter which MouvementStocks to update
     */
    where?: MouvementStockWhereInput
  }

  /**
   * MouvementStock updateManyAndReturn
   */
  export type MouvementStockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * The data used to update MouvementStocks.
     */
    data: XOR<MouvementStockUpdateManyMutationInput, MouvementStockUncheckedUpdateManyInput>
    /**
     * Filter which MouvementStocks to update
     */
    where?: MouvementStockWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementStock upsert
   */
  export type MouvementStockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * The filter to search for the MouvementStock to update in case it exists.
     */
    where: MouvementStockWhereUniqueInput
    /**
     * In case the MouvementStock found by the `where` argument doesn't exist, create a new MouvementStock with this data.
     */
    create: XOR<MouvementStockCreateInput, MouvementStockUncheckedCreateInput>
    /**
     * In case the MouvementStock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MouvementStockUpdateInput, MouvementStockUncheckedUpdateInput>
  }

  /**
   * MouvementStock delete
   */
  export type MouvementStockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
    /**
     * Filter which MouvementStock to delete.
     */
    where: MouvementStockWhereUniqueInput
  }

  /**
   * MouvementStock deleteMany
   */
  export type MouvementStockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementStocks to delete
     */
    where?: MouvementStockWhereInput
  }

  /**
   * MouvementStock without action
   */
  export type MouvementStockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementStock
     */
    select?: MouvementStockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementStock
     */
    omit?: MouvementStockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementStockInclude<ExtArgs> | null
  }


  /**
   * Model Dispensation
   */

  export type AggregateDispensation = {
    _count: DispensationCountAggregateOutputType | null
    _avg: DispensationAvgAggregateOutputType | null
    _sum: DispensationSumAggregateOutputType | null
    _min: DispensationMinAggregateOutputType | null
    _max: DispensationMaxAggregateOutputType | null
  }

  export type DispensationAvgAggregateOutputType = {
    quantite: number | null
  }

  export type DispensationSumAggregateOutputType = {
    quantite: number | null
  }

  export type DispensationMinAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    patientId: string | null
    quantite: number | null
    prescription: string | null
    pharmacien: string | null
    createdAt: Date | null
  }

  export type DispensationMaxAggregateOutputType = {
    id: string | null
    medicamentId: string | null
    patientId: string | null
    quantite: number | null
    prescription: string | null
    pharmacien: string | null
    createdAt: Date | null
  }

  export type DispensationCountAggregateOutputType = {
    id: number
    medicamentId: number
    patientId: number
    quantite: number
    prescription: number
    pharmacien: number
    createdAt: number
    _all: number
  }


  export type DispensationAvgAggregateInputType = {
    quantite?: true
  }

  export type DispensationSumAggregateInputType = {
    quantite?: true
  }

  export type DispensationMinAggregateInputType = {
    id?: true
    medicamentId?: true
    patientId?: true
    quantite?: true
    prescription?: true
    pharmacien?: true
    createdAt?: true
  }

  export type DispensationMaxAggregateInputType = {
    id?: true
    medicamentId?: true
    patientId?: true
    quantite?: true
    prescription?: true
    pharmacien?: true
    createdAt?: true
  }

  export type DispensationCountAggregateInputType = {
    id?: true
    medicamentId?: true
    patientId?: true
    quantite?: true
    prescription?: true
    pharmacien?: true
    createdAt?: true
    _all?: true
  }

  export type DispensationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispensation to aggregate.
     */
    where?: DispensationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispensations to fetch.
     */
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DispensationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispensations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispensations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dispensations
    **/
    _count?: true | DispensationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DispensationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DispensationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DispensationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DispensationMaxAggregateInputType
  }

  export type GetDispensationAggregateType<T extends DispensationAggregateArgs> = {
        [P in keyof T & keyof AggregateDispensation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispensation[P]>
      : GetScalarType<T[P], AggregateDispensation[P]>
  }




  export type DispensationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DispensationWhereInput
    orderBy?: DispensationOrderByWithAggregationInput | DispensationOrderByWithAggregationInput[]
    by: DispensationScalarFieldEnum[] | DispensationScalarFieldEnum
    having?: DispensationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DispensationCountAggregateInputType | true
    _avg?: DispensationAvgAggregateInputType
    _sum?: DispensationSumAggregateInputType
    _min?: DispensationMinAggregateInputType
    _max?: DispensationMaxAggregateInputType
  }

  export type DispensationGroupByOutputType = {
    id: string
    medicamentId: string
    patientId: string
    quantite: number
    prescription: string | null
    pharmacien: string
    createdAt: Date
    _count: DispensationCountAggregateOutputType | null
    _avg: DispensationAvgAggregateOutputType | null
    _sum: DispensationSumAggregateOutputType | null
    _min: DispensationMinAggregateOutputType | null
    _max: DispensationMaxAggregateOutputType | null
  }

  type GetDispensationGroupByPayload<T extends DispensationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DispensationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DispensationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DispensationGroupByOutputType[P]>
            : GetScalarType<T[P], DispensationGroupByOutputType[P]>
        }
      >
    >


  export type DispensationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    patientId?: boolean
    quantite?: boolean
    prescription?: boolean
    pharmacien?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispensation"]>

  export type DispensationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    patientId?: boolean
    quantite?: boolean
    prescription?: boolean
    pharmacien?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispensation"]>

  export type DispensationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicamentId?: boolean
    patientId?: boolean
    quantite?: boolean
    prescription?: boolean
    pharmacien?: boolean
    createdAt?: boolean
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispensation"]>

  export type DispensationSelectScalar = {
    id?: boolean
    medicamentId?: boolean
    patientId?: boolean
    quantite?: boolean
    prescription?: boolean
    pharmacien?: boolean
    createdAt?: boolean
  }

  export type DispensationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicamentId" | "patientId" | "quantite" | "prescription" | "pharmacien" | "createdAt", ExtArgs["result"]["dispensation"]>
  export type DispensationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DispensationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DispensationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicament?: boolean | MedicamentDefaultArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DispensationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispensation"
    objects: {
      medicament: Prisma.$MedicamentPayload<ExtArgs>
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicamentId: string
      patientId: string
      quantite: number
      prescription: string | null
      pharmacien: string
      createdAt: Date
    }, ExtArgs["result"]["dispensation"]>
    composites: {}
  }

  type DispensationGetPayload<S extends boolean | null | undefined | DispensationDefaultArgs> = $Result.GetResult<Prisma.$DispensationPayload, S>

  type DispensationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DispensationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DispensationCountAggregateInputType | true
    }

  export interface DispensationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispensation'], meta: { name: 'Dispensation' } }
    /**
     * Find zero or one Dispensation that matches the filter.
     * @param {DispensationFindUniqueArgs} args - Arguments to find a Dispensation
     * @example
     * // Get one Dispensation
     * const dispensation = await prisma.dispensation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DispensationFindUniqueArgs>(args: SelectSubset<T, DispensationFindUniqueArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Dispensation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DispensationFindUniqueOrThrowArgs} args - Arguments to find a Dispensation
     * @example
     * // Get one Dispensation
     * const dispensation = await prisma.dispensation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DispensationFindUniqueOrThrowArgs>(args: SelectSubset<T, DispensationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Dispensation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationFindFirstArgs} args - Arguments to find a Dispensation
     * @example
     * // Get one Dispensation
     * const dispensation = await prisma.dispensation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DispensationFindFirstArgs>(args?: SelectSubset<T, DispensationFindFirstArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Dispensation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationFindFirstOrThrowArgs} args - Arguments to find a Dispensation
     * @example
     * // Get one Dispensation
     * const dispensation = await prisma.dispensation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DispensationFindFirstOrThrowArgs>(args?: SelectSubset<T, DispensationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Dispensations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dispensations
     * const dispensations = await prisma.dispensation.findMany()
     * 
     * // Get first 10 Dispensations
     * const dispensations = await prisma.dispensation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dispensationWithIdOnly = await prisma.dispensation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DispensationFindManyArgs>(args?: SelectSubset<T, DispensationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Dispensation.
     * @param {DispensationCreateArgs} args - Arguments to create a Dispensation.
     * @example
     * // Create one Dispensation
     * const Dispensation = await prisma.dispensation.create({
     *   data: {
     *     // ... data to create a Dispensation
     *   }
     * })
     * 
     */
    create<T extends DispensationCreateArgs>(args: SelectSubset<T, DispensationCreateArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Dispensations.
     * @param {DispensationCreateManyArgs} args - Arguments to create many Dispensations.
     * @example
     * // Create many Dispensations
     * const dispensation = await prisma.dispensation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DispensationCreateManyArgs>(args?: SelectSubset<T, DispensationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dispensations and returns the data saved in the database.
     * @param {DispensationCreateManyAndReturnArgs} args - Arguments to create many Dispensations.
     * @example
     * // Create many Dispensations
     * const dispensation = await prisma.dispensation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dispensations and only return the `id`
     * const dispensationWithIdOnly = await prisma.dispensation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DispensationCreateManyAndReturnArgs>(args?: SelectSubset<T, DispensationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Dispensation.
     * @param {DispensationDeleteArgs} args - Arguments to delete one Dispensation.
     * @example
     * // Delete one Dispensation
     * const Dispensation = await prisma.dispensation.delete({
     *   where: {
     *     // ... filter to delete one Dispensation
     *   }
     * })
     * 
     */
    delete<T extends DispensationDeleteArgs>(args: SelectSubset<T, DispensationDeleteArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Dispensation.
     * @param {DispensationUpdateArgs} args - Arguments to update one Dispensation.
     * @example
     * // Update one Dispensation
     * const dispensation = await prisma.dispensation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DispensationUpdateArgs>(args: SelectSubset<T, DispensationUpdateArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Dispensations.
     * @param {DispensationDeleteManyArgs} args - Arguments to filter Dispensations to delete.
     * @example
     * // Delete a few Dispensations
     * const { count } = await prisma.dispensation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DispensationDeleteManyArgs>(args?: SelectSubset<T, DispensationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispensations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dispensations
     * const dispensation = await prisma.dispensation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DispensationUpdateManyArgs>(args: SelectSubset<T, DispensationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dispensations and returns the data updated in the database.
     * @param {DispensationUpdateManyAndReturnArgs} args - Arguments to update many Dispensations.
     * @example
     * // Update many Dispensations
     * const dispensation = await prisma.dispensation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dispensations and only return the `id`
     * const dispensationWithIdOnly = await prisma.dispensation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DispensationUpdateManyAndReturnArgs>(args: SelectSubset<T, DispensationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Dispensation.
     * @param {DispensationUpsertArgs} args - Arguments to update or create a Dispensation.
     * @example
     * // Update or create a Dispensation
     * const dispensation = await prisma.dispensation.upsert({
     *   create: {
     *     // ... data to create a Dispensation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispensation we want to update
     *   }
     * })
     */
    upsert<T extends DispensationUpsertArgs>(args: SelectSubset<T, DispensationUpsertArgs<ExtArgs>>): Prisma__DispensationClient<$Result.GetResult<Prisma.$DispensationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Dispensations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationCountArgs} args - Arguments to filter Dispensations to count.
     * @example
     * // Count the number of Dispensations
     * const count = await prisma.dispensation.count({
     *   where: {
     *     // ... the filter for the Dispensations we want to count
     *   }
     * })
    **/
    count<T extends DispensationCountArgs>(
      args?: Subset<T, DispensationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DispensationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispensation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DispensationAggregateArgs>(args: Subset<T, DispensationAggregateArgs>): Prisma.PrismaPromise<GetDispensationAggregateType<T>>

    /**
     * Group by Dispensation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DispensationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DispensationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DispensationGroupByArgs['orderBy'] }
        : { orderBy?: DispensationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DispensationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDispensationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispensation model
   */
  readonly fields: DispensationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispensation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DispensationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicament<T extends MedicamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicamentDefaultArgs<ExtArgs>>): Prisma__MedicamentClient<$Result.GetResult<Prisma.$MedicamentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispensation model
   */ 
  interface DispensationFieldRefs {
    readonly id: FieldRef<"Dispensation", 'String'>
    readonly medicamentId: FieldRef<"Dispensation", 'String'>
    readonly patientId: FieldRef<"Dispensation", 'String'>
    readonly quantite: FieldRef<"Dispensation", 'Int'>
    readonly prescription: FieldRef<"Dispensation", 'String'>
    readonly pharmacien: FieldRef<"Dispensation", 'String'>
    readonly createdAt: FieldRef<"Dispensation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispensation findUnique
   */
  export type DispensationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter, which Dispensation to fetch.
     */
    where: DispensationWhereUniqueInput
  }

  /**
   * Dispensation findUniqueOrThrow
   */
  export type DispensationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter, which Dispensation to fetch.
     */
    where: DispensationWhereUniqueInput
  }

  /**
   * Dispensation findFirst
   */
  export type DispensationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter, which Dispensation to fetch.
     */
    where?: DispensationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispensations to fetch.
     */
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispensations.
     */
    cursor?: DispensationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispensations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispensations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispensations.
     */
    distinct?: DispensationScalarFieldEnum | DispensationScalarFieldEnum[]
  }

  /**
   * Dispensation findFirstOrThrow
   */
  export type DispensationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter, which Dispensation to fetch.
     */
    where?: DispensationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispensations to fetch.
     */
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dispensations.
     */
    cursor?: DispensationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispensations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispensations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dispensations.
     */
    distinct?: DispensationScalarFieldEnum | DispensationScalarFieldEnum[]
  }

  /**
   * Dispensation findMany
   */
  export type DispensationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter, which Dispensations to fetch.
     */
    where?: DispensationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dispensations to fetch.
     */
    orderBy?: DispensationOrderByWithRelationInput | DispensationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dispensations.
     */
    cursor?: DispensationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dispensations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dispensations.
     */
    skip?: number
    distinct?: DispensationScalarFieldEnum | DispensationScalarFieldEnum[]
  }

  /**
   * Dispensation create
   */
  export type DispensationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispensation.
     */
    data: XOR<DispensationCreateInput, DispensationUncheckedCreateInput>
  }

  /**
   * Dispensation createMany
   */
  export type DispensationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dispensations.
     */
    data: DispensationCreateManyInput | DispensationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispensation createManyAndReturn
   */
  export type DispensationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * The data used to create many Dispensations.
     */
    data: DispensationCreateManyInput | DispensationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispensation update
   */
  export type DispensationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispensation.
     */
    data: XOR<DispensationUpdateInput, DispensationUncheckedUpdateInput>
    /**
     * Choose, which Dispensation to update.
     */
    where: DispensationWhereUniqueInput
  }

  /**
   * Dispensation updateMany
   */
  export type DispensationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dispensations.
     */
    data: XOR<DispensationUpdateManyMutationInput, DispensationUncheckedUpdateManyInput>
    /**
     * Filter which Dispensations to update
     */
    where?: DispensationWhereInput
  }

  /**
   * Dispensation updateManyAndReturn
   */
  export type DispensationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * The data used to update Dispensations.
     */
    data: XOR<DispensationUpdateManyMutationInput, DispensationUncheckedUpdateManyInput>
    /**
     * Filter which Dispensations to update
     */
    where?: DispensationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispensation upsert
   */
  export type DispensationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispensation to update in case it exists.
     */
    where: DispensationWhereUniqueInput
    /**
     * In case the Dispensation found by the `where` argument doesn't exist, create a new Dispensation with this data.
     */
    create: XOR<DispensationCreateInput, DispensationUncheckedCreateInput>
    /**
     * In case the Dispensation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DispensationUpdateInput, DispensationUncheckedUpdateInput>
  }

  /**
   * Dispensation delete
   */
  export type DispensationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
    /**
     * Filter which Dispensation to delete.
     */
    where: DispensationWhereUniqueInput
  }

  /**
   * Dispensation deleteMany
   */
  export type DispensationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispensations to delete
     */
    where?: DispensationWhereInput
  }

  /**
   * Dispensation without action
   */
  export type DispensationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispensation
     */
    select?: DispensationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispensation
     */
    omit?: DispensationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DispensationInclude<ExtArgs> | null
  }


  /**
   * Model Facture
   */

  export type AggregateFacture = {
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  export type FactureAvgAggregateOutputType = {
    montantHT: Decimal | null
    montantTVA: Decimal | null
    montantTTC: Decimal | null
    partAssurance: Decimal | null
    partPatient: Decimal | null
  }

  export type FactureSumAggregateOutputType = {
    montantHT: Decimal | null
    montantTVA: Decimal | null
    montantTTC: Decimal | null
    partAssurance: Decimal | null
    partPatient: Decimal | null
  }

  export type FactureMinAggregateOutputType = {
    id: string | null
    numeroFacture: string | null
    patientId: string | null
    dateFacture: Date | null
    dateEcheance: Date | null
    montantHT: Decimal | null
    montantTVA: Decimal | null
    montantTTC: Decimal | null
    partAssurance: Decimal | null
    partPatient: Decimal | null
    statut: string | null
    ecritureComptableId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FactureMaxAggregateOutputType = {
    id: string | null
    numeroFacture: string | null
    patientId: string | null
    dateFacture: Date | null
    dateEcheance: Date | null
    montantHT: Decimal | null
    montantTVA: Decimal | null
    montantTTC: Decimal | null
    partAssurance: Decimal | null
    partPatient: Decimal | null
    statut: string | null
    ecritureComptableId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FactureCountAggregateOutputType = {
    id: number
    numeroFacture: number
    patientId: number
    dateFacture: number
    dateEcheance: number
    montantHT: number
    montantTVA: number
    montantTTC: number
    partAssurance: number
    partPatient: number
    statut: number
    ecritureComptableId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FactureAvgAggregateInputType = {
    montantHT?: true
    montantTVA?: true
    montantTTC?: true
    partAssurance?: true
    partPatient?: true
  }

  export type FactureSumAggregateInputType = {
    montantHT?: true
    montantTVA?: true
    montantTTC?: true
    partAssurance?: true
    partPatient?: true
  }

  export type FactureMinAggregateInputType = {
    id?: true
    numeroFacture?: true
    patientId?: true
    dateFacture?: true
    dateEcheance?: true
    montantHT?: true
    montantTVA?: true
    montantTTC?: true
    partAssurance?: true
    partPatient?: true
    statut?: true
    ecritureComptableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FactureMaxAggregateInputType = {
    id?: true
    numeroFacture?: true
    patientId?: true
    dateFacture?: true
    dateEcheance?: true
    montantHT?: true
    montantTVA?: true
    montantTTC?: true
    partAssurance?: true
    partPatient?: true
    statut?: true
    ecritureComptableId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FactureCountAggregateInputType = {
    id?: true
    numeroFacture?: true
    patientId?: true
    dateFacture?: true
    dateEcheance?: true
    montantHT?: true
    montantTVA?: true
    montantTTC?: true
    partAssurance?: true
    partPatient?: true
    statut?: true
    ecritureComptableId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Facture to aggregate.
     */
    where?: FactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factures to fetch.
     */
    orderBy?: FactureOrderByWithRelationInput | FactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Factures
    **/
    _count?: true | FactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FactureMaxAggregateInputType
  }

  export type GetFactureAggregateType<T extends FactureAggregateArgs> = {
        [P in keyof T & keyof AggregateFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacture[P]>
      : GetScalarType<T[P], AggregateFacture[P]>
  }




  export type FactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FactureWhereInput
    orderBy?: FactureOrderByWithAggregationInput | FactureOrderByWithAggregationInput[]
    by: FactureScalarFieldEnum[] | FactureScalarFieldEnum
    having?: FactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FactureCountAggregateInputType | true
    _avg?: FactureAvgAggregateInputType
    _sum?: FactureSumAggregateInputType
    _min?: FactureMinAggregateInputType
    _max?: FactureMaxAggregateInputType
  }

  export type FactureGroupByOutputType = {
    id: string
    numeroFacture: string
    patientId: string
    dateFacture: Date
    dateEcheance: Date
    montantHT: Decimal
    montantTVA: Decimal
    montantTTC: Decimal
    partAssurance: Decimal
    partPatient: Decimal
    statut: string
    ecritureComptableId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FactureCountAggregateOutputType | null
    _avg: FactureAvgAggregateOutputType | null
    _sum: FactureSumAggregateOutputType | null
    _min: FactureMinAggregateOutputType | null
    _max: FactureMaxAggregateOutputType | null
  }

  type GetFactureGroupByPayload<T extends FactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FactureGroupByOutputType[P]>
            : GetScalarType<T[P], FactureGroupByOutputType[P]>
        }
      >
    >


  export type FactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroFacture?: boolean
    patientId?: boolean
    dateFacture?: boolean
    dateEcheance?: boolean
    montantHT?: boolean
    montantTVA?: boolean
    montantTTC?: boolean
    partAssurance?: boolean
    partPatient?: boolean
    statut?: boolean
    ecritureComptableId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lignes?: boolean | Facture$lignesArgs<ExtArgs>
    paiements?: boolean | Facture$paiementsArgs<ExtArgs>
    consultations?: boolean | Facture$consultationsArgs<ExtArgs>
    _count?: boolean | FactureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facture"]>

  export type FactureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroFacture?: boolean
    patientId?: boolean
    dateFacture?: boolean
    dateEcheance?: boolean
    montantHT?: boolean
    montantTVA?: boolean
    montantTTC?: boolean
    partAssurance?: boolean
    partPatient?: boolean
    statut?: boolean
    ecritureComptableId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facture"]>

  export type FactureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroFacture?: boolean
    patientId?: boolean
    dateFacture?: boolean
    dateEcheance?: boolean
    montantHT?: boolean
    montantTVA?: boolean
    montantTTC?: boolean
    partAssurance?: boolean
    partPatient?: boolean
    statut?: boolean
    ecritureComptableId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["facture"]>

  export type FactureSelectScalar = {
    id?: boolean
    numeroFacture?: boolean
    patientId?: boolean
    dateFacture?: boolean
    dateEcheance?: boolean
    montantHT?: boolean
    montantTVA?: boolean
    montantTTC?: boolean
    partAssurance?: boolean
    partPatient?: boolean
    statut?: boolean
    ecritureComptableId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numeroFacture" | "patientId" | "dateFacture" | "dateEcheance" | "montantHT" | "montantTVA" | "montantTTC" | "partAssurance" | "partPatient" | "statut" | "ecritureComptableId" | "createdAt" | "updatedAt", ExtArgs["result"]["facture"]>
  export type FactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lignes?: boolean | Facture$lignesArgs<ExtArgs>
    paiements?: boolean | Facture$paiementsArgs<ExtArgs>
    consultations?: boolean | Facture$consultationsArgs<ExtArgs>
    _count?: boolean | FactureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FactureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type FactureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $FacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Facture"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      lignes: Prisma.$LigneFacturePayload<ExtArgs>[]
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
      consultations: Prisma.$ConsultationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroFacture: string
      patientId: string
      dateFacture: Date
      dateEcheance: Date
      montantHT: Prisma.Decimal
      montantTVA: Prisma.Decimal
      montantTTC: Prisma.Decimal
      partAssurance: Prisma.Decimal
      partPatient: Prisma.Decimal
      statut: string
      ecritureComptableId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["facture"]>
    composites: {}
  }

  type FactureGetPayload<S extends boolean | null | undefined | FactureDefaultArgs> = $Result.GetResult<Prisma.$FacturePayload, S>

  type FactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FactureCountAggregateInputType | true
    }

  export interface FactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Facture'], meta: { name: 'Facture' } }
    /**
     * Find zero or one Facture that matches the filter.
     * @param {FactureFindUniqueArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FactureFindUniqueArgs>(args: SelectSubset<T, FactureFindUniqueArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Facture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FactureFindUniqueOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FactureFindUniqueOrThrowArgs>(args: SelectSubset<T, FactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Facture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureFindFirstArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FactureFindFirstArgs>(args?: SelectSubset<T, FactureFindFirstArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Facture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureFindFirstOrThrowArgs} args - Arguments to find a Facture
     * @example
     * // Get one Facture
     * const facture = await prisma.facture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FactureFindFirstOrThrowArgs>(args?: SelectSubset<T, FactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Factures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Factures
     * const factures = await prisma.facture.findMany()
     * 
     * // Get first 10 Factures
     * const factures = await prisma.facture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const factureWithIdOnly = await prisma.facture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FactureFindManyArgs>(args?: SelectSubset<T, FactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Facture.
     * @param {FactureCreateArgs} args - Arguments to create a Facture.
     * @example
     * // Create one Facture
     * const Facture = await prisma.facture.create({
     *   data: {
     *     // ... data to create a Facture
     *   }
     * })
     * 
     */
    create<T extends FactureCreateArgs>(args: SelectSubset<T, FactureCreateArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Factures.
     * @param {FactureCreateManyArgs} args - Arguments to create many Factures.
     * @example
     * // Create many Factures
     * const facture = await prisma.facture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FactureCreateManyArgs>(args?: SelectSubset<T, FactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Factures and returns the data saved in the database.
     * @param {FactureCreateManyAndReturnArgs} args - Arguments to create many Factures.
     * @example
     * // Create many Factures
     * const facture = await prisma.facture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Factures and only return the `id`
     * const factureWithIdOnly = await prisma.facture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FactureCreateManyAndReturnArgs>(args?: SelectSubset<T, FactureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Facture.
     * @param {FactureDeleteArgs} args - Arguments to delete one Facture.
     * @example
     * // Delete one Facture
     * const Facture = await prisma.facture.delete({
     *   where: {
     *     // ... filter to delete one Facture
     *   }
     * })
     * 
     */
    delete<T extends FactureDeleteArgs>(args: SelectSubset<T, FactureDeleteArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Facture.
     * @param {FactureUpdateArgs} args - Arguments to update one Facture.
     * @example
     * // Update one Facture
     * const facture = await prisma.facture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FactureUpdateArgs>(args: SelectSubset<T, FactureUpdateArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Factures.
     * @param {FactureDeleteManyArgs} args - Arguments to filter Factures to delete.
     * @example
     * // Delete a few Factures
     * const { count } = await prisma.facture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FactureDeleteManyArgs>(args?: SelectSubset<T, FactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Factures
     * const facture = await prisma.facture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FactureUpdateManyArgs>(args: SelectSubset<T, FactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Factures and returns the data updated in the database.
     * @param {FactureUpdateManyAndReturnArgs} args - Arguments to update many Factures.
     * @example
     * // Update many Factures
     * const facture = await prisma.facture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Factures and only return the `id`
     * const factureWithIdOnly = await prisma.facture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FactureUpdateManyAndReturnArgs>(args: SelectSubset<T, FactureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Facture.
     * @param {FactureUpsertArgs} args - Arguments to update or create a Facture.
     * @example
     * // Update or create a Facture
     * const facture = await prisma.facture.upsert({
     *   create: {
     *     // ... data to create a Facture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facture we want to update
     *   }
     * })
     */
    upsert<T extends FactureUpsertArgs>(args: SelectSubset<T, FactureUpsertArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Factures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureCountArgs} args - Arguments to filter Factures to count.
     * @example
     * // Count the number of Factures
     * const count = await prisma.facture.count({
     *   where: {
     *     // ... the filter for the Factures we want to count
     *   }
     * })
    **/
    count<T extends FactureCountArgs>(
      args?: Subset<T, FactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FactureAggregateArgs>(args: Subset<T, FactureAggregateArgs>): Prisma.PrismaPromise<GetFactureAggregateType<T>>

    /**
     * Group by Facture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FactureGroupByArgs['orderBy'] }
        : { orderBy?: FactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Facture model
   */
  readonly fields: FactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    lignes<T extends Facture$lignesArgs<ExtArgs> = {}>(args?: Subset<T, Facture$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    paiements<T extends Facture$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Facture$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    consultations<T extends Facture$consultationsArgs<ExtArgs> = {}>(args?: Subset<T, Facture$consultationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConsultationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Facture model
   */ 
  interface FactureFieldRefs {
    readonly id: FieldRef<"Facture", 'String'>
    readonly numeroFacture: FieldRef<"Facture", 'String'>
    readonly patientId: FieldRef<"Facture", 'String'>
    readonly dateFacture: FieldRef<"Facture", 'DateTime'>
    readonly dateEcheance: FieldRef<"Facture", 'DateTime'>
    readonly montantHT: FieldRef<"Facture", 'Decimal'>
    readonly montantTVA: FieldRef<"Facture", 'Decimal'>
    readonly montantTTC: FieldRef<"Facture", 'Decimal'>
    readonly partAssurance: FieldRef<"Facture", 'Decimal'>
    readonly partPatient: FieldRef<"Facture", 'Decimal'>
    readonly statut: FieldRef<"Facture", 'String'>
    readonly ecritureComptableId: FieldRef<"Facture", 'String'>
    readonly createdAt: FieldRef<"Facture", 'DateTime'>
    readonly updatedAt: FieldRef<"Facture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Facture findUnique
   */
  export type FactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter, which Facture to fetch.
     */
    where: FactureWhereUniqueInput
  }

  /**
   * Facture findUniqueOrThrow
   */
  export type FactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter, which Facture to fetch.
     */
    where: FactureWhereUniqueInput
  }

  /**
   * Facture findFirst
   */
  export type FactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter, which Facture to fetch.
     */
    where?: FactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factures to fetch.
     */
    orderBy?: FactureOrderByWithRelationInput | FactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factures.
     */
    cursor?: FactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factures.
     */
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }

  /**
   * Facture findFirstOrThrow
   */
  export type FactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter, which Facture to fetch.
     */
    where?: FactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factures to fetch.
     */
    orderBy?: FactureOrderByWithRelationInput | FactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Factures.
     */
    cursor?: FactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Factures.
     */
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }

  /**
   * Facture findMany
   */
  export type FactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter, which Factures to fetch.
     */
    where?: FactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Factures to fetch.
     */
    orderBy?: FactureOrderByWithRelationInput | FactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Factures.
     */
    cursor?: FactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Factures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Factures.
     */
    skip?: number
    distinct?: FactureScalarFieldEnum | FactureScalarFieldEnum[]
  }

  /**
   * Facture create
   */
  export type FactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * The data needed to create a Facture.
     */
    data: XOR<FactureCreateInput, FactureUncheckedCreateInput>
  }

  /**
   * Facture createMany
   */
  export type FactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Factures.
     */
    data: FactureCreateManyInput | FactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Facture createManyAndReturn
   */
  export type FactureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * The data used to create many Factures.
     */
    data: FactureCreateManyInput | FactureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facture update
   */
  export type FactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * The data needed to update a Facture.
     */
    data: XOR<FactureUpdateInput, FactureUncheckedUpdateInput>
    /**
     * Choose, which Facture to update.
     */
    where: FactureWhereUniqueInput
  }

  /**
   * Facture updateMany
   */
  export type FactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Factures.
     */
    data: XOR<FactureUpdateManyMutationInput, FactureUncheckedUpdateManyInput>
    /**
     * Filter which Factures to update
     */
    where?: FactureWhereInput
  }

  /**
   * Facture updateManyAndReturn
   */
  export type FactureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * The data used to update Factures.
     */
    data: XOR<FactureUpdateManyMutationInput, FactureUncheckedUpdateManyInput>
    /**
     * Filter which Factures to update
     */
    where?: FactureWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Facture upsert
   */
  export type FactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * The filter to search for the Facture to update in case it exists.
     */
    where: FactureWhereUniqueInput
    /**
     * In case the Facture found by the `where` argument doesn't exist, create a new Facture with this data.
     */
    create: XOR<FactureCreateInput, FactureUncheckedCreateInput>
    /**
     * In case the Facture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FactureUpdateInput, FactureUncheckedUpdateInput>
  }

  /**
   * Facture delete
   */
  export type FactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
    /**
     * Filter which Facture to delete.
     */
    where: FactureWhereUniqueInput
  }

  /**
   * Facture deleteMany
   */
  export type FactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Factures to delete
     */
    where?: FactureWhereInput
  }

  /**
   * Facture.lignes
   */
  export type Facture$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    where?: LigneFactureWhereInput
    orderBy?: LigneFactureOrderByWithRelationInput | LigneFactureOrderByWithRelationInput[]
    cursor?: LigneFactureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneFactureScalarFieldEnum | LigneFactureScalarFieldEnum[]
  }

  /**
   * Facture.paiements
   */
  export type Facture$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Facture.consultations
   */
  export type Facture$consultationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Consultation
     */
    select?: ConsultationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Consultation
     */
    omit?: ConsultationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConsultationInclude<ExtArgs> | null
    where?: ConsultationWhereInput
    orderBy?: ConsultationOrderByWithRelationInput | ConsultationOrderByWithRelationInput[]
    cursor?: ConsultationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConsultationScalarFieldEnum | ConsultationScalarFieldEnum[]
  }

  /**
   * Facture without action
   */
  export type FactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Facture
     */
    select?: FactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Facture
     */
    omit?: FactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FactureInclude<ExtArgs> | null
  }


  /**
   * Model LigneFacture
   */

  export type AggregateLigneFacture = {
    _count: LigneFactureCountAggregateOutputType | null
    _avg: LigneFactureAvgAggregateOutputType | null
    _sum: LigneFactureSumAggregateOutputType | null
    _min: LigneFactureMinAggregateOutputType | null
    _max: LigneFactureMaxAggregateOutputType | null
  }

  export type LigneFactureAvgAggregateOutputType = {
    quantite: number | null
    prixUnitaire: Decimal | null
    montant: Decimal | null
  }

  export type LigneFactureSumAggregateOutputType = {
    quantite: number | null
    prixUnitaire: Decimal | null
    montant: Decimal | null
  }

  export type LigneFactureMinAggregateOutputType = {
    id: string | null
    factureId: string | null
    designation: string | null
    quantite: number | null
    prixUnitaire: Decimal | null
    montant: Decimal | null
    createdAt: Date | null
  }

  export type LigneFactureMaxAggregateOutputType = {
    id: string | null
    factureId: string | null
    designation: string | null
    quantite: number | null
    prixUnitaire: Decimal | null
    montant: Decimal | null
    createdAt: Date | null
  }

  export type LigneFactureCountAggregateOutputType = {
    id: number
    factureId: number
    designation: number
    quantite: number
    prixUnitaire: number
    montant: number
    createdAt: number
    _all: number
  }


  export type LigneFactureAvgAggregateInputType = {
    quantite?: true
    prixUnitaire?: true
    montant?: true
  }

  export type LigneFactureSumAggregateInputType = {
    quantite?: true
    prixUnitaire?: true
    montant?: true
  }

  export type LigneFactureMinAggregateInputType = {
    id?: true
    factureId?: true
    designation?: true
    quantite?: true
    prixUnitaire?: true
    montant?: true
    createdAt?: true
  }

  export type LigneFactureMaxAggregateInputType = {
    id?: true
    factureId?: true
    designation?: true
    quantite?: true
    prixUnitaire?: true
    montant?: true
    createdAt?: true
  }

  export type LigneFactureCountAggregateInputType = {
    id?: true
    factureId?: true
    designation?: true
    quantite?: true
    prixUnitaire?: true
    montant?: true
    createdAt?: true
    _all?: true
  }

  export type LigneFactureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneFacture to aggregate.
     */
    where?: LigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneFactures to fetch.
     */
    orderBy?: LigneFactureOrderByWithRelationInput | LigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneFactures
    **/
    _count?: true | LigneFactureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneFactureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneFactureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneFactureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneFactureMaxAggregateInputType
  }

  export type GetLigneFactureAggregateType<T extends LigneFactureAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneFacture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneFacture[P]>
      : GetScalarType<T[P], AggregateLigneFacture[P]>
  }




  export type LigneFactureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneFactureWhereInput
    orderBy?: LigneFactureOrderByWithAggregationInput | LigneFactureOrderByWithAggregationInput[]
    by: LigneFactureScalarFieldEnum[] | LigneFactureScalarFieldEnum
    having?: LigneFactureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneFactureCountAggregateInputType | true
    _avg?: LigneFactureAvgAggregateInputType
    _sum?: LigneFactureSumAggregateInputType
    _min?: LigneFactureMinAggregateInputType
    _max?: LigneFactureMaxAggregateInputType
  }

  export type LigneFactureGroupByOutputType = {
    id: string
    factureId: string
    designation: string
    quantite: number
    prixUnitaire: Decimal
    montant: Decimal
    createdAt: Date
    _count: LigneFactureCountAggregateOutputType | null
    _avg: LigneFactureAvgAggregateOutputType | null
    _sum: LigneFactureSumAggregateOutputType | null
    _min: LigneFactureMinAggregateOutputType | null
    _max: LigneFactureMaxAggregateOutputType | null
  }

  type GetLigneFactureGroupByPayload<T extends LigneFactureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneFactureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneFactureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneFactureGroupByOutputType[P]>
            : GetScalarType<T[P], LigneFactureGroupByOutputType[P]>
        }
      >
    >


  export type LigneFactureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    designation?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    montant?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneFacture"]>

  export type LigneFactureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    designation?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    montant?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneFacture"]>

  export type LigneFactureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    designation?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    montant?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneFacture"]>

  export type LigneFactureSelectScalar = {
    id?: boolean
    factureId?: boolean
    designation?: boolean
    quantite?: boolean
    prixUnitaire?: boolean
    montant?: boolean
    createdAt?: boolean
  }

  export type LigneFactureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "factureId" | "designation" | "quantite" | "prixUnitaire" | "montant" | "createdAt", ExtArgs["result"]["ligneFacture"]>
  export type LigneFactureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }
  export type LigneFactureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }
  export type LigneFactureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
  }

  export type $LigneFacturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneFacture"
    objects: {
      facture: Prisma.$FacturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      factureId: string
      designation: string
      quantite: number
      prixUnitaire: Prisma.Decimal
      montant: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["ligneFacture"]>
    composites: {}
  }

  type LigneFactureGetPayload<S extends boolean | null | undefined | LigneFactureDefaultArgs> = $Result.GetResult<Prisma.$LigneFacturePayload, S>

  type LigneFactureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneFactureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneFactureCountAggregateInputType | true
    }

  export interface LigneFactureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneFacture'], meta: { name: 'LigneFacture' } }
    /**
     * Find zero or one LigneFacture that matches the filter.
     * @param {LigneFactureFindUniqueArgs} args - Arguments to find a LigneFacture
     * @example
     * // Get one LigneFacture
     * const ligneFacture = await prisma.ligneFacture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneFactureFindUniqueArgs>(args: SelectSubset<T, LigneFactureFindUniqueArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LigneFacture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneFactureFindUniqueOrThrowArgs} args - Arguments to find a LigneFacture
     * @example
     * // Get one LigneFacture
     * const ligneFacture = await prisma.ligneFacture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneFactureFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneFactureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LigneFacture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureFindFirstArgs} args - Arguments to find a LigneFacture
     * @example
     * // Get one LigneFacture
     * const ligneFacture = await prisma.ligneFacture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneFactureFindFirstArgs>(args?: SelectSubset<T, LigneFactureFindFirstArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LigneFacture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureFindFirstOrThrowArgs} args - Arguments to find a LigneFacture
     * @example
     * // Get one LigneFacture
     * const ligneFacture = await prisma.ligneFacture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneFactureFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneFactureFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LigneFactures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneFactures
     * const ligneFactures = await prisma.ligneFacture.findMany()
     * 
     * // Get first 10 LigneFactures
     * const ligneFactures = await prisma.ligneFacture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneFactureWithIdOnly = await prisma.ligneFacture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneFactureFindManyArgs>(args?: SelectSubset<T, LigneFactureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LigneFacture.
     * @param {LigneFactureCreateArgs} args - Arguments to create a LigneFacture.
     * @example
     * // Create one LigneFacture
     * const LigneFacture = await prisma.ligneFacture.create({
     *   data: {
     *     // ... data to create a LigneFacture
     *   }
     * })
     * 
     */
    create<T extends LigneFactureCreateArgs>(args: SelectSubset<T, LigneFactureCreateArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LigneFactures.
     * @param {LigneFactureCreateManyArgs} args - Arguments to create many LigneFactures.
     * @example
     * // Create many LigneFactures
     * const ligneFacture = await prisma.ligneFacture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneFactureCreateManyArgs>(args?: SelectSubset<T, LigneFactureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LigneFactures and returns the data saved in the database.
     * @param {LigneFactureCreateManyAndReturnArgs} args - Arguments to create many LigneFactures.
     * @example
     * // Create many LigneFactures
     * const ligneFacture = await prisma.ligneFacture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LigneFactures and only return the `id`
     * const ligneFactureWithIdOnly = await prisma.ligneFacture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneFactureCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneFactureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LigneFacture.
     * @param {LigneFactureDeleteArgs} args - Arguments to delete one LigneFacture.
     * @example
     * // Delete one LigneFacture
     * const LigneFacture = await prisma.ligneFacture.delete({
     *   where: {
     *     // ... filter to delete one LigneFacture
     *   }
     * })
     * 
     */
    delete<T extends LigneFactureDeleteArgs>(args: SelectSubset<T, LigneFactureDeleteArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LigneFacture.
     * @param {LigneFactureUpdateArgs} args - Arguments to update one LigneFacture.
     * @example
     * // Update one LigneFacture
     * const ligneFacture = await prisma.ligneFacture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneFactureUpdateArgs>(args: SelectSubset<T, LigneFactureUpdateArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LigneFactures.
     * @param {LigneFactureDeleteManyArgs} args - Arguments to filter LigneFactures to delete.
     * @example
     * // Delete a few LigneFactures
     * const { count } = await prisma.ligneFacture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneFactureDeleteManyArgs>(args?: SelectSubset<T, LigneFactureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneFactures
     * const ligneFacture = await prisma.ligneFacture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneFactureUpdateManyArgs>(args: SelectSubset<T, LigneFactureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneFactures and returns the data updated in the database.
     * @param {LigneFactureUpdateManyAndReturnArgs} args - Arguments to update many LigneFactures.
     * @example
     * // Update many LigneFactures
     * const ligneFacture = await prisma.ligneFacture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LigneFactures and only return the `id`
     * const ligneFactureWithIdOnly = await prisma.ligneFacture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LigneFactureUpdateManyAndReturnArgs>(args: SelectSubset<T, LigneFactureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LigneFacture.
     * @param {LigneFactureUpsertArgs} args - Arguments to update or create a LigneFacture.
     * @example
     * // Update or create a LigneFacture
     * const ligneFacture = await prisma.ligneFacture.upsert({
     *   create: {
     *     // ... data to create a LigneFacture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneFacture we want to update
     *   }
     * })
     */
    upsert<T extends LigneFactureUpsertArgs>(args: SelectSubset<T, LigneFactureUpsertArgs<ExtArgs>>): Prisma__LigneFactureClient<$Result.GetResult<Prisma.$LigneFacturePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LigneFactures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureCountArgs} args - Arguments to filter LigneFactures to count.
     * @example
     * // Count the number of LigneFactures
     * const count = await prisma.ligneFacture.count({
     *   where: {
     *     // ... the filter for the LigneFactures we want to count
     *   }
     * })
    **/
    count<T extends LigneFactureCountArgs>(
      args?: Subset<T, LigneFactureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneFactureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneFactureAggregateArgs>(args: Subset<T, LigneFactureAggregateArgs>): Prisma.PrismaPromise<GetLigneFactureAggregateType<T>>

    /**
     * Group by LigneFacture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneFactureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneFactureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneFactureGroupByArgs['orderBy'] }
        : { orderBy?: LigneFactureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneFactureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneFactureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneFacture model
   */
  readonly fields: LigneFactureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneFacture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneFactureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facture<T extends FactureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FactureDefaultArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneFacture model
   */ 
  interface LigneFactureFieldRefs {
    readonly id: FieldRef<"LigneFacture", 'String'>
    readonly factureId: FieldRef<"LigneFacture", 'String'>
    readonly designation: FieldRef<"LigneFacture", 'String'>
    readonly quantite: FieldRef<"LigneFacture", 'Int'>
    readonly prixUnitaire: FieldRef<"LigneFacture", 'Decimal'>
    readonly montant: FieldRef<"LigneFacture", 'Decimal'>
    readonly createdAt: FieldRef<"LigneFacture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LigneFacture findUnique
   */
  export type LigneFactureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which LigneFacture to fetch.
     */
    where: LigneFactureWhereUniqueInput
  }

  /**
   * LigneFacture findUniqueOrThrow
   */
  export type LigneFactureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which LigneFacture to fetch.
     */
    where: LigneFactureWhereUniqueInput
  }

  /**
   * LigneFacture findFirst
   */
  export type LigneFactureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which LigneFacture to fetch.
     */
    where?: LigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneFactures to fetch.
     */
    orderBy?: LigneFactureOrderByWithRelationInput | LigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneFactures.
     */
    cursor?: LigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneFactures.
     */
    distinct?: LigneFactureScalarFieldEnum | LigneFactureScalarFieldEnum[]
  }

  /**
   * LigneFacture findFirstOrThrow
   */
  export type LigneFactureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which LigneFacture to fetch.
     */
    where?: LigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneFactures to fetch.
     */
    orderBy?: LigneFactureOrderByWithRelationInput | LigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneFactures.
     */
    cursor?: LigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneFactures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneFactures.
     */
    distinct?: LigneFactureScalarFieldEnum | LigneFactureScalarFieldEnum[]
  }

  /**
   * LigneFacture findMany
   */
  export type LigneFactureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter, which LigneFactures to fetch.
     */
    where?: LigneFactureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneFactures to fetch.
     */
    orderBy?: LigneFactureOrderByWithRelationInput | LigneFactureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneFactures.
     */
    cursor?: LigneFactureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneFactures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneFactures.
     */
    skip?: number
    distinct?: LigneFactureScalarFieldEnum | LigneFactureScalarFieldEnum[]
  }

  /**
   * LigneFacture create
   */
  export type LigneFactureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneFacture.
     */
    data: XOR<LigneFactureCreateInput, LigneFactureUncheckedCreateInput>
  }

  /**
   * LigneFacture createMany
   */
  export type LigneFactureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneFactures.
     */
    data: LigneFactureCreateManyInput | LigneFactureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneFacture createManyAndReturn
   */
  export type LigneFactureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * The data used to create many LigneFactures.
     */
    data: LigneFactureCreateManyInput | LigneFactureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneFacture update
   */
  export type LigneFactureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneFacture.
     */
    data: XOR<LigneFactureUpdateInput, LigneFactureUncheckedUpdateInput>
    /**
     * Choose, which LigneFacture to update.
     */
    where: LigneFactureWhereUniqueInput
  }

  /**
   * LigneFacture updateMany
   */
  export type LigneFactureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneFactures.
     */
    data: XOR<LigneFactureUpdateManyMutationInput, LigneFactureUncheckedUpdateManyInput>
    /**
     * Filter which LigneFactures to update
     */
    where?: LigneFactureWhereInput
  }

  /**
   * LigneFacture updateManyAndReturn
   */
  export type LigneFactureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * The data used to update LigneFactures.
     */
    data: XOR<LigneFactureUpdateManyMutationInput, LigneFactureUncheckedUpdateManyInput>
    /**
     * Filter which LigneFactures to update
     */
    where?: LigneFactureWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneFacture upsert
   */
  export type LigneFactureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneFacture to update in case it exists.
     */
    where: LigneFactureWhereUniqueInput
    /**
     * In case the LigneFacture found by the `where` argument doesn't exist, create a new LigneFacture with this data.
     */
    create: XOR<LigneFactureCreateInput, LigneFactureUncheckedCreateInput>
    /**
     * In case the LigneFacture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneFactureUpdateInput, LigneFactureUncheckedUpdateInput>
  }

  /**
   * LigneFacture delete
   */
  export type LigneFactureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
    /**
     * Filter which LigneFacture to delete.
     */
    where: LigneFactureWhereUniqueInput
  }

  /**
   * LigneFacture deleteMany
   */
  export type LigneFactureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneFactures to delete
     */
    where?: LigneFactureWhereInput
  }

  /**
   * LigneFacture without action
   */
  export type LigneFactureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneFacture
     */
    select?: LigneFactureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneFacture
     */
    omit?: LigneFactureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneFactureInclude<ExtArgs> | null
  }


  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    montant: Decimal | null
  }

  export type PaiementSumAggregateOutputType = {
    montant: Decimal | null
  }

  export type PaiementMinAggregateOutputType = {
    id: string | null
    factureId: string | null
    datePaiement: Date | null
    montant: Decimal | null
    modePaiement: string | null
    reference: string | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: string | null
    factureId: string | null
    datePaiement: Date | null
    montant: Decimal | null
    modePaiement: string | null
    reference: string | null
    notes: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    factureId: number
    datePaiement: number
    montant: number
    modePaiement: number
    reference: number
    notes: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    montant?: true
  }

  export type PaiementSumAggregateInputType = {
    montant?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    factureId?: true
    datePaiement?: true
    montant?: true
    modePaiement?: true
    reference?: true
    notes?: true
    createdById?: true
    createdAt?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    factureId?: true
    datePaiement?: true
    montant?: true
    modePaiement?: true
    reference?: true
    notes?: true
    createdById?: true
    createdAt?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    factureId?: true
    datePaiement?: true
    montant?: true
    modePaiement?: true
    reference?: true
    notes?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: string
    factureId: string
    datePaiement: Date
    montant: Decimal
    modePaiement: string
    reference: string | null
    notes: string | null
    createdById: string
    createdAt: Date
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    datePaiement?: boolean
    montant?: boolean
    modePaiement?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    datePaiement?: boolean
    montant?: boolean
    modePaiement?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    factureId?: boolean
    datePaiement?: boolean
    montant?: boolean
    modePaiement?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectScalar = {
    id?: boolean
    factureId?: boolean
    datePaiement?: boolean
    montant?: boolean
    modePaiement?: boolean
    reference?: boolean
    notes?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type PaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "factureId" | "datePaiement" | "montant" | "modePaiement" | "reference" | "notes" | "createdById" | "createdAt", ExtArgs["result"]["paiement"]>
  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    facture?: boolean | FactureDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      facture: Prisma.$FacturePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      factureId: string
      datePaiement: Date
      montant: Prisma.Decimal
      modePaiement: string
      reference: string | null
      notes: string | null
      createdById: string
      createdAt: Date
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }

  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaiementFindUniqueArgs>(args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Paiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaiementFindFirstArgs>(args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaiementFindManyArgs>(args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
     */
    create<T extends PaiementCreateArgs>(args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Paiements.
     * @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaiementCreateManyArgs>(args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paiements and returns the data saved in the database.
     * @param {PaiementCreateManyAndReturnArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaiementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaiementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
     */
    delete<T extends PaiementDeleteArgs>(args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaiementUpdateArgs>(args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaiementDeleteManyArgs>(args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaiementUpdateManyArgs>(args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements and returns the data updated in the database.
     * @param {PaiementUpdateManyAndReturnArgs} args - Arguments to update many Paiements.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaiementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaiementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
     */
    upsert<T extends PaiementUpsertArgs>(args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    facture<T extends FactureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FactureDefaultArgs<ExtArgs>>): Prisma__FactureClient<$Result.GetResult<Prisma.$FacturePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paiement model
   */ 
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'String'>
    readonly factureId: FieldRef<"Paiement", 'String'>
    readonly datePaiement: FieldRef<"Paiement", 'DateTime'>
    readonly montant: FieldRef<"Paiement", 'Decimal'>
    readonly modePaiement: FieldRef<"Paiement", 'String'>
    readonly reference: FieldRef<"Paiement", 'String'>
    readonly notes: FieldRef<"Paiement", 'String'>
    readonly createdById: FieldRef<"Paiement", 'String'>
    readonly createdAt: FieldRef<"Paiement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }

  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paiement createManyAndReturn
   */
  export type PaiementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
  }

  /**
   * Paiement updateManyAndReturn
   */
  export type PaiementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }

  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
  }

  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
  }


  /**
   * Model Lit
   */

  export type AggregateLit = {
    _count: LitCountAggregateOutputType | null
    _avg: LitAvgAggregateOutputType | null
    _sum: LitSumAggregateOutputType | null
    _min: LitMinAggregateOutputType | null
    _max: LitMaxAggregateOutputType | null
  }

  export type LitAvgAggregateOutputType = {
    prixJournalier: Decimal | null
  }

  export type LitSumAggregateOutputType = {
    prixJournalier: Decimal | null
  }

  export type LitMinAggregateOutputType = {
    id: string | null
    numero: string | null
    chambre: string | null
    service: string | null
    categorie: string | null
    prixJournalier: Decimal | null
    occupe: boolean | null
    createdAt: Date | null
  }

  export type LitMaxAggregateOutputType = {
    id: string | null
    numero: string | null
    chambre: string | null
    service: string | null
    categorie: string | null
    prixJournalier: Decimal | null
    occupe: boolean | null
    createdAt: Date | null
  }

  export type LitCountAggregateOutputType = {
    id: number
    numero: number
    chambre: number
    service: number
    categorie: number
    prixJournalier: number
    occupe: number
    createdAt: number
    _all: number
  }


  export type LitAvgAggregateInputType = {
    prixJournalier?: true
  }

  export type LitSumAggregateInputType = {
    prixJournalier?: true
  }

  export type LitMinAggregateInputType = {
    id?: true
    numero?: true
    chambre?: true
    service?: true
    categorie?: true
    prixJournalier?: true
    occupe?: true
    createdAt?: true
  }

  export type LitMaxAggregateInputType = {
    id?: true
    numero?: true
    chambre?: true
    service?: true
    categorie?: true
    prixJournalier?: true
    occupe?: true
    createdAt?: true
  }

  export type LitCountAggregateInputType = {
    id?: true
    numero?: true
    chambre?: true
    service?: true
    categorie?: true
    prixJournalier?: true
    occupe?: true
    createdAt?: true
    _all?: true
  }

  export type LitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lit to aggregate.
     */
    where?: LitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lits to fetch.
     */
    orderBy?: LitOrderByWithRelationInput | LitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lits
    **/
    _count?: true | LitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LitMaxAggregateInputType
  }

  export type GetLitAggregateType<T extends LitAggregateArgs> = {
        [P in keyof T & keyof AggregateLit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLit[P]>
      : GetScalarType<T[P], AggregateLit[P]>
  }




  export type LitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LitWhereInput
    orderBy?: LitOrderByWithAggregationInput | LitOrderByWithAggregationInput[]
    by: LitScalarFieldEnum[] | LitScalarFieldEnum
    having?: LitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LitCountAggregateInputType | true
    _avg?: LitAvgAggregateInputType
    _sum?: LitSumAggregateInputType
    _min?: LitMinAggregateInputType
    _max?: LitMaxAggregateInputType
  }

  export type LitGroupByOutputType = {
    id: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal
    occupe: boolean
    createdAt: Date
    _count: LitCountAggregateOutputType | null
    _avg: LitAvgAggregateOutputType | null
    _sum: LitSumAggregateOutputType | null
    _min: LitMinAggregateOutputType | null
    _max: LitMaxAggregateOutputType | null
  }

  type GetLitGroupByPayload<T extends LitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LitGroupByOutputType[P]>
            : GetScalarType<T[P], LitGroupByOutputType[P]>
        }
      >
    >


  export type LitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    chambre?: boolean
    service?: boolean
    categorie?: boolean
    prixJournalier?: boolean
    occupe?: boolean
    createdAt?: boolean
    hospitalisations?: boolean | Lit$hospitalisationsArgs<ExtArgs>
    _count?: boolean | LitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lit"]>

  export type LitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    chambre?: boolean
    service?: boolean
    categorie?: boolean
    prixJournalier?: boolean
    occupe?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lit"]>

  export type LitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numero?: boolean
    chambre?: boolean
    service?: boolean
    categorie?: boolean
    prixJournalier?: boolean
    occupe?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lit"]>

  export type LitSelectScalar = {
    id?: boolean
    numero?: boolean
    chambre?: boolean
    service?: boolean
    categorie?: boolean
    prixJournalier?: boolean
    occupe?: boolean
    createdAt?: boolean
  }

  export type LitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "numero" | "chambre" | "service" | "categorie" | "prixJournalier" | "occupe" | "createdAt", ExtArgs["result"]["lit"]>
  export type LitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospitalisations?: boolean | Lit$hospitalisationsArgs<ExtArgs>
    _count?: boolean | LitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lit"
    objects: {
      hospitalisations: Prisma.$HospitalisationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numero: string
      chambre: string
      service: string
      categorie: string
      prixJournalier: Prisma.Decimal
      occupe: boolean
      createdAt: Date
    }, ExtArgs["result"]["lit"]>
    composites: {}
  }

  type LitGetPayload<S extends boolean | null | undefined | LitDefaultArgs> = $Result.GetResult<Prisma.$LitPayload, S>

  type LitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LitCountAggregateInputType | true
    }

  export interface LitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lit'], meta: { name: 'Lit' } }
    /**
     * Find zero or one Lit that matches the filter.
     * @param {LitFindUniqueArgs} args - Arguments to find a Lit
     * @example
     * // Get one Lit
     * const lit = await prisma.lit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LitFindUniqueArgs>(args: SelectSubset<T, LitFindUniqueArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Lit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LitFindUniqueOrThrowArgs} args - Arguments to find a Lit
     * @example
     * // Get one Lit
     * const lit = await prisma.lit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LitFindUniqueOrThrowArgs>(args: SelectSubset<T, LitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Lit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitFindFirstArgs} args - Arguments to find a Lit
     * @example
     * // Get one Lit
     * const lit = await prisma.lit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LitFindFirstArgs>(args?: SelectSubset<T, LitFindFirstArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Lit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitFindFirstOrThrowArgs} args - Arguments to find a Lit
     * @example
     * // Get one Lit
     * const lit = await prisma.lit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LitFindFirstOrThrowArgs>(args?: SelectSubset<T, LitFindFirstOrThrowArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Lits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lits
     * const lits = await prisma.lit.findMany()
     * 
     * // Get first 10 Lits
     * const lits = await prisma.lit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const litWithIdOnly = await prisma.lit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LitFindManyArgs>(args?: SelectSubset<T, LitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Lit.
     * @param {LitCreateArgs} args - Arguments to create a Lit.
     * @example
     * // Create one Lit
     * const Lit = await prisma.lit.create({
     *   data: {
     *     // ... data to create a Lit
     *   }
     * })
     * 
     */
    create<T extends LitCreateArgs>(args: SelectSubset<T, LitCreateArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Lits.
     * @param {LitCreateManyArgs} args - Arguments to create many Lits.
     * @example
     * // Create many Lits
     * const lit = await prisma.lit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LitCreateManyArgs>(args?: SelectSubset<T, LitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lits and returns the data saved in the database.
     * @param {LitCreateManyAndReturnArgs} args - Arguments to create many Lits.
     * @example
     * // Create many Lits
     * const lit = await prisma.lit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lits and only return the `id`
     * const litWithIdOnly = await prisma.lit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LitCreateManyAndReturnArgs>(args?: SelectSubset<T, LitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Lit.
     * @param {LitDeleteArgs} args - Arguments to delete one Lit.
     * @example
     * // Delete one Lit
     * const Lit = await prisma.lit.delete({
     *   where: {
     *     // ... filter to delete one Lit
     *   }
     * })
     * 
     */
    delete<T extends LitDeleteArgs>(args: SelectSubset<T, LitDeleteArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Lit.
     * @param {LitUpdateArgs} args - Arguments to update one Lit.
     * @example
     * // Update one Lit
     * const lit = await prisma.lit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LitUpdateArgs>(args: SelectSubset<T, LitUpdateArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Lits.
     * @param {LitDeleteManyArgs} args - Arguments to filter Lits to delete.
     * @example
     * // Delete a few Lits
     * const { count } = await prisma.lit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LitDeleteManyArgs>(args?: SelectSubset<T, LitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lits
     * const lit = await prisma.lit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LitUpdateManyArgs>(args: SelectSubset<T, LitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lits and returns the data updated in the database.
     * @param {LitUpdateManyAndReturnArgs} args - Arguments to update many Lits.
     * @example
     * // Update many Lits
     * const lit = await prisma.lit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lits and only return the `id`
     * const litWithIdOnly = await prisma.lit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LitUpdateManyAndReturnArgs>(args: SelectSubset<T, LitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Lit.
     * @param {LitUpsertArgs} args - Arguments to update or create a Lit.
     * @example
     * // Update or create a Lit
     * const lit = await prisma.lit.upsert({
     *   create: {
     *     // ... data to create a Lit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lit we want to update
     *   }
     * })
     */
    upsert<T extends LitUpsertArgs>(args: SelectSubset<T, LitUpsertArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Lits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitCountArgs} args - Arguments to filter Lits to count.
     * @example
     * // Count the number of Lits
     * const count = await prisma.lit.count({
     *   where: {
     *     // ... the filter for the Lits we want to count
     *   }
     * })
    **/
    count<T extends LitCountArgs>(
      args?: Subset<T, LitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LitAggregateArgs>(args: Subset<T, LitAggregateArgs>): Prisma.PrismaPromise<GetLitAggregateType<T>>

    /**
     * Group by Lit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LitGroupByArgs['orderBy'] }
        : { orderBy?: LitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lit model
   */
  readonly fields: LitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hospitalisations<T extends Lit$hospitalisationsArgs<ExtArgs> = {}>(args?: Subset<T, Lit$hospitalisationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lit model
   */ 
  interface LitFieldRefs {
    readonly id: FieldRef<"Lit", 'String'>
    readonly numero: FieldRef<"Lit", 'String'>
    readonly chambre: FieldRef<"Lit", 'String'>
    readonly service: FieldRef<"Lit", 'String'>
    readonly categorie: FieldRef<"Lit", 'String'>
    readonly prixJournalier: FieldRef<"Lit", 'Decimal'>
    readonly occupe: FieldRef<"Lit", 'Boolean'>
    readonly createdAt: FieldRef<"Lit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lit findUnique
   */
  export type LitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter, which Lit to fetch.
     */
    where: LitWhereUniqueInput
  }

  /**
   * Lit findUniqueOrThrow
   */
  export type LitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter, which Lit to fetch.
     */
    where: LitWhereUniqueInput
  }

  /**
   * Lit findFirst
   */
  export type LitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter, which Lit to fetch.
     */
    where?: LitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lits to fetch.
     */
    orderBy?: LitOrderByWithRelationInput | LitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lits.
     */
    cursor?: LitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lits.
     */
    distinct?: LitScalarFieldEnum | LitScalarFieldEnum[]
  }

  /**
   * Lit findFirstOrThrow
   */
  export type LitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter, which Lit to fetch.
     */
    where?: LitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lits to fetch.
     */
    orderBy?: LitOrderByWithRelationInput | LitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lits.
     */
    cursor?: LitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lits.
     */
    distinct?: LitScalarFieldEnum | LitScalarFieldEnum[]
  }

  /**
   * Lit findMany
   */
  export type LitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter, which Lits to fetch.
     */
    where?: LitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lits to fetch.
     */
    orderBy?: LitOrderByWithRelationInput | LitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lits.
     */
    cursor?: LitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lits.
     */
    skip?: number
    distinct?: LitScalarFieldEnum | LitScalarFieldEnum[]
  }

  /**
   * Lit create
   */
  export type LitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * The data needed to create a Lit.
     */
    data: XOR<LitCreateInput, LitUncheckedCreateInput>
  }

  /**
   * Lit createMany
   */
  export type LitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lits.
     */
    data: LitCreateManyInput | LitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lit createManyAndReturn
   */
  export type LitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * The data used to create many Lits.
     */
    data: LitCreateManyInput | LitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lit update
   */
  export type LitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * The data needed to update a Lit.
     */
    data: XOR<LitUpdateInput, LitUncheckedUpdateInput>
    /**
     * Choose, which Lit to update.
     */
    where: LitWhereUniqueInput
  }

  /**
   * Lit updateMany
   */
  export type LitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lits.
     */
    data: XOR<LitUpdateManyMutationInput, LitUncheckedUpdateManyInput>
    /**
     * Filter which Lits to update
     */
    where?: LitWhereInput
  }

  /**
   * Lit updateManyAndReturn
   */
  export type LitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * The data used to update Lits.
     */
    data: XOR<LitUpdateManyMutationInput, LitUncheckedUpdateManyInput>
    /**
     * Filter which Lits to update
     */
    where?: LitWhereInput
  }

  /**
   * Lit upsert
   */
  export type LitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * The filter to search for the Lit to update in case it exists.
     */
    where: LitWhereUniqueInput
    /**
     * In case the Lit found by the `where` argument doesn't exist, create a new Lit with this data.
     */
    create: XOR<LitCreateInput, LitUncheckedCreateInput>
    /**
     * In case the Lit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LitUpdateInput, LitUncheckedUpdateInput>
  }

  /**
   * Lit delete
   */
  export type LitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
    /**
     * Filter which Lit to delete.
     */
    where: LitWhereUniqueInput
  }

  /**
   * Lit deleteMany
   */
  export type LitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lits to delete
     */
    where?: LitWhereInput
  }

  /**
   * Lit.hospitalisations
   */
  export type Lit$hospitalisationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    where?: HospitalisationWhereInput
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    cursor?: HospitalisationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HospitalisationScalarFieldEnum | HospitalisationScalarFieldEnum[]
  }

  /**
   * Lit without action
   */
  export type LitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lit
     */
    select?: LitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lit
     */
    omit?: LitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LitInclude<ExtArgs> | null
  }


  /**
   * Model Hospitalisation
   */

  export type AggregateHospitalisation = {
    _count: HospitalisationCountAggregateOutputType | null
    _min: HospitalisationMinAggregateOutputType | null
    _max: HospitalisationMaxAggregateOutputType | null
  }

  export type HospitalisationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    litId: string | null
    dateEntree: Date | null
    dateSortie: Date | null
    motif: string | null
    diagnosticEntree: string | null
    diagnosticSortie: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalisationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    litId: string | null
    dateEntree: Date | null
    dateSortie: Date | null
    motif: string | null
    diagnosticEntree: string | null
    diagnosticSortie: string | null
    statut: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HospitalisationCountAggregateOutputType = {
    id: number
    patientId: number
    litId: number
    dateEntree: number
    dateSortie: number
    motif: number
    diagnosticEntree: number
    diagnosticSortie: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HospitalisationMinAggregateInputType = {
    id?: true
    patientId?: true
    litId?: true
    dateEntree?: true
    dateSortie?: true
    motif?: true
    diagnosticEntree?: true
    diagnosticSortie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalisationMaxAggregateInputType = {
    id?: true
    patientId?: true
    litId?: true
    dateEntree?: true
    dateSortie?: true
    motif?: true
    diagnosticEntree?: true
    diagnosticSortie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HospitalisationCountAggregateInputType = {
    id?: true
    patientId?: true
    litId?: true
    dateEntree?: true
    dateSortie?: true
    motif?: true
    diagnosticEntree?: true
    diagnosticSortie?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HospitalisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitalisation to aggregate.
     */
    where?: HospitalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitalisations to fetch.
     */
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HospitalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hospitalisations
    **/
    _count?: true | HospitalisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HospitalisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HospitalisationMaxAggregateInputType
  }

  export type GetHospitalisationAggregateType<T extends HospitalisationAggregateArgs> = {
        [P in keyof T & keyof AggregateHospitalisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHospitalisation[P]>
      : GetScalarType<T[P], AggregateHospitalisation[P]>
  }




  export type HospitalisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HospitalisationWhereInput
    orderBy?: HospitalisationOrderByWithAggregationInput | HospitalisationOrderByWithAggregationInput[]
    by: HospitalisationScalarFieldEnum[] | HospitalisationScalarFieldEnum
    having?: HospitalisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HospitalisationCountAggregateInputType | true
    _min?: HospitalisationMinAggregateInputType
    _max?: HospitalisationMaxAggregateInputType
  }

  export type HospitalisationGroupByOutputType = {
    id: string
    patientId: string
    litId: string
    dateEntree: Date
    dateSortie: Date | null
    motif: string
    diagnosticEntree: string | null
    diagnosticSortie: string | null
    statut: string
    createdAt: Date
    updatedAt: Date
    _count: HospitalisationCountAggregateOutputType | null
    _min: HospitalisationMinAggregateOutputType | null
    _max: HospitalisationMaxAggregateOutputType | null
  }

  type GetHospitalisationGroupByPayload<T extends HospitalisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HospitalisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HospitalisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HospitalisationGroupByOutputType[P]>
            : GetScalarType<T[P], HospitalisationGroupByOutputType[P]>
        }
      >
    >


  export type HospitalisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    litId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    motif?: boolean
    diagnosticEntree?: boolean
    diagnosticSortie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
    observations?: boolean | Hospitalisation$observationsArgs<ExtArgs>
    _count?: boolean | HospitalisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospitalisation"]>

  export type HospitalisationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    litId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    motif?: boolean
    diagnosticEntree?: boolean
    diagnosticSortie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospitalisation"]>

  export type HospitalisationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    litId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    motif?: boolean
    diagnosticEntree?: boolean
    diagnosticSortie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hospitalisation"]>

  export type HospitalisationSelectScalar = {
    id?: boolean
    patientId?: boolean
    litId?: boolean
    dateEntree?: boolean
    dateSortie?: boolean
    motif?: boolean
    diagnosticEntree?: boolean
    diagnosticSortie?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HospitalisationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "litId" | "dateEntree" | "dateSortie" | "motif" | "diagnosticEntree" | "diagnosticSortie" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["hospitalisation"]>
  export type HospitalisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
    observations?: boolean | Hospitalisation$observationsArgs<ExtArgs>
    _count?: boolean | HospitalisationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HospitalisationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
  }
  export type HospitalisationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    lit?: boolean | LitDefaultArgs<ExtArgs>
  }

  export type $HospitalisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hospitalisation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      lit: Prisma.$LitPayload<ExtArgs>
      observations: Prisma.$ObservationInfirmierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      litId: string
      dateEntree: Date
      dateSortie: Date | null
      motif: string
      diagnosticEntree: string | null
      diagnosticSortie: string | null
      statut: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hospitalisation"]>
    composites: {}
  }

  type HospitalisationGetPayload<S extends boolean | null | undefined | HospitalisationDefaultArgs> = $Result.GetResult<Prisma.$HospitalisationPayload, S>

  type HospitalisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HospitalisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HospitalisationCountAggregateInputType | true
    }

  export interface HospitalisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hospitalisation'], meta: { name: 'Hospitalisation' } }
    /**
     * Find zero or one Hospitalisation that matches the filter.
     * @param {HospitalisationFindUniqueArgs} args - Arguments to find a Hospitalisation
     * @example
     * // Get one Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HospitalisationFindUniqueArgs>(args: SelectSubset<T, HospitalisationFindUniqueArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Hospitalisation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HospitalisationFindUniqueOrThrowArgs} args - Arguments to find a Hospitalisation
     * @example
     * // Get one Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HospitalisationFindUniqueOrThrowArgs>(args: SelectSubset<T, HospitalisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Hospitalisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationFindFirstArgs} args - Arguments to find a Hospitalisation
     * @example
     * // Get one Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HospitalisationFindFirstArgs>(args?: SelectSubset<T, HospitalisationFindFirstArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Hospitalisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationFindFirstOrThrowArgs} args - Arguments to find a Hospitalisation
     * @example
     * // Get one Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HospitalisationFindFirstOrThrowArgs>(args?: SelectSubset<T, HospitalisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Hospitalisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hospitalisations
     * const hospitalisations = await prisma.hospitalisation.findMany()
     * 
     * // Get first 10 Hospitalisations
     * const hospitalisations = await prisma.hospitalisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hospitalisationWithIdOnly = await prisma.hospitalisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HospitalisationFindManyArgs>(args?: SelectSubset<T, HospitalisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Hospitalisation.
     * @param {HospitalisationCreateArgs} args - Arguments to create a Hospitalisation.
     * @example
     * // Create one Hospitalisation
     * const Hospitalisation = await prisma.hospitalisation.create({
     *   data: {
     *     // ... data to create a Hospitalisation
     *   }
     * })
     * 
     */
    create<T extends HospitalisationCreateArgs>(args: SelectSubset<T, HospitalisationCreateArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Hospitalisations.
     * @param {HospitalisationCreateManyArgs} args - Arguments to create many Hospitalisations.
     * @example
     * // Create many Hospitalisations
     * const hospitalisation = await prisma.hospitalisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HospitalisationCreateManyArgs>(args?: SelectSubset<T, HospitalisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hospitalisations and returns the data saved in the database.
     * @param {HospitalisationCreateManyAndReturnArgs} args - Arguments to create many Hospitalisations.
     * @example
     * // Create many Hospitalisations
     * const hospitalisation = await prisma.hospitalisation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hospitalisations and only return the `id`
     * const hospitalisationWithIdOnly = await prisma.hospitalisation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HospitalisationCreateManyAndReturnArgs>(args?: SelectSubset<T, HospitalisationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Hospitalisation.
     * @param {HospitalisationDeleteArgs} args - Arguments to delete one Hospitalisation.
     * @example
     * // Delete one Hospitalisation
     * const Hospitalisation = await prisma.hospitalisation.delete({
     *   where: {
     *     // ... filter to delete one Hospitalisation
     *   }
     * })
     * 
     */
    delete<T extends HospitalisationDeleteArgs>(args: SelectSubset<T, HospitalisationDeleteArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Hospitalisation.
     * @param {HospitalisationUpdateArgs} args - Arguments to update one Hospitalisation.
     * @example
     * // Update one Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HospitalisationUpdateArgs>(args: SelectSubset<T, HospitalisationUpdateArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Hospitalisations.
     * @param {HospitalisationDeleteManyArgs} args - Arguments to filter Hospitalisations to delete.
     * @example
     * // Delete a few Hospitalisations
     * const { count } = await prisma.hospitalisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HospitalisationDeleteManyArgs>(args?: SelectSubset<T, HospitalisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitalisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hospitalisations
     * const hospitalisation = await prisma.hospitalisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HospitalisationUpdateManyArgs>(args: SelectSubset<T, HospitalisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hospitalisations and returns the data updated in the database.
     * @param {HospitalisationUpdateManyAndReturnArgs} args - Arguments to update many Hospitalisations.
     * @example
     * // Update many Hospitalisations
     * const hospitalisation = await prisma.hospitalisation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hospitalisations and only return the `id`
     * const hospitalisationWithIdOnly = await prisma.hospitalisation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HospitalisationUpdateManyAndReturnArgs>(args: SelectSubset<T, HospitalisationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Hospitalisation.
     * @param {HospitalisationUpsertArgs} args - Arguments to update or create a Hospitalisation.
     * @example
     * // Update or create a Hospitalisation
     * const hospitalisation = await prisma.hospitalisation.upsert({
     *   create: {
     *     // ... data to create a Hospitalisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hospitalisation we want to update
     *   }
     * })
     */
    upsert<T extends HospitalisationUpsertArgs>(args: SelectSubset<T, HospitalisationUpsertArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Hospitalisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationCountArgs} args - Arguments to filter Hospitalisations to count.
     * @example
     * // Count the number of Hospitalisations
     * const count = await prisma.hospitalisation.count({
     *   where: {
     *     // ... the filter for the Hospitalisations we want to count
     *   }
     * })
    **/
    count<T extends HospitalisationCountArgs>(
      args?: Subset<T, HospitalisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HospitalisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hospitalisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HospitalisationAggregateArgs>(args: Subset<T, HospitalisationAggregateArgs>): Prisma.PrismaPromise<GetHospitalisationAggregateType<T>>

    /**
     * Group by Hospitalisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HospitalisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HospitalisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HospitalisationGroupByArgs['orderBy'] }
        : { orderBy?: HospitalisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HospitalisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHospitalisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hospitalisation model
   */
  readonly fields: HospitalisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hospitalisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HospitalisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    lit<T extends LitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LitDefaultArgs<ExtArgs>>): Prisma__LitClient<$Result.GetResult<Prisma.$LitPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    observations<T extends Hospitalisation$observationsArgs<ExtArgs> = {}>(args?: Subset<T, Hospitalisation$observationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hospitalisation model
   */ 
  interface HospitalisationFieldRefs {
    readonly id: FieldRef<"Hospitalisation", 'String'>
    readonly patientId: FieldRef<"Hospitalisation", 'String'>
    readonly litId: FieldRef<"Hospitalisation", 'String'>
    readonly dateEntree: FieldRef<"Hospitalisation", 'DateTime'>
    readonly dateSortie: FieldRef<"Hospitalisation", 'DateTime'>
    readonly motif: FieldRef<"Hospitalisation", 'String'>
    readonly diagnosticEntree: FieldRef<"Hospitalisation", 'String'>
    readonly diagnosticSortie: FieldRef<"Hospitalisation", 'String'>
    readonly statut: FieldRef<"Hospitalisation", 'String'>
    readonly createdAt: FieldRef<"Hospitalisation", 'DateTime'>
    readonly updatedAt: FieldRef<"Hospitalisation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hospitalisation findUnique
   */
  export type HospitalisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter, which Hospitalisation to fetch.
     */
    where: HospitalisationWhereUniqueInput
  }

  /**
   * Hospitalisation findUniqueOrThrow
   */
  export type HospitalisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter, which Hospitalisation to fetch.
     */
    where: HospitalisationWhereUniqueInput
  }

  /**
   * Hospitalisation findFirst
   */
  export type HospitalisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter, which Hospitalisation to fetch.
     */
    where?: HospitalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitalisations to fetch.
     */
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitalisations.
     */
    cursor?: HospitalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitalisations.
     */
    distinct?: HospitalisationScalarFieldEnum | HospitalisationScalarFieldEnum[]
  }

  /**
   * Hospitalisation findFirstOrThrow
   */
  export type HospitalisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter, which Hospitalisation to fetch.
     */
    where?: HospitalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitalisations to fetch.
     */
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hospitalisations.
     */
    cursor?: HospitalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitalisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hospitalisations.
     */
    distinct?: HospitalisationScalarFieldEnum | HospitalisationScalarFieldEnum[]
  }

  /**
   * Hospitalisation findMany
   */
  export type HospitalisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter, which Hospitalisations to fetch.
     */
    where?: HospitalisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hospitalisations to fetch.
     */
    orderBy?: HospitalisationOrderByWithRelationInput | HospitalisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hospitalisations.
     */
    cursor?: HospitalisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hospitalisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hospitalisations.
     */
    skip?: number
    distinct?: HospitalisationScalarFieldEnum | HospitalisationScalarFieldEnum[]
  }

  /**
   * Hospitalisation create
   */
  export type HospitalisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * The data needed to create a Hospitalisation.
     */
    data: XOR<HospitalisationCreateInput, HospitalisationUncheckedCreateInput>
  }

  /**
   * Hospitalisation createMany
   */
  export type HospitalisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hospitalisations.
     */
    data: HospitalisationCreateManyInput | HospitalisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hospitalisation createManyAndReturn
   */
  export type HospitalisationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * The data used to create many Hospitalisations.
     */
    data: HospitalisationCreateManyInput | HospitalisationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospitalisation update
   */
  export type HospitalisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * The data needed to update a Hospitalisation.
     */
    data: XOR<HospitalisationUpdateInput, HospitalisationUncheckedUpdateInput>
    /**
     * Choose, which Hospitalisation to update.
     */
    where: HospitalisationWhereUniqueInput
  }

  /**
   * Hospitalisation updateMany
   */
  export type HospitalisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hospitalisations.
     */
    data: XOR<HospitalisationUpdateManyMutationInput, HospitalisationUncheckedUpdateManyInput>
    /**
     * Filter which Hospitalisations to update
     */
    where?: HospitalisationWhereInput
  }

  /**
   * Hospitalisation updateManyAndReturn
   */
  export type HospitalisationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * The data used to update Hospitalisations.
     */
    data: XOR<HospitalisationUpdateManyMutationInput, HospitalisationUncheckedUpdateManyInput>
    /**
     * Filter which Hospitalisations to update
     */
    where?: HospitalisationWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hospitalisation upsert
   */
  export type HospitalisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * The filter to search for the Hospitalisation to update in case it exists.
     */
    where: HospitalisationWhereUniqueInput
    /**
     * In case the Hospitalisation found by the `where` argument doesn't exist, create a new Hospitalisation with this data.
     */
    create: XOR<HospitalisationCreateInput, HospitalisationUncheckedCreateInput>
    /**
     * In case the Hospitalisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HospitalisationUpdateInput, HospitalisationUncheckedUpdateInput>
  }

  /**
   * Hospitalisation delete
   */
  export type HospitalisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
    /**
     * Filter which Hospitalisation to delete.
     */
    where: HospitalisationWhereUniqueInput
  }

  /**
   * Hospitalisation deleteMany
   */
  export type HospitalisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hospitalisations to delete
     */
    where?: HospitalisationWhereInput
  }

  /**
   * Hospitalisation.observations
   */
  export type Hospitalisation$observationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    where?: ObservationInfirmierWhereInput
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    cursor?: ObservationInfirmierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationInfirmierScalarFieldEnum | ObservationInfirmierScalarFieldEnum[]
  }

  /**
   * Hospitalisation without action
   */
  export type HospitalisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hospitalisation
     */
    select?: HospitalisationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hospitalisation
     */
    omit?: HospitalisationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HospitalisationInclude<ExtArgs> | null
  }


  /**
   * Model ObservationInfirmier
   */

  export type AggregateObservationInfirmier = {
    _count: ObservationInfirmierCountAggregateOutputType | null
    _avg: ObservationInfirmierAvgAggregateOutputType | null
    _sum: ObservationInfirmierSumAggregateOutputType | null
    _min: ObservationInfirmierMinAggregateOutputType | null
    _max: ObservationInfirmierMaxAggregateOutputType | null
  }

  export type ObservationInfirmierAvgAggregateOutputType = {
    temperature: Decimal | null
  }

  export type ObservationInfirmierSumAggregateOutputType = {
    temperature: Decimal | null
  }

  export type ObservationInfirmierMinAggregateOutputType = {
    id: string | null
    hospitalisationId: string | null
    infirmierId: string | null
    pressionArterielle: string | null
    temperature: Decimal | null
    note: string | null
    dateHeure: Date | null
  }

  export type ObservationInfirmierMaxAggregateOutputType = {
    id: string | null
    hospitalisationId: string | null
    infirmierId: string | null
    pressionArterielle: string | null
    temperature: Decimal | null
    note: string | null
    dateHeure: Date | null
  }

  export type ObservationInfirmierCountAggregateOutputType = {
    id: number
    hospitalisationId: number
    infirmierId: number
    pressionArterielle: number
    temperature: number
    note: number
    dateHeure: number
    _all: number
  }


  export type ObservationInfirmierAvgAggregateInputType = {
    temperature?: true
  }

  export type ObservationInfirmierSumAggregateInputType = {
    temperature?: true
  }

  export type ObservationInfirmierMinAggregateInputType = {
    id?: true
    hospitalisationId?: true
    infirmierId?: true
    pressionArterielle?: true
    temperature?: true
    note?: true
    dateHeure?: true
  }

  export type ObservationInfirmierMaxAggregateInputType = {
    id?: true
    hospitalisationId?: true
    infirmierId?: true
    pressionArterielle?: true
    temperature?: true
    note?: true
    dateHeure?: true
  }

  export type ObservationInfirmierCountAggregateInputType = {
    id?: true
    hospitalisationId?: true
    infirmierId?: true
    pressionArterielle?: true
    temperature?: true
    note?: true
    dateHeure?: true
    _all?: true
  }

  export type ObservationInfirmierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationInfirmier to aggregate.
     */
    where?: ObservationInfirmierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationInfirmiers to fetch.
     */
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationInfirmierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationInfirmiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationInfirmiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObservationInfirmiers
    **/
    _count?: true | ObservationInfirmierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObservationInfirmierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObservationInfirmierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationInfirmierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationInfirmierMaxAggregateInputType
  }

  export type GetObservationInfirmierAggregateType<T extends ObservationInfirmierAggregateArgs> = {
        [P in keyof T & keyof AggregateObservationInfirmier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservationInfirmier[P]>
      : GetScalarType<T[P], AggregateObservationInfirmier[P]>
  }




  export type ObservationInfirmierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationInfirmierWhereInput
    orderBy?: ObservationInfirmierOrderByWithAggregationInput | ObservationInfirmierOrderByWithAggregationInput[]
    by: ObservationInfirmierScalarFieldEnum[] | ObservationInfirmierScalarFieldEnum
    having?: ObservationInfirmierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationInfirmierCountAggregateInputType | true
    _avg?: ObservationInfirmierAvgAggregateInputType
    _sum?: ObservationInfirmierSumAggregateInputType
    _min?: ObservationInfirmierMinAggregateInputType
    _max?: ObservationInfirmierMaxAggregateInputType
  }

  export type ObservationInfirmierGroupByOutputType = {
    id: string
    hospitalisationId: string
    infirmierId: string
    pressionArterielle: string | null
    temperature: Decimal | null
    note: string
    dateHeure: Date
    _count: ObservationInfirmierCountAggregateOutputType | null
    _avg: ObservationInfirmierAvgAggregateOutputType | null
    _sum: ObservationInfirmierSumAggregateOutputType | null
    _min: ObservationInfirmierMinAggregateOutputType | null
    _max: ObservationInfirmierMaxAggregateOutputType | null
  }

  type GetObservationInfirmierGroupByPayload<T extends ObservationInfirmierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationInfirmierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationInfirmierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationInfirmierGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationInfirmierGroupByOutputType[P]>
        }
      >
    >


  export type ObservationInfirmierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalisationId?: boolean
    infirmierId?: boolean
    pressionArterielle?: boolean
    temperature?: boolean
    note?: boolean
    dateHeure?: boolean
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observationInfirmier"]>

  export type ObservationInfirmierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalisationId?: boolean
    infirmierId?: boolean
    pressionArterielle?: boolean
    temperature?: boolean
    note?: boolean
    dateHeure?: boolean
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observationInfirmier"]>

  export type ObservationInfirmierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hospitalisationId?: boolean
    infirmierId?: boolean
    pressionArterielle?: boolean
    temperature?: boolean
    note?: boolean
    dateHeure?: boolean
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observationInfirmier"]>

  export type ObservationInfirmierSelectScalar = {
    id?: boolean
    hospitalisationId?: boolean
    infirmierId?: boolean
    pressionArterielle?: boolean
    temperature?: boolean
    note?: boolean
    dateHeure?: boolean
  }

  export type ObservationInfirmierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hospitalisationId" | "infirmierId" | "pressionArterielle" | "temperature" | "note" | "dateHeure", ExtArgs["result"]["observationInfirmier"]>
  export type ObservationInfirmierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ObservationInfirmierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ObservationInfirmierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hospitalisation?: boolean | HospitalisationDefaultArgs<ExtArgs>
    infirmier?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ObservationInfirmierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObservationInfirmier"
    objects: {
      hospitalisation: Prisma.$HospitalisationPayload<ExtArgs>
      infirmier: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hospitalisationId: string
      infirmierId: string
      pressionArterielle: string | null
      temperature: Prisma.Decimal | null
      note: string
      dateHeure: Date
    }, ExtArgs["result"]["observationInfirmier"]>
    composites: {}
  }

  type ObservationInfirmierGetPayload<S extends boolean | null | undefined | ObservationInfirmierDefaultArgs> = $Result.GetResult<Prisma.$ObservationInfirmierPayload, S>

  type ObservationInfirmierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObservationInfirmierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObservationInfirmierCountAggregateInputType | true
    }

  export interface ObservationInfirmierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObservationInfirmier'], meta: { name: 'ObservationInfirmier' } }
    /**
     * Find zero or one ObservationInfirmier that matches the filter.
     * @param {ObservationInfirmierFindUniqueArgs} args - Arguments to find a ObservationInfirmier
     * @example
     * // Get one ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationInfirmierFindUniqueArgs>(args: SelectSubset<T, ObservationInfirmierFindUniqueArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ObservationInfirmier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObservationInfirmierFindUniqueOrThrowArgs} args - Arguments to find a ObservationInfirmier
     * @example
     * // Get one ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationInfirmierFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationInfirmierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ObservationInfirmier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierFindFirstArgs} args - Arguments to find a ObservationInfirmier
     * @example
     * // Get one ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationInfirmierFindFirstArgs>(args?: SelectSubset<T, ObservationInfirmierFindFirstArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ObservationInfirmier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierFindFirstOrThrowArgs} args - Arguments to find a ObservationInfirmier
     * @example
     * // Get one ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationInfirmierFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationInfirmierFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ObservationInfirmiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObservationInfirmiers
     * const observationInfirmiers = await prisma.observationInfirmier.findMany()
     * 
     * // Get first 10 ObservationInfirmiers
     * const observationInfirmiers = await prisma.observationInfirmier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationInfirmierWithIdOnly = await prisma.observationInfirmier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationInfirmierFindManyArgs>(args?: SelectSubset<T, ObservationInfirmierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ObservationInfirmier.
     * @param {ObservationInfirmierCreateArgs} args - Arguments to create a ObservationInfirmier.
     * @example
     * // Create one ObservationInfirmier
     * const ObservationInfirmier = await prisma.observationInfirmier.create({
     *   data: {
     *     // ... data to create a ObservationInfirmier
     *   }
     * })
     * 
     */
    create<T extends ObservationInfirmierCreateArgs>(args: SelectSubset<T, ObservationInfirmierCreateArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ObservationInfirmiers.
     * @param {ObservationInfirmierCreateManyArgs} args - Arguments to create many ObservationInfirmiers.
     * @example
     * // Create many ObservationInfirmiers
     * const observationInfirmier = await prisma.observationInfirmier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationInfirmierCreateManyArgs>(args?: SelectSubset<T, ObservationInfirmierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObservationInfirmiers and returns the data saved in the database.
     * @param {ObservationInfirmierCreateManyAndReturnArgs} args - Arguments to create many ObservationInfirmiers.
     * @example
     * // Create many ObservationInfirmiers
     * const observationInfirmier = await prisma.observationInfirmier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObservationInfirmiers and only return the `id`
     * const observationInfirmierWithIdOnly = await prisma.observationInfirmier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObservationInfirmierCreateManyAndReturnArgs>(args?: SelectSubset<T, ObservationInfirmierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ObservationInfirmier.
     * @param {ObservationInfirmierDeleteArgs} args - Arguments to delete one ObservationInfirmier.
     * @example
     * // Delete one ObservationInfirmier
     * const ObservationInfirmier = await prisma.observationInfirmier.delete({
     *   where: {
     *     // ... filter to delete one ObservationInfirmier
     *   }
     * })
     * 
     */
    delete<T extends ObservationInfirmierDeleteArgs>(args: SelectSubset<T, ObservationInfirmierDeleteArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ObservationInfirmier.
     * @param {ObservationInfirmierUpdateArgs} args - Arguments to update one ObservationInfirmier.
     * @example
     * // Update one ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationInfirmierUpdateArgs>(args: SelectSubset<T, ObservationInfirmierUpdateArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ObservationInfirmiers.
     * @param {ObservationInfirmierDeleteManyArgs} args - Arguments to filter ObservationInfirmiers to delete.
     * @example
     * // Delete a few ObservationInfirmiers
     * const { count } = await prisma.observationInfirmier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationInfirmierDeleteManyArgs>(args?: SelectSubset<T, ObservationInfirmierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObservationInfirmiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObservationInfirmiers
     * const observationInfirmier = await prisma.observationInfirmier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationInfirmierUpdateManyArgs>(args: SelectSubset<T, ObservationInfirmierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObservationInfirmiers and returns the data updated in the database.
     * @param {ObservationInfirmierUpdateManyAndReturnArgs} args - Arguments to update many ObservationInfirmiers.
     * @example
     * // Update many ObservationInfirmiers
     * const observationInfirmier = await prisma.observationInfirmier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ObservationInfirmiers and only return the `id`
     * const observationInfirmierWithIdOnly = await prisma.observationInfirmier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ObservationInfirmierUpdateManyAndReturnArgs>(args: SelectSubset<T, ObservationInfirmierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ObservationInfirmier.
     * @param {ObservationInfirmierUpsertArgs} args - Arguments to update or create a ObservationInfirmier.
     * @example
     * // Update or create a ObservationInfirmier
     * const observationInfirmier = await prisma.observationInfirmier.upsert({
     *   create: {
     *     // ... data to create a ObservationInfirmier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObservationInfirmier we want to update
     *   }
     * })
     */
    upsert<T extends ObservationInfirmierUpsertArgs>(args: SelectSubset<T, ObservationInfirmierUpsertArgs<ExtArgs>>): Prisma__ObservationInfirmierClient<$Result.GetResult<Prisma.$ObservationInfirmierPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ObservationInfirmiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierCountArgs} args - Arguments to filter ObservationInfirmiers to count.
     * @example
     * // Count the number of ObservationInfirmiers
     * const count = await prisma.observationInfirmier.count({
     *   where: {
     *     // ... the filter for the ObservationInfirmiers we want to count
     *   }
     * })
    **/
    count<T extends ObservationInfirmierCountArgs>(
      args?: Subset<T, ObservationInfirmierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationInfirmierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObservationInfirmier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationInfirmierAggregateArgs>(args: Subset<T, ObservationInfirmierAggregateArgs>): Prisma.PrismaPromise<GetObservationInfirmierAggregateType<T>>

    /**
     * Group by ObservationInfirmier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationInfirmierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationInfirmierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationInfirmierGroupByArgs['orderBy'] }
        : { orderBy?: ObservationInfirmierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationInfirmierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationInfirmierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObservationInfirmier model
   */
  readonly fields: ObservationInfirmierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObservationInfirmier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationInfirmierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hospitalisation<T extends HospitalisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HospitalisationDefaultArgs<ExtArgs>>): Prisma__HospitalisationClient<$Result.GetResult<Prisma.$HospitalisationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    infirmier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObservationInfirmier model
   */ 
  interface ObservationInfirmierFieldRefs {
    readonly id: FieldRef<"ObservationInfirmier", 'String'>
    readonly hospitalisationId: FieldRef<"ObservationInfirmier", 'String'>
    readonly infirmierId: FieldRef<"ObservationInfirmier", 'String'>
    readonly pressionArterielle: FieldRef<"ObservationInfirmier", 'String'>
    readonly temperature: FieldRef<"ObservationInfirmier", 'Decimal'>
    readonly note: FieldRef<"ObservationInfirmier", 'String'>
    readonly dateHeure: FieldRef<"ObservationInfirmier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ObservationInfirmier findUnique
   */
  export type ObservationInfirmierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter, which ObservationInfirmier to fetch.
     */
    where: ObservationInfirmierWhereUniqueInput
  }

  /**
   * ObservationInfirmier findUniqueOrThrow
   */
  export type ObservationInfirmierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter, which ObservationInfirmier to fetch.
     */
    where: ObservationInfirmierWhereUniqueInput
  }

  /**
   * ObservationInfirmier findFirst
   */
  export type ObservationInfirmierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter, which ObservationInfirmier to fetch.
     */
    where?: ObservationInfirmierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationInfirmiers to fetch.
     */
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationInfirmiers.
     */
    cursor?: ObservationInfirmierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationInfirmiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationInfirmiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationInfirmiers.
     */
    distinct?: ObservationInfirmierScalarFieldEnum | ObservationInfirmierScalarFieldEnum[]
  }

  /**
   * ObservationInfirmier findFirstOrThrow
   */
  export type ObservationInfirmierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter, which ObservationInfirmier to fetch.
     */
    where?: ObservationInfirmierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationInfirmiers to fetch.
     */
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObservationInfirmiers.
     */
    cursor?: ObservationInfirmierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationInfirmiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationInfirmiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObservationInfirmiers.
     */
    distinct?: ObservationInfirmierScalarFieldEnum | ObservationInfirmierScalarFieldEnum[]
  }

  /**
   * ObservationInfirmier findMany
   */
  export type ObservationInfirmierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter, which ObservationInfirmiers to fetch.
     */
    where?: ObservationInfirmierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObservationInfirmiers to fetch.
     */
    orderBy?: ObservationInfirmierOrderByWithRelationInput | ObservationInfirmierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObservationInfirmiers.
     */
    cursor?: ObservationInfirmierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObservationInfirmiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObservationInfirmiers.
     */
    skip?: number
    distinct?: ObservationInfirmierScalarFieldEnum | ObservationInfirmierScalarFieldEnum[]
  }

  /**
   * ObservationInfirmier create
   */
  export type ObservationInfirmierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * The data needed to create a ObservationInfirmier.
     */
    data: XOR<ObservationInfirmierCreateInput, ObservationInfirmierUncheckedCreateInput>
  }

  /**
   * ObservationInfirmier createMany
   */
  export type ObservationInfirmierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObservationInfirmiers.
     */
    data: ObservationInfirmierCreateManyInput | ObservationInfirmierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObservationInfirmier createManyAndReturn
   */
  export type ObservationInfirmierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * The data used to create many ObservationInfirmiers.
     */
    data: ObservationInfirmierCreateManyInput | ObservationInfirmierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ObservationInfirmier update
   */
  export type ObservationInfirmierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * The data needed to update a ObservationInfirmier.
     */
    data: XOR<ObservationInfirmierUpdateInput, ObservationInfirmierUncheckedUpdateInput>
    /**
     * Choose, which ObservationInfirmier to update.
     */
    where: ObservationInfirmierWhereUniqueInput
  }

  /**
   * ObservationInfirmier updateMany
   */
  export type ObservationInfirmierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObservationInfirmiers.
     */
    data: XOR<ObservationInfirmierUpdateManyMutationInput, ObservationInfirmierUncheckedUpdateManyInput>
    /**
     * Filter which ObservationInfirmiers to update
     */
    where?: ObservationInfirmierWhereInput
  }

  /**
   * ObservationInfirmier updateManyAndReturn
   */
  export type ObservationInfirmierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * The data used to update ObservationInfirmiers.
     */
    data: XOR<ObservationInfirmierUpdateManyMutationInput, ObservationInfirmierUncheckedUpdateManyInput>
    /**
     * Filter which ObservationInfirmiers to update
     */
    where?: ObservationInfirmierWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ObservationInfirmier upsert
   */
  export type ObservationInfirmierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * The filter to search for the ObservationInfirmier to update in case it exists.
     */
    where: ObservationInfirmierWhereUniqueInput
    /**
     * In case the ObservationInfirmier found by the `where` argument doesn't exist, create a new ObservationInfirmier with this data.
     */
    create: XOR<ObservationInfirmierCreateInput, ObservationInfirmierUncheckedCreateInput>
    /**
     * In case the ObservationInfirmier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationInfirmierUpdateInput, ObservationInfirmierUncheckedUpdateInput>
  }

  /**
   * ObservationInfirmier delete
   */
  export type ObservationInfirmierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
    /**
     * Filter which ObservationInfirmier to delete.
     */
    where: ObservationInfirmierWhereUniqueInput
  }

  /**
   * ObservationInfirmier deleteMany
   */
  export type ObservationInfirmierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObservationInfirmiers to delete
     */
    where?: ObservationInfirmierWhereInput
  }

  /**
   * ObservationInfirmier without action
   */
  export type ObservationInfirmierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObservationInfirmier
     */
    select?: ObservationInfirmierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObservationInfirmier
     */
    omit?: ObservationInfirmierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInfirmierInclude<ExtArgs> | null
  }


  /**
   * Model Intervention
   */

  export type AggregateIntervention = {
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  export type InterventionAvgAggregateOutputType = {
    duree: number | null
  }

  export type InterventionSumAggregateOutputType = {
    duree: number | null
  }

  export type InterventionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    chirurgienId: string | null
    anesthesisteId: string | null
    typeIntervention: string | null
    dateHeure: Date | null
    salle: string | null
    statut: string | null
    protocoleOp: string | null
    typeAnesthesie: string | null
    duree: number | null
    createdAt: Date | null
  }

  export type InterventionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    chirurgienId: string | null
    anesthesisteId: string | null
    typeIntervention: string | null
    dateHeure: Date | null
    salle: string | null
    statut: string | null
    protocoleOp: string | null
    typeAnesthesie: string | null
    duree: number | null
    createdAt: Date | null
  }

  export type InterventionCountAggregateOutputType = {
    id: number
    patientId: number
    chirurgienId: number
    anesthesisteId: number
    typeIntervention: number
    dateHeure: number
    salle: number
    statut: number
    protocoleOp: number
    typeAnesthesie: number
    duree: number
    createdAt: number
    _all: number
  }


  export type InterventionAvgAggregateInputType = {
    duree?: true
  }

  export type InterventionSumAggregateInputType = {
    duree?: true
  }

  export type InterventionMinAggregateInputType = {
    id?: true
    patientId?: true
    chirurgienId?: true
    anesthesisteId?: true
    typeIntervention?: true
    dateHeure?: true
    salle?: true
    statut?: true
    protocoleOp?: true
    typeAnesthesie?: true
    duree?: true
    createdAt?: true
  }

  export type InterventionMaxAggregateInputType = {
    id?: true
    patientId?: true
    chirurgienId?: true
    anesthesisteId?: true
    typeIntervention?: true
    dateHeure?: true
    salle?: true
    statut?: true
    protocoleOp?: true
    typeAnesthesie?: true
    duree?: true
    createdAt?: true
  }

  export type InterventionCountAggregateInputType = {
    id?: true
    patientId?: true
    chirurgienId?: true
    anesthesisteId?: true
    typeIntervention?: true
    dateHeure?: true
    salle?: true
    statut?: true
    protocoleOp?: true
    typeAnesthesie?: true
    duree?: true
    createdAt?: true
    _all?: true
  }

  export type InterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervention to aggregate.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interventions
    **/
    _count?: true | InterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionMaxAggregateInputType
  }

  export type GetInterventionAggregateType<T extends InterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention[P]>
      : GetScalarType<T[P], AggregateIntervention[P]>
  }




  export type InterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithAggregationInput | InterventionOrderByWithAggregationInput[]
    by: InterventionScalarFieldEnum[] | InterventionScalarFieldEnum
    having?: InterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionCountAggregateInputType | true
    _avg?: InterventionAvgAggregateInputType
    _sum?: InterventionSumAggregateInputType
    _min?: InterventionMinAggregateInputType
    _max?: InterventionMaxAggregateInputType
  }

  export type InterventionGroupByOutputType = {
    id: string
    patientId: string
    chirurgienId: string
    anesthesisteId: string | null
    typeIntervention: string
    dateHeure: Date
    salle: string
    statut: string
    protocoleOp: string | null
    typeAnesthesie: string | null
    duree: number | null
    createdAt: Date
    _count: InterventionCountAggregateOutputType | null
    _avg: InterventionAvgAggregateOutputType | null
    _sum: InterventionSumAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  type GetInterventionGroupByPayload<T extends InterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    chirurgienId?: boolean
    anesthesisteId?: boolean
    typeIntervention?: boolean
    dateHeure?: boolean
    salle?: boolean
    statut?: boolean
    protocoleOp?: boolean
    typeAnesthesie?: boolean
    duree?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    chirurgienId?: boolean
    anesthesisteId?: boolean
    typeIntervention?: boolean
    dateHeure?: boolean
    salle?: boolean
    statut?: boolean
    protocoleOp?: boolean
    typeAnesthesie?: boolean
    duree?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    chirurgienId?: boolean
    anesthesisteId?: boolean
    typeIntervention?: boolean
    dateHeure?: boolean
    salle?: boolean
    statut?: boolean
    protocoleOp?: boolean
    typeAnesthesie?: boolean
    duree?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>

  export type InterventionSelectScalar = {
    id?: boolean
    patientId?: boolean
    chirurgienId?: boolean
    anesthesisteId?: boolean
    typeIntervention?: boolean
    dateHeure?: boolean
    salle?: boolean
    statut?: boolean
    protocoleOp?: boolean
    typeAnesthesie?: boolean
    duree?: boolean
    createdAt?: boolean
  }

  export type InterventionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "chirurgienId" | "anesthesisteId" | "typeIntervention" | "dateHeure" | "salle" | "statut" | "protocoleOp" | "typeAnesthesie" | "duree" | "createdAt", ExtArgs["result"]["intervention"]>
  export type InterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }
  export type InterventionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }
  export type InterventionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    chirurgien?: boolean | UserDefaultArgs<ExtArgs>
    anesthesiste?: boolean | Intervention$anesthesisteArgs<ExtArgs>
  }

  export type $InterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervention"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      chirurgien: Prisma.$UserPayload<ExtArgs>
      anesthesiste: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      chirurgienId: string
      anesthesisteId: string | null
      typeIntervention: string
      dateHeure: Date
      salle: string
      statut: string
      protocoleOp: string | null
      typeAnesthesie: string | null
      duree: number | null
      createdAt: Date
    }, ExtArgs["result"]["intervention"]>
    composites: {}
  }

  type InterventionGetPayload<S extends boolean | null | undefined | InterventionDefaultArgs> = $Result.GetResult<Prisma.$InterventionPayload, S>

  type InterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionCountAggregateInputType | true
    }

  export interface InterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervention'], meta: { name: 'Intervention' } }
    /**
     * Find zero or one Intervention that matches the filter.
     * @param {InterventionFindUniqueArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionFindUniqueArgs>(args: SelectSubset<T, InterventionFindUniqueArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Intervention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionFindUniqueOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Intervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionFindFirstArgs>(args?: SelectSubset<T, InterventionFindFirstArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Intervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Interventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interventions
     * const interventions = await prisma.intervention.findMany()
     * 
     * // Get first 10 Interventions
     * const interventions = await prisma.intervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionWithIdOnly = await prisma.intervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionFindManyArgs>(args?: SelectSubset<T, InterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Intervention.
     * @param {InterventionCreateArgs} args - Arguments to create a Intervention.
     * @example
     * // Create one Intervention
     * const Intervention = await prisma.intervention.create({
     *   data: {
     *     // ... data to create a Intervention
     *   }
     * })
     * 
     */
    create<T extends InterventionCreateArgs>(args: SelectSubset<T, InterventionCreateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Interventions.
     * @param {InterventionCreateManyArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionCreateManyArgs>(args?: SelectSubset<T, InterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interventions and returns the data saved in the database.
     * @param {InterventionCreateManyAndReturnArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interventions and only return the `id`
     * const interventionWithIdOnly = await prisma.intervention.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Intervention.
     * @param {InterventionDeleteArgs} args - Arguments to delete one Intervention.
     * @example
     * // Delete one Intervention
     * const Intervention = await prisma.intervention.delete({
     *   where: {
     *     // ... filter to delete one Intervention
     *   }
     * })
     * 
     */
    delete<T extends InterventionDeleteArgs>(args: SelectSubset<T, InterventionDeleteArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Intervention.
     * @param {InterventionUpdateArgs} args - Arguments to update one Intervention.
     * @example
     * // Update one Intervention
     * const intervention = await prisma.intervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionUpdateArgs>(args: SelectSubset<T, InterventionUpdateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Interventions.
     * @param {InterventionDeleteManyArgs} args - Arguments to filter Interventions to delete.
     * @example
     * // Delete a few Interventions
     * const { count } = await prisma.intervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionDeleteManyArgs>(args?: SelectSubset<T, InterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionUpdateManyArgs>(args: SelectSubset<T, InterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions and returns the data updated in the database.
     * @param {InterventionUpdateManyAndReturnArgs} args - Arguments to update many Interventions.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interventions and only return the `id`
     * const interventionWithIdOnly = await prisma.intervention.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterventionUpdateManyAndReturnArgs>(args: SelectSubset<T, InterventionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Intervention.
     * @param {InterventionUpsertArgs} args - Arguments to update or create a Intervention.
     * @example
     * // Update or create a Intervention
     * const intervention = await prisma.intervention.upsert({
     *   create: {
     *     // ... data to create a Intervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention we want to update
     *   }
     * })
     */
    upsert<T extends InterventionUpsertArgs>(args: SelectSubset<T, InterventionUpsertArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionCountArgs} args - Arguments to filter Interventions to count.
     * @example
     * // Count the number of Interventions
     * const count = await prisma.intervention.count({
     *   where: {
     *     // ... the filter for the Interventions we want to count
     *   }
     * })
    **/
    count<T extends InterventionCountArgs>(
      args?: Subset<T, InterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionAggregateArgs>(args: Subset<T, InterventionAggregateArgs>): Prisma.PrismaPromise<GetInterventionAggregateType<T>>

    /**
     * Group by Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionGroupByArgs['orderBy'] }
        : { orderBy?: InterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervention model
   */
  readonly fields: InterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    chirurgien<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    anesthesiste<T extends Intervention$anesthesisteArgs<ExtArgs> = {}>(args?: Subset<T, Intervention$anesthesisteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervention model
   */ 
  interface InterventionFieldRefs {
    readonly id: FieldRef<"Intervention", 'String'>
    readonly patientId: FieldRef<"Intervention", 'String'>
    readonly chirurgienId: FieldRef<"Intervention", 'String'>
    readonly anesthesisteId: FieldRef<"Intervention", 'String'>
    readonly typeIntervention: FieldRef<"Intervention", 'String'>
    readonly dateHeure: FieldRef<"Intervention", 'DateTime'>
    readonly salle: FieldRef<"Intervention", 'String'>
    readonly statut: FieldRef<"Intervention", 'String'>
    readonly protocoleOp: FieldRef<"Intervention", 'String'>
    readonly typeAnesthesie: FieldRef<"Intervention", 'String'>
    readonly duree: FieldRef<"Intervention", 'Int'>
    readonly createdAt: FieldRef<"Intervention", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Intervention findUnique
   */
  export type InterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findUniqueOrThrow
   */
  export type InterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findFirst
   */
  export type InterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findFirstOrThrow
   */
  export type InterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findMany
   */
  export type InterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Interventions to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention create
   */
  export type InterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervention.
     */
    data: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
  }

  /**
   * Intervention createMany
   */
  export type InterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervention createManyAndReturn
   */
  export type InterventionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention update
   */
  export type InterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervention.
     */
    data: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
    /**
     * Choose, which Intervention to update.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention updateMany
   */
  export type InterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
  }

  /**
   * Intervention updateManyAndReturn
   */
  export type InterventionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Intervention upsert
   */
  export type InterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervention to update in case it exists.
     */
    where: InterventionWhereUniqueInput
    /**
     * In case the Intervention found by the `where` argument doesn't exist, create a new Intervention with this data.
     */
    create: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
    /**
     * In case the Intervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
  }

  /**
   * Intervention delete
   */
  export type InterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter which Intervention to delete.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention deleteMany
   */
  export type InterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interventions to delete
     */
    where?: InterventionWhereInput
  }

  /**
   * Intervention.anesthesiste
   */
  export type Intervention$anesthesisteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Intervention without action
   */
  export type InterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
  }


  /**
   * Model DossierMaternite
   */

  export type AggregateDossierMaternite = {
    _count: DossierMaterniteCountAggregateOutputType | null
    _avg: DossierMaterniteAvgAggregateOutputType | null
    _sum: DossierMaterniteSumAggregateOutputType | null
    _min: DossierMaterniteMinAggregateOutputType | null
    _max: DossierMaterniteMaxAggregateOutputType | null
  }

  export type DossierMaterniteAvgAggregateOutputType = {
    parite: number | null
    gestite: number | null
  }

  export type DossierMaterniteSumAggregateOutputType = {
    parite: number | null
    gestite: number | null
  }

  export type DossierMaterniteMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    dateDebutGrossesse: Date | null
    parite: number | null
    gestite: number | null
    groupageRhesus: string | null
    createdAt: Date | null
  }

  export type DossierMaterniteMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    dateDebutGrossesse: Date | null
    parite: number | null
    gestite: number | null
    groupageRhesus: string | null
    createdAt: Date | null
  }

  export type DossierMaterniteCountAggregateOutputType = {
    id: number
    patientId: number
    dateDebutGrossesse: number
    parite: number
    gestite: number
    groupageRhesus: number
    examensPrenataux: number
    accouchement: number
    createdAt: number
    _all: number
  }


  export type DossierMaterniteAvgAggregateInputType = {
    parite?: true
    gestite?: true
  }

  export type DossierMaterniteSumAggregateInputType = {
    parite?: true
    gestite?: true
  }

  export type DossierMaterniteMinAggregateInputType = {
    id?: true
    patientId?: true
    dateDebutGrossesse?: true
    parite?: true
    gestite?: true
    groupageRhesus?: true
    createdAt?: true
  }

  export type DossierMaterniteMaxAggregateInputType = {
    id?: true
    patientId?: true
    dateDebutGrossesse?: true
    parite?: true
    gestite?: true
    groupageRhesus?: true
    createdAt?: true
  }

  export type DossierMaterniteCountAggregateInputType = {
    id?: true
    patientId?: true
    dateDebutGrossesse?: true
    parite?: true
    gestite?: true
    groupageRhesus?: true
    examensPrenataux?: true
    accouchement?: true
    createdAt?: true
    _all?: true
  }

  export type DossierMaterniteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DossierMaternite to aggregate.
     */
    where?: DossierMaterniteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DossierMaternites to fetch.
     */
    orderBy?: DossierMaterniteOrderByWithRelationInput | DossierMaterniteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DossierMaterniteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DossierMaternites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DossierMaternites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DossierMaternites
    **/
    _count?: true | DossierMaterniteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DossierMaterniteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DossierMaterniteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DossierMaterniteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DossierMaterniteMaxAggregateInputType
  }

  export type GetDossierMaterniteAggregateType<T extends DossierMaterniteAggregateArgs> = {
        [P in keyof T & keyof AggregateDossierMaternite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDossierMaternite[P]>
      : GetScalarType<T[P], AggregateDossierMaternite[P]>
  }




  export type DossierMaterniteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DossierMaterniteWhereInput
    orderBy?: DossierMaterniteOrderByWithAggregationInput | DossierMaterniteOrderByWithAggregationInput[]
    by: DossierMaterniteScalarFieldEnum[] | DossierMaterniteScalarFieldEnum
    having?: DossierMaterniteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DossierMaterniteCountAggregateInputType | true
    _avg?: DossierMaterniteAvgAggregateInputType
    _sum?: DossierMaterniteSumAggregateInputType
    _min?: DossierMaterniteMinAggregateInputType
    _max?: DossierMaterniteMaxAggregateInputType
  }

  export type DossierMaterniteGroupByOutputType = {
    id: string
    patientId: string
    dateDebutGrossesse: Date
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux: JsonValue | null
    accouchement: JsonValue | null
    createdAt: Date
    _count: DossierMaterniteCountAggregateOutputType | null
    _avg: DossierMaterniteAvgAggregateOutputType | null
    _sum: DossierMaterniteSumAggregateOutputType | null
    _min: DossierMaterniteMinAggregateOutputType | null
    _max: DossierMaterniteMaxAggregateOutputType | null
  }

  type GetDossierMaterniteGroupByPayload<T extends DossierMaterniteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DossierMaterniteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DossierMaterniteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DossierMaterniteGroupByOutputType[P]>
            : GetScalarType<T[P], DossierMaterniteGroupByOutputType[P]>
        }
      >
    >


  export type DossierMaterniteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    dateDebutGrossesse?: boolean
    parite?: boolean
    gestite?: boolean
    groupageRhesus?: boolean
    examensPrenataux?: boolean
    accouchement?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nouveauNes?: boolean | DossierMaternite$nouveauNesArgs<ExtArgs>
    _count?: boolean | DossierMaterniteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dossierMaternite"]>

  export type DossierMaterniteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    dateDebutGrossesse?: boolean
    parite?: boolean
    gestite?: boolean
    groupageRhesus?: boolean
    examensPrenataux?: boolean
    accouchement?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dossierMaternite"]>

  export type DossierMaterniteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    dateDebutGrossesse?: boolean
    parite?: boolean
    gestite?: boolean
    groupageRhesus?: boolean
    examensPrenataux?: boolean
    accouchement?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dossierMaternite"]>

  export type DossierMaterniteSelectScalar = {
    id?: boolean
    patientId?: boolean
    dateDebutGrossesse?: boolean
    parite?: boolean
    gestite?: boolean
    groupageRhesus?: boolean
    examensPrenataux?: boolean
    accouchement?: boolean
    createdAt?: boolean
  }

  export type DossierMaterniteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "dateDebutGrossesse" | "parite" | "gestite" | "groupageRhesus" | "examensPrenataux" | "accouchement" | "createdAt", ExtArgs["result"]["dossierMaternite"]>
  export type DossierMaterniteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    nouveauNes?: boolean | DossierMaternite$nouveauNesArgs<ExtArgs>
    _count?: boolean | DossierMaterniteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DossierMaterniteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type DossierMaterniteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $DossierMaternitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DossierMaternite"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      nouveauNes: Prisma.$NouveauNePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      dateDebutGrossesse: Date
      parite: number
      gestite: number
      groupageRhesus: string
      examensPrenataux: Prisma.JsonValue | null
      accouchement: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["dossierMaternite"]>
    composites: {}
  }

  type DossierMaterniteGetPayload<S extends boolean | null | undefined | DossierMaterniteDefaultArgs> = $Result.GetResult<Prisma.$DossierMaternitePayload, S>

  type DossierMaterniteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DossierMaterniteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DossierMaterniteCountAggregateInputType | true
    }

  export interface DossierMaterniteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DossierMaternite'], meta: { name: 'DossierMaternite' } }
    /**
     * Find zero or one DossierMaternite that matches the filter.
     * @param {DossierMaterniteFindUniqueArgs} args - Arguments to find a DossierMaternite
     * @example
     * // Get one DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DossierMaterniteFindUniqueArgs>(args: SelectSubset<T, DossierMaterniteFindUniqueArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DossierMaternite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DossierMaterniteFindUniqueOrThrowArgs} args - Arguments to find a DossierMaternite
     * @example
     * // Get one DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DossierMaterniteFindUniqueOrThrowArgs>(args: SelectSubset<T, DossierMaterniteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DossierMaternite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteFindFirstArgs} args - Arguments to find a DossierMaternite
     * @example
     * // Get one DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DossierMaterniteFindFirstArgs>(args?: SelectSubset<T, DossierMaterniteFindFirstArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DossierMaternite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteFindFirstOrThrowArgs} args - Arguments to find a DossierMaternite
     * @example
     * // Get one DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DossierMaterniteFindFirstOrThrowArgs>(args?: SelectSubset<T, DossierMaterniteFindFirstOrThrowArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DossierMaternites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DossierMaternites
     * const dossierMaternites = await prisma.dossierMaternite.findMany()
     * 
     * // Get first 10 DossierMaternites
     * const dossierMaternites = await prisma.dossierMaternite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dossierMaterniteWithIdOnly = await prisma.dossierMaternite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DossierMaterniteFindManyArgs>(args?: SelectSubset<T, DossierMaterniteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DossierMaternite.
     * @param {DossierMaterniteCreateArgs} args - Arguments to create a DossierMaternite.
     * @example
     * // Create one DossierMaternite
     * const DossierMaternite = await prisma.dossierMaternite.create({
     *   data: {
     *     // ... data to create a DossierMaternite
     *   }
     * })
     * 
     */
    create<T extends DossierMaterniteCreateArgs>(args: SelectSubset<T, DossierMaterniteCreateArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DossierMaternites.
     * @param {DossierMaterniteCreateManyArgs} args - Arguments to create many DossierMaternites.
     * @example
     * // Create many DossierMaternites
     * const dossierMaternite = await prisma.dossierMaternite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DossierMaterniteCreateManyArgs>(args?: SelectSubset<T, DossierMaterniteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DossierMaternites and returns the data saved in the database.
     * @param {DossierMaterniteCreateManyAndReturnArgs} args - Arguments to create many DossierMaternites.
     * @example
     * // Create many DossierMaternites
     * const dossierMaternite = await prisma.dossierMaternite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DossierMaternites and only return the `id`
     * const dossierMaterniteWithIdOnly = await prisma.dossierMaternite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DossierMaterniteCreateManyAndReturnArgs>(args?: SelectSubset<T, DossierMaterniteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DossierMaternite.
     * @param {DossierMaterniteDeleteArgs} args - Arguments to delete one DossierMaternite.
     * @example
     * // Delete one DossierMaternite
     * const DossierMaternite = await prisma.dossierMaternite.delete({
     *   where: {
     *     // ... filter to delete one DossierMaternite
     *   }
     * })
     * 
     */
    delete<T extends DossierMaterniteDeleteArgs>(args: SelectSubset<T, DossierMaterniteDeleteArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DossierMaternite.
     * @param {DossierMaterniteUpdateArgs} args - Arguments to update one DossierMaternite.
     * @example
     * // Update one DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DossierMaterniteUpdateArgs>(args: SelectSubset<T, DossierMaterniteUpdateArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DossierMaternites.
     * @param {DossierMaterniteDeleteManyArgs} args - Arguments to filter DossierMaternites to delete.
     * @example
     * // Delete a few DossierMaternites
     * const { count } = await prisma.dossierMaternite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DossierMaterniteDeleteManyArgs>(args?: SelectSubset<T, DossierMaterniteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DossierMaternites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DossierMaternites
     * const dossierMaternite = await prisma.dossierMaternite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DossierMaterniteUpdateManyArgs>(args: SelectSubset<T, DossierMaterniteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DossierMaternites and returns the data updated in the database.
     * @param {DossierMaterniteUpdateManyAndReturnArgs} args - Arguments to update many DossierMaternites.
     * @example
     * // Update many DossierMaternites
     * const dossierMaternite = await prisma.dossierMaternite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DossierMaternites and only return the `id`
     * const dossierMaterniteWithIdOnly = await prisma.dossierMaternite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DossierMaterniteUpdateManyAndReturnArgs>(args: SelectSubset<T, DossierMaterniteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DossierMaternite.
     * @param {DossierMaterniteUpsertArgs} args - Arguments to update or create a DossierMaternite.
     * @example
     * // Update or create a DossierMaternite
     * const dossierMaternite = await prisma.dossierMaternite.upsert({
     *   create: {
     *     // ... data to create a DossierMaternite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DossierMaternite we want to update
     *   }
     * })
     */
    upsert<T extends DossierMaterniteUpsertArgs>(args: SelectSubset<T, DossierMaterniteUpsertArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DossierMaternites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteCountArgs} args - Arguments to filter DossierMaternites to count.
     * @example
     * // Count the number of DossierMaternites
     * const count = await prisma.dossierMaternite.count({
     *   where: {
     *     // ... the filter for the DossierMaternites we want to count
     *   }
     * })
    **/
    count<T extends DossierMaterniteCountArgs>(
      args?: Subset<T, DossierMaterniteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DossierMaterniteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DossierMaternite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DossierMaterniteAggregateArgs>(args: Subset<T, DossierMaterniteAggregateArgs>): Prisma.PrismaPromise<GetDossierMaterniteAggregateType<T>>

    /**
     * Group by DossierMaternite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierMaterniteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DossierMaterniteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DossierMaterniteGroupByArgs['orderBy'] }
        : { orderBy?: DossierMaterniteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DossierMaterniteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDossierMaterniteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DossierMaternite model
   */
  readonly fields: DossierMaterniteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DossierMaternite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DossierMaterniteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    nouveauNes<T extends DossierMaternite$nouveauNesArgs<ExtArgs> = {}>(args?: Subset<T, DossierMaternite$nouveauNesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DossierMaternite model
   */ 
  interface DossierMaterniteFieldRefs {
    readonly id: FieldRef<"DossierMaternite", 'String'>
    readonly patientId: FieldRef<"DossierMaternite", 'String'>
    readonly dateDebutGrossesse: FieldRef<"DossierMaternite", 'DateTime'>
    readonly parite: FieldRef<"DossierMaternite", 'Int'>
    readonly gestite: FieldRef<"DossierMaternite", 'Int'>
    readonly groupageRhesus: FieldRef<"DossierMaternite", 'String'>
    readonly examensPrenataux: FieldRef<"DossierMaternite", 'Json'>
    readonly accouchement: FieldRef<"DossierMaternite", 'Json'>
    readonly createdAt: FieldRef<"DossierMaternite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DossierMaternite findUnique
   */
  export type DossierMaterniteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter, which DossierMaternite to fetch.
     */
    where: DossierMaterniteWhereUniqueInput
  }

  /**
   * DossierMaternite findUniqueOrThrow
   */
  export type DossierMaterniteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter, which DossierMaternite to fetch.
     */
    where: DossierMaterniteWhereUniqueInput
  }

  /**
   * DossierMaternite findFirst
   */
  export type DossierMaterniteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter, which DossierMaternite to fetch.
     */
    where?: DossierMaterniteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DossierMaternites to fetch.
     */
    orderBy?: DossierMaterniteOrderByWithRelationInput | DossierMaterniteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DossierMaternites.
     */
    cursor?: DossierMaterniteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DossierMaternites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DossierMaternites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DossierMaternites.
     */
    distinct?: DossierMaterniteScalarFieldEnum | DossierMaterniteScalarFieldEnum[]
  }

  /**
   * DossierMaternite findFirstOrThrow
   */
  export type DossierMaterniteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter, which DossierMaternite to fetch.
     */
    where?: DossierMaterniteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DossierMaternites to fetch.
     */
    orderBy?: DossierMaterniteOrderByWithRelationInput | DossierMaterniteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DossierMaternites.
     */
    cursor?: DossierMaterniteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DossierMaternites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DossierMaternites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DossierMaternites.
     */
    distinct?: DossierMaterniteScalarFieldEnum | DossierMaterniteScalarFieldEnum[]
  }

  /**
   * DossierMaternite findMany
   */
  export type DossierMaterniteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter, which DossierMaternites to fetch.
     */
    where?: DossierMaterniteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DossierMaternites to fetch.
     */
    orderBy?: DossierMaterniteOrderByWithRelationInput | DossierMaterniteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DossierMaternites.
     */
    cursor?: DossierMaterniteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DossierMaternites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DossierMaternites.
     */
    skip?: number
    distinct?: DossierMaterniteScalarFieldEnum | DossierMaterniteScalarFieldEnum[]
  }

  /**
   * DossierMaternite create
   */
  export type DossierMaterniteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * The data needed to create a DossierMaternite.
     */
    data: XOR<DossierMaterniteCreateInput, DossierMaterniteUncheckedCreateInput>
  }

  /**
   * DossierMaternite createMany
   */
  export type DossierMaterniteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DossierMaternites.
     */
    data: DossierMaterniteCreateManyInput | DossierMaterniteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DossierMaternite createManyAndReturn
   */
  export type DossierMaterniteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * The data used to create many DossierMaternites.
     */
    data: DossierMaterniteCreateManyInput | DossierMaterniteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DossierMaternite update
   */
  export type DossierMaterniteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * The data needed to update a DossierMaternite.
     */
    data: XOR<DossierMaterniteUpdateInput, DossierMaterniteUncheckedUpdateInput>
    /**
     * Choose, which DossierMaternite to update.
     */
    where: DossierMaterniteWhereUniqueInput
  }

  /**
   * DossierMaternite updateMany
   */
  export type DossierMaterniteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DossierMaternites.
     */
    data: XOR<DossierMaterniteUpdateManyMutationInput, DossierMaterniteUncheckedUpdateManyInput>
    /**
     * Filter which DossierMaternites to update
     */
    where?: DossierMaterniteWhereInput
  }

  /**
   * DossierMaternite updateManyAndReturn
   */
  export type DossierMaterniteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * The data used to update DossierMaternites.
     */
    data: XOR<DossierMaterniteUpdateManyMutationInput, DossierMaterniteUncheckedUpdateManyInput>
    /**
     * Filter which DossierMaternites to update
     */
    where?: DossierMaterniteWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DossierMaternite upsert
   */
  export type DossierMaterniteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * The filter to search for the DossierMaternite to update in case it exists.
     */
    where: DossierMaterniteWhereUniqueInput
    /**
     * In case the DossierMaternite found by the `where` argument doesn't exist, create a new DossierMaternite with this data.
     */
    create: XOR<DossierMaterniteCreateInput, DossierMaterniteUncheckedCreateInput>
    /**
     * In case the DossierMaternite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DossierMaterniteUpdateInput, DossierMaterniteUncheckedUpdateInput>
  }

  /**
   * DossierMaternite delete
   */
  export type DossierMaterniteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
    /**
     * Filter which DossierMaternite to delete.
     */
    where: DossierMaterniteWhereUniqueInput
  }

  /**
   * DossierMaternite deleteMany
   */
  export type DossierMaterniteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DossierMaternites to delete
     */
    where?: DossierMaterniteWhereInput
  }

  /**
   * DossierMaternite.nouveauNes
   */
  export type DossierMaternite$nouveauNesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    where?: NouveauNeWhereInput
    orderBy?: NouveauNeOrderByWithRelationInput | NouveauNeOrderByWithRelationInput[]
    cursor?: NouveauNeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NouveauNeScalarFieldEnum | NouveauNeScalarFieldEnum[]
  }

  /**
   * DossierMaternite without action
   */
  export type DossierMaterniteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierMaternite
     */
    select?: DossierMaterniteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DossierMaternite
     */
    omit?: DossierMaterniteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DossierMaterniteInclude<ExtArgs> | null
  }


  /**
   * Model NouveauNe
   */

  export type AggregateNouveauNe = {
    _count: NouveauNeCountAggregateOutputType | null
    _avg: NouveauNeAvgAggregateOutputType | null
    _sum: NouveauNeSumAggregateOutputType | null
    _min: NouveauNeMinAggregateOutputType | null
    _max: NouveauNeMaxAggregateOutputType | null
  }

  export type NouveauNeAvgAggregateOutputType = {
    poids: Decimal | null
    scoreApgar: number | null
  }

  export type NouveauNeSumAggregateOutputType = {
    poids: Decimal | null
    scoreApgar: number | null
  }

  export type NouveauNeMinAggregateOutputType = {
    id: string | null
    dossierMaterniteId: string | null
    nom: string | null
    prenom: string | null
    dateHeureNaissance: Date | null
    sexe: string | null
    poids: Decimal | null
    scoreApgar: number | null
    createdAt: Date | null
  }

  export type NouveauNeMaxAggregateOutputType = {
    id: string | null
    dossierMaterniteId: string | null
    nom: string | null
    prenom: string | null
    dateHeureNaissance: Date | null
    sexe: string | null
    poids: Decimal | null
    scoreApgar: number | null
    createdAt: Date | null
  }

  export type NouveauNeCountAggregateOutputType = {
    id: number
    dossierMaterniteId: number
    nom: number
    prenom: number
    dateHeureNaissance: number
    sexe: number
    poids: number
    scoreApgar: number
    createdAt: number
    _all: number
  }


  export type NouveauNeAvgAggregateInputType = {
    poids?: true
    scoreApgar?: true
  }

  export type NouveauNeSumAggregateInputType = {
    poids?: true
    scoreApgar?: true
  }

  export type NouveauNeMinAggregateInputType = {
    id?: true
    dossierMaterniteId?: true
    nom?: true
    prenom?: true
    dateHeureNaissance?: true
    sexe?: true
    poids?: true
    scoreApgar?: true
    createdAt?: true
  }

  export type NouveauNeMaxAggregateInputType = {
    id?: true
    dossierMaterniteId?: true
    nom?: true
    prenom?: true
    dateHeureNaissance?: true
    sexe?: true
    poids?: true
    scoreApgar?: true
    createdAt?: true
  }

  export type NouveauNeCountAggregateInputType = {
    id?: true
    dossierMaterniteId?: true
    nom?: true
    prenom?: true
    dateHeureNaissance?: true
    sexe?: true
    poids?: true
    scoreApgar?: true
    createdAt?: true
    _all?: true
  }

  export type NouveauNeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NouveauNe to aggregate.
     */
    where?: NouveauNeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NouveauNes to fetch.
     */
    orderBy?: NouveauNeOrderByWithRelationInput | NouveauNeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NouveauNeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NouveauNes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NouveauNes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NouveauNes
    **/
    _count?: true | NouveauNeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NouveauNeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NouveauNeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NouveauNeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NouveauNeMaxAggregateInputType
  }

  export type GetNouveauNeAggregateType<T extends NouveauNeAggregateArgs> = {
        [P in keyof T & keyof AggregateNouveauNe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNouveauNe[P]>
      : GetScalarType<T[P], AggregateNouveauNe[P]>
  }




  export type NouveauNeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NouveauNeWhereInput
    orderBy?: NouveauNeOrderByWithAggregationInput | NouveauNeOrderByWithAggregationInput[]
    by: NouveauNeScalarFieldEnum[] | NouveauNeScalarFieldEnum
    having?: NouveauNeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NouveauNeCountAggregateInputType | true
    _avg?: NouveauNeAvgAggregateInputType
    _sum?: NouveauNeSumAggregateInputType
    _min?: NouveauNeMinAggregateInputType
    _max?: NouveauNeMaxAggregateInputType
  }

  export type NouveauNeGroupByOutputType = {
    id: string
    dossierMaterniteId: string
    nom: string
    prenom: string
    dateHeureNaissance: Date
    sexe: string
    poids: Decimal
    scoreApgar: number | null
    createdAt: Date
    _count: NouveauNeCountAggregateOutputType | null
    _avg: NouveauNeAvgAggregateOutputType | null
    _sum: NouveauNeSumAggregateOutputType | null
    _min: NouveauNeMinAggregateOutputType | null
    _max: NouveauNeMaxAggregateOutputType | null
  }

  type GetNouveauNeGroupByPayload<T extends NouveauNeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NouveauNeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NouveauNeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NouveauNeGroupByOutputType[P]>
            : GetScalarType<T[P], NouveauNeGroupByOutputType[P]>
        }
      >
    >


  export type NouveauNeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossierMaterniteId?: boolean
    nom?: boolean
    prenom?: boolean
    dateHeureNaissance?: boolean
    sexe?: boolean
    poids?: boolean
    scoreApgar?: boolean
    createdAt?: boolean
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nouveauNe"]>

  export type NouveauNeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossierMaterniteId?: boolean
    nom?: boolean
    prenom?: boolean
    dateHeureNaissance?: boolean
    sexe?: boolean
    poids?: boolean
    scoreApgar?: boolean
    createdAt?: boolean
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nouveauNe"]>

  export type NouveauNeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dossierMaterniteId?: boolean
    nom?: boolean
    prenom?: boolean
    dateHeureNaissance?: boolean
    sexe?: boolean
    poids?: boolean
    scoreApgar?: boolean
    createdAt?: boolean
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nouveauNe"]>

  export type NouveauNeSelectScalar = {
    id?: boolean
    dossierMaterniteId?: boolean
    nom?: boolean
    prenom?: boolean
    dateHeureNaissance?: boolean
    sexe?: boolean
    poids?: boolean
    scoreApgar?: boolean
    createdAt?: boolean
  }

  export type NouveauNeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dossierMaterniteId" | "nom" | "prenom" | "dateHeureNaissance" | "sexe" | "poids" | "scoreApgar" | "createdAt", ExtArgs["result"]["nouveauNe"]>
  export type NouveauNeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }
  export type NouveauNeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }
  export type NouveauNeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossierMaternite?: boolean | DossierMaterniteDefaultArgs<ExtArgs>
  }

  export type $NouveauNePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NouveauNe"
    objects: {
      dossierMaternite: Prisma.$DossierMaternitePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dossierMaterniteId: string
      nom: string
      prenom: string
      dateHeureNaissance: Date
      sexe: string
      poids: Prisma.Decimal
      scoreApgar: number | null
      createdAt: Date
    }, ExtArgs["result"]["nouveauNe"]>
    composites: {}
  }

  type NouveauNeGetPayload<S extends boolean | null | undefined | NouveauNeDefaultArgs> = $Result.GetResult<Prisma.$NouveauNePayload, S>

  type NouveauNeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NouveauNeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NouveauNeCountAggregateInputType | true
    }

  export interface NouveauNeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NouveauNe'], meta: { name: 'NouveauNe' } }
    /**
     * Find zero or one NouveauNe that matches the filter.
     * @param {NouveauNeFindUniqueArgs} args - Arguments to find a NouveauNe
     * @example
     * // Get one NouveauNe
     * const nouveauNe = await prisma.nouveauNe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NouveauNeFindUniqueArgs>(args: SelectSubset<T, NouveauNeFindUniqueArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NouveauNe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NouveauNeFindUniqueOrThrowArgs} args - Arguments to find a NouveauNe
     * @example
     * // Get one NouveauNe
     * const nouveauNe = await prisma.nouveauNe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NouveauNeFindUniqueOrThrowArgs>(args: SelectSubset<T, NouveauNeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NouveauNe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeFindFirstArgs} args - Arguments to find a NouveauNe
     * @example
     * // Get one NouveauNe
     * const nouveauNe = await prisma.nouveauNe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NouveauNeFindFirstArgs>(args?: SelectSubset<T, NouveauNeFindFirstArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NouveauNe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeFindFirstOrThrowArgs} args - Arguments to find a NouveauNe
     * @example
     * // Get one NouveauNe
     * const nouveauNe = await prisma.nouveauNe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NouveauNeFindFirstOrThrowArgs>(args?: SelectSubset<T, NouveauNeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NouveauNes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NouveauNes
     * const nouveauNes = await prisma.nouveauNe.findMany()
     * 
     * // Get first 10 NouveauNes
     * const nouveauNes = await prisma.nouveauNe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nouveauNeWithIdOnly = await prisma.nouveauNe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NouveauNeFindManyArgs>(args?: SelectSubset<T, NouveauNeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NouveauNe.
     * @param {NouveauNeCreateArgs} args - Arguments to create a NouveauNe.
     * @example
     * // Create one NouveauNe
     * const NouveauNe = await prisma.nouveauNe.create({
     *   data: {
     *     // ... data to create a NouveauNe
     *   }
     * })
     * 
     */
    create<T extends NouveauNeCreateArgs>(args: SelectSubset<T, NouveauNeCreateArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NouveauNes.
     * @param {NouveauNeCreateManyArgs} args - Arguments to create many NouveauNes.
     * @example
     * // Create many NouveauNes
     * const nouveauNe = await prisma.nouveauNe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NouveauNeCreateManyArgs>(args?: SelectSubset<T, NouveauNeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NouveauNes and returns the data saved in the database.
     * @param {NouveauNeCreateManyAndReturnArgs} args - Arguments to create many NouveauNes.
     * @example
     * // Create many NouveauNes
     * const nouveauNe = await prisma.nouveauNe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NouveauNes and only return the `id`
     * const nouveauNeWithIdOnly = await prisma.nouveauNe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NouveauNeCreateManyAndReturnArgs>(args?: SelectSubset<T, NouveauNeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NouveauNe.
     * @param {NouveauNeDeleteArgs} args - Arguments to delete one NouveauNe.
     * @example
     * // Delete one NouveauNe
     * const NouveauNe = await prisma.nouveauNe.delete({
     *   where: {
     *     // ... filter to delete one NouveauNe
     *   }
     * })
     * 
     */
    delete<T extends NouveauNeDeleteArgs>(args: SelectSubset<T, NouveauNeDeleteArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NouveauNe.
     * @param {NouveauNeUpdateArgs} args - Arguments to update one NouveauNe.
     * @example
     * // Update one NouveauNe
     * const nouveauNe = await prisma.nouveauNe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NouveauNeUpdateArgs>(args: SelectSubset<T, NouveauNeUpdateArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NouveauNes.
     * @param {NouveauNeDeleteManyArgs} args - Arguments to filter NouveauNes to delete.
     * @example
     * // Delete a few NouveauNes
     * const { count } = await prisma.nouveauNe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NouveauNeDeleteManyArgs>(args?: SelectSubset<T, NouveauNeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NouveauNes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NouveauNes
     * const nouveauNe = await prisma.nouveauNe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NouveauNeUpdateManyArgs>(args: SelectSubset<T, NouveauNeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NouveauNes and returns the data updated in the database.
     * @param {NouveauNeUpdateManyAndReturnArgs} args - Arguments to update many NouveauNes.
     * @example
     * // Update many NouveauNes
     * const nouveauNe = await prisma.nouveauNe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NouveauNes and only return the `id`
     * const nouveauNeWithIdOnly = await prisma.nouveauNe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NouveauNeUpdateManyAndReturnArgs>(args: SelectSubset<T, NouveauNeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NouveauNe.
     * @param {NouveauNeUpsertArgs} args - Arguments to update or create a NouveauNe.
     * @example
     * // Update or create a NouveauNe
     * const nouveauNe = await prisma.nouveauNe.upsert({
     *   create: {
     *     // ... data to create a NouveauNe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NouveauNe we want to update
     *   }
     * })
     */
    upsert<T extends NouveauNeUpsertArgs>(args: SelectSubset<T, NouveauNeUpsertArgs<ExtArgs>>): Prisma__NouveauNeClient<$Result.GetResult<Prisma.$NouveauNePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NouveauNes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeCountArgs} args - Arguments to filter NouveauNes to count.
     * @example
     * // Count the number of NouveauNes
     * const count = await prisma.nouveauNe.count({
     *   where: {
     *     // ... the filter for the NouveauNes we want to count
     *   }
     * })
    **/
    count<T extends NouveauNeCountArgs>(
      args?: Subset<T, NouveauNeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NouveauNeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NouveauNe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NouveauNeAggregateArgs>(args: Subset<T, NouveauNeAggregateArgs>): Prisma.PrismaPromise<GetNouveauNeAggregateType<T>>

    /**
     * Group by NouveauNe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NouveauNeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NouveauNeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NouveauNeGroupByArgs['orderBy'] }
        : { orderBy?: NouveauNeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NouveauNeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNouveauNeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NouveauNe model
   */
  readonly fields: NouveauNeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NouveauNe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NouveauNeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dossierMaternite<T extends DossierMaterniteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DossierMaterniteDefaultArgs<ExtArgs>>): Prisma__DossierMaterniteClient<$Result.GetResult<Prisma.$DossierMaternitePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NouveauNe model
   */ 
  interface NouveauNeFieldRefs {
    readonly id: FieldRef<"NouveauNe", 'String'>
    readonly dossierMaterniteId: FieldRef<"NouveauNe", 'String'>
    readonly nom: FieldRef<"NouveauNe", 'String'>
    readonly prenom: FieldRef<"NouveauNe", 'String'>
    readonly dateHeureNaissance: FieldRef<"NouveauNe", 'DateTime'>
    readonly sexe: FieldRef<"NouveauNe", 'String'>
    readonly poids: FieldRef<"NouveauNe", 'Decimal'>
    readonly scoreApgar: FieldRef<"NouveauNe", 'Int'>
    readonly createdAt: FieldRef<"NouveauNe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NouveauNe findUnique
   */
  export type NouveauNeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter, which NouveauNe to fetch.
     */
    where: NouveauNeWhereUniqueInput
  }

  /**
   * NouveauNe findUniqueOrThrow
   */
  export type NouveauNeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter, which NouveauNe to fetch.
     */
    where: NouveauNeWhereUniqueInput
  }

  /**
   * NouveauNe findFirst
   */
  export type NouveauNeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter, which NouveauNe to fetch.
     */
    where?: NouveauNeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NouveauNes to fetch.
     */
    orderBy?: NouveauNeOrderByWithRelationInput | NouveauNeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NouveauNes.
     */
    cursor?: NouveauNeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NouveauNes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NouveauNes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NouveauNes.
     */
    distinct?: NouveauNeScalarFieldEnum | NouveauNeScalarFieldEnum[]
  }

  /**
   * NouveauNe findFirstOrThrow
   */
  export type NouveauNeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter, which NouveauNe to fetch.
     */
    where?: NouveauNeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NouveauNes to fetch.
     */
    orderBy?: NouveauNeOrderByWithRelationInput | NouveauNeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NouveauNes.
     */
    cursor?: NouveauNeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NouveauNes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NouveauNes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NouveauNes.
     */
    distinct?: NouveauNeScalarFieldEnum | NouveauNeScalarFieldEnum[]
  }

  /**
   * NouveauNe findMany
   */
  export type NouveauNeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter, which NouveauNes to fetch.
     */
    where?: NouveauNeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NouveauNes to fetch.
     */
    orderBy?: NouveauNeOrderByWithRelationInput | NouveauNeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NouveauNes.
     */
    cursor?: NouveauNeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NouveauNes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NouveauNes.
     */
    skip?: number
    distinct?: NouveauNeScalarFieldEnum | NouveauNeScalarFieldEnum[]
  }

  /**
   * NouveauNe create
   */
  export type NouveauNeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * The data needed to create a NouveauNe.
     */
    data: XOR<NouveauNeCreateInput, NouveauNeUncheckedCreateInput>
  }

  /**
   * NouveauNe createMany
   */
  export type NouveauNeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NouveauNes.
     */
    data: NouveauNeCreateManyInput | NouveauNeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NouveauNe createManyAndReturn
   */
  export type NouveauNeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * The data used to create many NouveauNes.
     */
    data: NouveauNeCreateManyInput | NouveauNeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NouveauNe update
   */
  export type NouveauNeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * The data needed to update a NouveauNe.
     */
    data: XOR<NouveauNeUpdateInput, NouveauNeUncheckedUpdateInput>
    /**
     * Choose, which NouveauNe to update.
     */
    where: NouveauNeWhereUniqueInput
  }

  /**
   * NouveauNe updateMany
   */
  export type NouveauNeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NouveauNes.
     */
    data: XOR<NouveauNeUpdateManyMutationInput, NouveauNeUncheckedUpdateManyInput>
    /**
     * Filter which NouveauNes to update
     */
    where?: NouveauNeWhereInput
  }

  /**
   * NouveauNe updateManyAndReturn
   */
  export type NouveauNeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * The data used to update NouveauNes.
     */
    data: XOR<NouveauNeUpdateManyMutationInput, NouveauNeUncheckedUpdateManyInput>
    /**
     * Filter which NouveauNes to update
     */
    where?: NouveauNeWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NouveauNe upsert
   */
  export type NouveauNeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * The filter to search for the NouveauNe to update in case it exists.
     */
    where: NouveauNeWhereUniqueInput
    /**
     * In case the NouveauNe found by the `where` argument doesn't exist, create a new NouveauNe with this data.
     */
    create: XOR<NouveauNeCreateInput, NouveauNeUncheckedCreateInput>
    /**
     * In case the NouveauNe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NouveauNeUpdateInput, NouveauNeUncheckedUpdateInput>
  }

  /**
   * NouveauNe delete
   */
  export type NouveauNeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
    /**
     * Filter which NouveauNe to delete.
     */
    where: NouveauNeWhereUniqueInput
  }

  /**
   * NouveauNe deleteMany
   */
  export type NouveauNeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NouveauNes to delete
     */
    where?: NouveauNeWhereInput
  }

  /**
   * NouveauNe without action
   */
  export type NouveauNeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NouveauNe
     */
    select?: NouveauNeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NouveauNe
     */
    omit?: NouveauNeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NouveauNeInclude<ExtArgs> | null
  }


  /**
   * Model ArticleLogistique
   */

  export type AggregateArticleLogistique = {
    _count: ArticleLogistiqueCountAggregateOutputType | null
    _avg: ArticleLogistiqueAvgAggregateOutputType | null
    _sum: ArticleLogistiqueSumAggregateOutputType | null
    _min: ArticleLogistiqueMinAggregateOutputType | null
    _max: ArticleLogistiqueMaxAggregateOutputType | null
  }

  export type ArticleLogistiqueAvgAggregateOutputType = {
    stockAlerte: number | null
    stockActuel: number | null
  }

  export type ArticleLogistiqueSumAggregateOutputType = {
    stockAlerte: number | null
    stockActuel: number | null
  }

  export type ArticleLogistiqueMinAggregateOutputType = {
    id: string | null
    designation: string | null
    categorie: string | null
    famille: string | null
    uniteMesure: string | null
    stockAlerte: number | null
    stockActuel: number | null
    createdAt: Date | null
  }

  export type ArticleLogistiqueMaxAggregateOutputType = {
    id: string | null
    designation: string | null
    categorie: string | null
    famille: string | null
    uniteMesure: string | null
    stockAlerte: number | null
    stockActuel: number | null
    createdAt: Date | null
  }

  export type ArticleLogistiqueCountAggregateOutputType = {
    id: number
    designation: number
    categorie: number
    famille: number
    uniteMesure: number
    stockAlerte: number
    stockActuel: number
    createdAt: number
    _all: number
  }


  export type ArticleLogistiqueAvgAggregateInputType = {
    stockAlerte?: true
    stockActuel?: true
  }

  export type ArticleLogistiqueSumAggregateInputType = {
    stockAlerte?: true
    stockActuel?: true
  }

  export type ArticleLogistiqueMinAggregateInputType = {
    id?: true
    designation?: true
    categorie?: true
    famille?: true
    uniteMesure?: true
    stockAlerte?: true
    stockActuel?: true
    createdAt?: true
  }

  export type ArticleLogistiqueMaxAggregateInputType = {
    id?: true
    designation?: true
    categorie?: true
    famille?: true
    uniteMesure?: true
    stockAlerte?: true
    stockActuel?: true
    createdAt?: true
  }

  export type ArticleLogistiqueCountAggregateInputType = {
    id?: true
    designation?: true
    categorie?: true
    famille?: true
    uniteMesure?: true
    stockAlerte?: true
    stockActuel?: true
    createdAt?: true
    _all?: true
  }

  export type ArticleLogistiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleLogistique to aggregate.
     */
    where?: ArticleLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleLogistiques to fetch.
     */
    orderBy?: ArticleLogistiqueOrderByWithRelationInput | ArticleLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleLogistiques
    **/
    _count?: true | ArticleLogistiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleLogistiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleLogistiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleLogistiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleLogistiqueMaxAggregateInputType
  }

  export type GetArticleLogistiqueAggregateType<T extends ArticleLogistiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleLogistique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleLogistique[P]>
      : GetScalarType<T[P], AggregateArticleLogistique[P]>
  }




  export type ArticleLogistiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleLogistiqueWhereInput
    orderBy?: ArticleLogistiqueOrderByWithAggregationInput | ArticleLogistiqueOrderByWithAggregationInput[]
    by: ArticleLogistiqueScalarFieldEnum[] | ArticleLogistiqueScalarFieldEnum
    having?: ArticleLogistiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleLogistiqueCountAggregateInputType | true
    _avg?: ArticleLogistiqueAvgAggregateInputType
    _sum?: ArticleLogistiqueSumAggregateInputType
    _min?: ArticleLogistiqueMinAggregateInputType
    _max?: ArticleLogistiqueMaxAggregateInputType
  }

  export type ArticleLogistiqueGroupByOutputType = {
    id: string
    designation: string
    categorie: string
    famille: string | null
    uniteMesure: string
    stockAlerte: number
    stockActuel: number
    createdAt: Date
    _count: ArticleLogistiqueCountAggregateOutputType | null
    _avg: ArticleLogistiqueAvgAggregateOutputType | null
    _sum: ArticleLogistiqueSumAggregateOutputType | null
    _min: ArticleLogistiqueMinAggregateOutputType | null
    _max: ArticleLogistiqueMaxAggregateOutputType | null
  }

  type GetArticleLogistiqueGroupByPayload<T extends ArticleLogistiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleLogistiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleLogistiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleLogistiqueGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleLogistiqueGroupByOutputType[P]>
        }
      >
    >


  export type ArticleLogistiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    categorie?: boolean
    famille?: boolean
    uniteMesure?: boolean
    stockAlerte?: boolean
    stockActuel?: boolean
    createdAt?: boolean
    mouvements?: boolean | ArticleLogistique$mouvementsArgs<ExtArgs>
    _count?: boolean | ArticleLogistiqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleLogistique"]>

  export type ArticleLogistiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    categorie?: boolean
    famille?: boolean
    uniteMesure?: boolean
    stockAlerte?: boolean
    stockActuel?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["articleLogistique"]>

  export type ArticleLogistiqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    categorie?: boolean
    famille?: boolean
    uniteMesure?: boolean
    stockAlerte?: boolean
    stockActuel?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["articleLogistique"]>

  export type ArticleLogistiqueSelectScalar = {
    id?: boolean
    designation?: boolean
    categorie?: boolean
    famille?: boolean
    uniteMesure?: boolean
    stockAlerte?: boolean
    stockActuel?: boolean
    createdAt?: boolean
  }

  export type ArticleLogistiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designation" | "categorie" | "famille" | "uniteMesure" | "stockAlerte" | "stockActuel" | "createdAt", ExtArgs["result"]["articleLogistique"]>
  export type ArticleLogistiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mouvements?: boolean | ArticleLogistique$mouvementsArgs<ExtArgs>
    _count?: boolean | ArticleLogistiqueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArticleLogistiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArticleLogistiqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArticleLogistiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleLogistique"
    objects: {
      mouvements: Prisma.$MouvementLogistiquePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      designation: string
      categorie: string
      famille: string | null
      uniteMesure: string
      stockAlerte: number
      stockActuel: number
      createdAt: Date
    }, ExtArgs["result"]["articleLogistique"]>
    composites: {}
  }

  type ArticleLogistiqueGetPayload<S extends boolean | null | undefined | ArticleLogistiqueDefaultArgs> = $Result.GetResult<Prisma.$ArticleLogistiquePayload, S>

  type ArticleLogistiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArticleLogistiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArticleLogistiqueCountAggregateInputType | true
    }

  export interface ArticleLogistiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleLogistique'], meta: { name: 'ArticleLogistique' } }
    /**
     * Find zero or one ArticleLogistique that matches the filter.
     * @param {ArticleLogistiqueFindUniqueArgs} args - Arguments to find a ArticleLogistique
     * @example
     * // Get one ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleLogistiqueFindUniqueArgs>(args: SelectSubset<T, ArticleLogistiqueFindUniqueArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ArticleLogistique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArticleLogistiqueFindUniqueOrThrowArgs} args - Arguments to find a ArticleLogistique
     * @example
     * // Get one ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleLogistiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleLogistiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ArticleLogistique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueFindFirstArgs} args - Arguments to find a ArticleLogistique
     * @example
     * // Get one ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleLogistiqueFindFirstArgs>(args?: SelectSubset<T, ArticleLogistiqueFindFirstArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ArticleLogistique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueFindFirstOrThrowArgs} args - Arguments to find a ArticleLogistique
     * @example
     * // Get one ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleLogistiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleLogistiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ArticleLogistiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleLogistiques
     * const articleLogistiques = await prisma.articleLogistique.findMany()
     * 
     * // Get first 10 ArticleLogistiques
     * const articleLogistiques = await prisma.articleLogistique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleLogistiqueWithIdOnly = await prisma.articleLogistique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleLogistiqueFindManyArgs>(args?: SelectSubset<T, ArticleLogistiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ArticleLogistique.
     * @param {ArticleLogistiqueCreateArgs} args - Arguments to create a ArticleLogistique.
     * @example
     * // Create one ArticleLogistique
     * const ArticleLogistique = await prisma.articleLogistique.create({
     *   data: {
     *     // ... data to create a ArticleLogistique
     *   }
     * })
     * 
     */
    create<T extends ArticleLogistiqueCreateArgs>(args: SelectSubset<T, ArticleLogistiqueCreateArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ArticleLogistiques.
     * @param {ArticleLogistiqueCreateManyArgs} args - Arguments to create many ArticleLogistiques.
     * @example
     * // Create many ArticleLogistiques
     * const articleLogistique = await prisma.articleLogistique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleLogistiqueCreateManyArgs>(args?: SelectSubset<T, ArticleLogistiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleLogistiques and returns the data saved in the database.
     * @param {ArticleLogistiqueCreateManyAndReturnArgs} args - Arguments to create many ArticleLogistiques.
     * @example
     * // Create many ArticleLogistiques
     * const articleLogistique = await prisma.articleLogistique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArticleLogistiques and only return the `id`
     * const articleLogistiqueWithIdOnly = await prisma.articleLogistique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleLogistiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleLogistiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ArticleLogistique.
     * @param {ArticleLogistiqueDeleteArgs} args - Arguments to delete one ArticleLogistique.
     * @example
     * // Delete one ArticleLogistique
     * const ArticleLogistique = await prisma.articleLogistique.delete({
     *   where: {
     *     // ... filter to delete one ArticleLogistique
     *   }
     * })
     * 
     */
    delete<T extends ArticleLogistiqueDeleteArgs>(args: SelectSubset<T, ArticleLogistiqueDeleteArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ArticleLogistique.
     * @param {ArticleLogistiqueUpdateArgs} args - Arguments to update one ArticleLogistique.
     * @example
     * // Update one ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleLogistiqueUpdateArgs>(args: SelectSubset<T, ArticleLogistiqueUpdateArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ArticleLogistiques.
     * @param {ArticleLogistiqueDeleteManyArgs} args - Arguments to filter ArticleLogistiques to delete.
     * @example
     * // Delete a few ArticleLogistiques
     * const { count } = await prisma.articleLogistique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleLogistiqueDeleteManyArgs>(args?: SelectSubset<T, ArticleLogistiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleLogistiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleLogistiques
     * const articleLogistique = await prisma.articleLogistique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleLogistiqueUpdateManyArgs>(args: SelectSubset<T, ArticleLogistiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleLogistiques and returns the data updated in the database.
     * @param {ArticleLogistiqueUpdateManyAndReturnArgs} args - Arguments to update many ArticleLogistiques.
     * @example
     * // Update many ArticleLogistiques
     * const articleLogistique = await prisma.articleLogistique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArticleLogistiques and only return the `id`
     * const articleLogistiqueWithIdOnly = await prisma.articleLogistique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArticleLogistiqueUpdateManyAndReturnArgs>(args: SelectSubset<T, ArticleLogistiqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ArticleLogistique.
     * @param {ArticleLogistiqueUpsertArgs} args - Arguments to update or create a ArticleLogistique.
     * @example
     * // Update or create a ArticleLogistique
     * const articleLogistique = await prisma.articleLogistique.upsert({
     *   create: {
     *     // ... data to create a ArticleLogistique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleLogistique we want to update
     *   }
     * })
     */
    upsert<T extends ArticleLogistiqueUpsertArgs>(args: SelectSubset<T, ArticleLogistiqueUpsertArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ArticleLogistiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueCountArgs} args - Arguments to filter ArticleLogistiques to count.
     * @example
     * // Count the number of ArticleLogistiques
     * const count = await prisma.articleLogistique.count({
     *   where: {
     *     // ... the filter for the ArticleLogistiques we want to count
     *   }
     * })
    **/
    count<T extends ArticleLogistiqueCountArgs>(
      args?: Subset<T, ArticleLogistiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleLogistiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleLogistique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleLogistiqueAggregateArgs>(args: Subset<T, ArticleLogistiqueAggregateArgs>): Prisma.PrismaPromise<GetArticleLogistiqueAggregateType<T>>

    /**
     * Group by ArticleLogistique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleLogistiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleLogistiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleLogistiqueGroupByArgs['orderBy'] }
        : { orderBy?: ArticleLogistiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleLogistiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleLogistiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleLogistique model
   */
  readonly fields: ArticleLogistiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleLogistique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleLogistiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mouvements<T extends ArticleLogistique$mouvementsArgs<ExtArgs> = {}>(args?: Subset<T, ArticleLogistique$mouvementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleLogistique model
   */ 
  interface ArticleLogistiqueFieldRefs {
    readonly id: FieldRef<"ArticleLogistique", 'String'>
    readonly designation: FieldRef<"ArticleLogistique", 'String'>
    readonly categorie: FieldRef<"ArticleLogistique", 'String'>
    readonly famille: FieldRef<"ArticleLogistique", 'String'>
    readonly uniteMesure: FieldRef<"ArticleLogistique", 'String'>
    readonly stockAlerte: FieldRef<"ArticleLogistique", 'Int'>
    readonly stockActuel: FieldRef<"ArticleLogistique", 'Int'>
    readonly createdAt: FieldRef<"ArticleLogistique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArticleLogistique findUnique
   */
  export type ArticleLogistiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which ArticleLogistique to fetch.
     */
    where: ArticleLogistiqueWhereUniqueInput
  }

  /**
   * ArticleLogistique findUniqueOrThrow
   */
  export type ArticleLogistiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which ArticleLogistique to fetch.
     */
    where: ArticleLogistiqueWhereUniqueInput
  }

  /**
   * ArticleLogistique findFirst
   */
  export type ArticleLogistiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which ArticleLogistique to fetch.
     */
    where?: ArticleLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleLogistiques to fetch.
     */
    orderBy?: ArticleLogistiqueOrderByWithRelationInput | ArticleLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleLogistiques.
     */
    cursor?: ArticleLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleLogistiques.
     */
    distinct?: ArticleLogistiqueScalarFieldEnum | ArticleLogistiqueScalarFieldEnum[]
  }

  /**
   * ArticleLogistique findFirstOrThrow
   */
  export type ArticleLogistiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which ArticleLogistique to fetch.
     */
    where?: ArticleLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleLogistiques to fetch.
     */
    orderBy?: ArticleLogistiqueOrderByWithRelationInput | ArticleLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleLogistiques.
     */
    cursor?: ArticleLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleLogistiques.
     */
    distinct?: ArticleLogistiqueScalarFieldEnum | ArticleLogistiqueScalarFieldEnum[]
  }

  /**
   * ArticleLogistique findMany
   */
  export type ArticleLogistiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which ArticleLogistiques to fetch.
     */
    where?: ArticleLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleLogistiques to fetch.
     */
    orderBy?: ArticleLogistiqueOrderByWithRelationInput | ArticleLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleLogistiques.
     */
    cursor?: ArticleLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleLogistiques.
     */
    skip?: number
    distinct?: ArticleLogistiqueScalarFieldEnum | ArticleLogistiqueScalarFieldEnum[]
  }

  /**
   * ArticleLogistique create
   */
  export type ArticleLogistiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleLogistique.
     */
    data: XOR<ArticleLogistiqueCreateInput, ArticleLogistiqueUncheckedCreateInput>
  }

  /**
   * ArticleLogistique createMany
   */
  export type ArticleLogistiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleLogistiques.
     */
    data: ArticleLogistiqueCreateManyInput | ArticleLogistiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleLogistique createManyAndReturn
   */
  export type ArticleLogistiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * The data used to create many ArticleLogistiques.
     */
    data: ArticleLogistiqueCreateManyInput | ArticleLogistiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArticleLogistique update
   */
  export type ArticleLogistiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleLogistique.
     */
    data: XOR<ArticleLogistiqueUpdateInput, ArticleLogistiqueUncheckedUpdateInput>
    /**
     * Choose, which ArticleLogistique to update.
     */
    where: ArticleLogistiqueWhereUniqueInput
  }

  /**
   * ArticleLogistique updateMany
   */
  export type ArticleLogistiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleLogistiques.
     */
    data: XOR<ArticleLogistiqueUpdateManyMutationInput, ArticleLogistiqueUncheckedUpdateManyInput>
    /**
     * Filter which ArticleLogistiques to update
     */
    where?: ArticleLogistiqueWhereInput
  }

  /**
   * ArticleLogistique updateManyAndReturn
   */
  export type ArticleLogistiqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * The data used to update ArticleLogistiques.
     */
    data: XOR<ArticleLogistiqueUpdateManyMutationInput, ArticleLogistiqueUncheckedUpdateManyInput>
    /**
     * Filter which ArticleLogistiques to update
     */
    where?: ArticleLogistiqueWhereInput
  }

  /**
   * ArticleLogistique upsert
   */
  export type ArticleLogistiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleLogistique to update in case it exists.
     */
    where: ArticleLogistiqueWhereUniqueInput
    /**
     * In case the ArticleLogistique found by the `where` argument doesn't exist, create a new ArticleLogistique with this data.
     */
    create: XOR<ArticleLogistiqueCreateInput, ArticleLogistiqueUncheckedCreateInput>
    /**
     * In case the ArticleLogistique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleLogistiqueUpdateInput, ArticleLogistiqueUncheckedUpdateInput>
  }

  /**
   * ArticleLogistique delete
   */
  export type ArticleLogistiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
    /**
     * Filter which ArticleLogistique to delete.
     */
    where: ArticleLogistiqueWhereUniqueInput
  }

  /**
   * ArticleLogistique deleteMany
   */
  export type ArticleLogistiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleLogistiques to delete
     */
    where?: ArticleLogistiqueWhereInput
  }

  /**
   * ArticleLogistique.mouvements
   */
  export type ArticleLogistique$mouvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    where?: MouvementLogistiqueWhereInput
    orderBy?: MouvementLogistiqueOrderByWithRelationInput | MouvementLogistiqueOrderByWithRelationInput[]
    cursor?: MouvementLogistiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementLogistiqueScalarFieldEnum | MouvementLogistiqueScalarFieldEnum[]
  }

  /**
   * ArticleLogistique without action
   */
  export type ArticleLogistiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleLogistique
     */
    select?: ArticleLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArticleLogistique
     */
    omit?: ArticleLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleLogistiqueInclude<ExtArgs> | null
  }


  /**
   * Model MouvementLogistique
   */

  export type AggregateMouvementLogistique = {
    _count: MouvementLogistiqueCountAggregateOutputType | null
    _avg: MouvementLogistiqueAvgAggregateOutputType | null
    _sum: MouvementLogistiqueSumAggregateOutputType | null
    _min: MouvementLogistiqueMinAggregateOutputType | null
    _max: MouvementLogistiqueMaxAggregateOutputType | null
  }

  export type MouvementLogistiqueAvgAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementLogistiqueSumAggregateOutputType = {
    quantite: number | null
  }

  export type MouvementLogistiqueMinAggregateOutputType = {
    id: string | null
    articleId: string | null
    type: string | null
    quantite: number | null
    serviceDestinataire: string | null
    motif: string | null
    utilisateur: string | null
    createdAt: Date | null
  }

  export type MouvementLogistiqueMaxAggregateOutputType = {
    id: string | null
    articleId: string | null
    type: string | null
    quantite: number | null
    serviceDestinataire: string | null
    motif: string | null
    utilisateur: string | null
    createdAt: Date | null
  }

  export type MouvementLogistiqueCountAggregateOutputType = {
    id: number
    articleId: number
    type: number
    quantite: number
    serviceDestinataire: number
    motif: number
    utilisateur: number
    createdAt: number
    _all: number
  }


  export type MouvementLogistiqueAvgAggregateInputType = {
    quantite?: true
  }

  export type MouvementLogistiqueSumAggregateInputType = {
    quantite?: true
  }

  export type MouvementLogistiqueMinAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    serviceDestinataire?: true
    motif?: true
    utilisateur?: true
    createdAt?: true
  }

  export type MouvementLogistiqueMaxAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    serviceDestinataire?: true
    motif?: true
    utilisateur?: true
    createdAt?: true
  }

  export type MouvementLogistiqueCountAggregateInputType = {
    id?: true
    articleId?: true
    type?: true
    quantite?: true
    serviceDestinataire?: true
    motif?: true
    utilisateur?: true
    createdAt?: true
    _all?: true
  }

  export type MouvementLogistiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementLogistique to aggregate.
     */
    where?: MouvementLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementLogistiques to fetch.
     */
    orderBy?: MouvementLogistiqueOrderByWithRelationInput | MouvementLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MouvementLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MouvementLogistiques
    **/
    _count?: true | MouvementLogistiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MouvementLogistiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MouvementLogistiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MouvementLogistiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MouvementLogistiqueMaxAggregateInputType
  }

  export type GetMouvementLogistiqueAggregateType<T extends MouvementLogistiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateMouvementLogistique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMouvementLogistique[P]>
      : GetScalarType<T[P], AggregateMouvementLogistique[P]>
  }




  export type MouvementLogistiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementLogistiqueWhereInput
    orderBy?: MouvementLogistiqueOrderByWithAggregationInput | MouvementLogistiqueOrderByWithAggregationInput[]
    by: MouvementLogistiqueScalarFieldEnum[] | MouvementLogistiqueScalarFieldEnum
    having?: MouvementLogistiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MouvementLogistiqueCountAggregateInputType | true
    _avg?: MouvementLogistiqueAvgAggregateInputType
    _sum?: MouvementLogistiqueSumAggregateInputType
    _min?: MouvementLogistiqueMinAggregateInputType
    _max?: MouvementLogistiqueMaxAggregateInputType
  }

  export type MouvementLogistiqueGroupByOutputType = {
    id: string
    articleId: string
    type: string
    quantite: number
    serviceDestinataire: string | null
    motif: string | null
    utilisateur: string
    createdAt: Date
    _count: MouvementLogistiqueCountAggregateOutputType | null
    _avg: MouvementLogistiqueAvgAggregateOutputType | null
    _sum: MouvementLogistiqueSumAggregateOutputType | null
    _min: MouvementLogistiqueMinAggregateOutputType | null
    _max: MouvementLogistiqueMaxAggregateOutputType | null
  }

  type GetMouvementLogistiqueGroupByPayload<T extends MouvementLogistiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MouvementLogistiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MouvementLogistiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MouvementLogistiqueGroupByOutputType[P]>
            : GetScalarType<T[P], MouvementLogistiqueGroupByOutputType[P]>
        }
      >
    >


  export type MouvementLogistiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    serviceDestinataire?: boolean
    motif?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementLogistique"]>

  export type MouvementLogistiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    serviceDestinataire?: boolean
    motif?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementLogistique"]>

  export type MouvementLogistiqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    serviceDestinataire?: boolean
    motif?: boolean
    utilisateur?: boolean
    createdAt?: boolean
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementLogistique"]>

  export type MouvementLogistiqueSelectScalar = {
    id?: boolean
    articleId?: boolean
    type?: boolean
    quantite?: boolean
    serviceDestinataire?: boolean
    motif?: boolean
    utilisateur?: boolean
    createdAt?: boolean
  }

  export type MouvementLogistiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "articleId" | "type" | "quantite" | "serviceDestinataire" | "motif" | "utilisateur" | "createdAt", ExtArgs["result"]["mouvementLogistique"]>
  export type MouvementLogistiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }
  export type MouvementLogistiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }
  export type MouvementLogistiqueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | ArticleLogistiqueDefaultArgs<ExtArgs>
  }

  export type $MouvementLogistiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MouvementLogistique"
    objects: {
      article: Prisma.$ArticleLogistiquePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      articleId: string
      type: string
      quantite: number
      serviceDestinataire: string | null
      motif: string | null
      utilisateur: string
      createdAt: Date
    }, ExtArgs["result"]["mouvementLogistique"]>
    composites: {}
  }

  type MouvementLogistiqueGetPayload<S extends boolean | null | undefined | MouvementLogistiqueDefaultArgs> = $Result.GetResult<Prisma.$MouvementLogistiquePayload, S>

  type MouvementLogistiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MouvementLogistiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MouvementLogistiqueCountAggregateInputType | true
    }

  export interface MouvementLogistiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MouvementLogistique'], meta: { name: 'MouvementLogistique' } }
    /**
     * Find zero or one MouvementLogistique that matches the filter.
     * @param {MouvementLogistiqueFindUniqueArgs} args - Arguments to find a MouvementLogistique
     * @example
     * // Get one MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MouvementLogistiqueFindUniqueArgs>(args: SelectSubset<T, MouvementLogistiqueFindUniqueArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MouvementLogistique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MouvementLogistiqueFindUniqueOrThrowArgs} args - Arguments to find a MouvementLogistique
     * @example
     * // Get one MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MouvementLogistiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, MouvementLogistiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MouvementLogistique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueFindFirstArgs} args - Arguments to find a MouvementLogistique
     * @example
     * // Get one MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MouvementLogistiqueFindFirstArgs>(args?: SelectSubset<T, MouvementLogistiqueFindFirstArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MouvementLogistique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueFindFirstOrThrowArgs} args - Arguments to find a MouvementLogistique
     * @example
     * // Get one MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MouvementLogistiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, MouvementLogistiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MouvementLogistiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MouvementLogistiques
     * const mouvementLogistiques = await prisma.mouvementLogistique.findMany()
     * 
     * // Get first 10 MouvementLogistiques
     * const mouvementLogistiques = await prisma.mouvementLogistique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mouvementLogistiqueWithIdOnly = await prisma.mouvementLogistique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MouvementLogistiqueFindManyArgs>(args?: SelectSubset<T, MouvementLogistiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MouvementLogistique.
     * @param {MouvementLogistiqueCreateArgs} args - Arguments to create a MouvementLogistique.
     * @example
     * // Create one MouvementLogistique
     * const MouvementLogistique = await prisma.mouvementLogistique.create({
     *   data: {
     *     // ... data to create a MouvementLogistique
     *   }
     * })
     * 
     */
    create<T extends MouvementLogistiqueCreateArgs>(args: SelectSubset<T, MouvementLogistiqueCreateArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MouvementLogistiques.
     * @param {MouvementLogistiqueCreateManyArgs} args - Arguments to create many MouvementLogistiques.
     * @example
     * // Create many MouvementLogistiques
     * const mouvementLogistique = await prisma.mouvementLogistique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MouvementLogistiqueCreateManyArgs>(args?: SelectSubset<T, MouvementLogistiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MouvementLogistiques and returns the data saved in the database.
     * @param {MouvementLogistiqueCreateManyAndReturnArgs} args - Arguments to create many MouvementLogistiques.
     * @example
     * // Create many MouvementLogistiques
     * const mouvementLogistique = await prisma.mouvementLogistique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MouvementLogistiques and only return the `id`
     * const mouvementLogistiqueWithIdOnly = await prisma.mouvementLogistique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MouvementLogistiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, MouvementLogistiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MouvementLogistique.
     * @param {MouvementLogistiqueDeleteArgs} args - Arguments to delete one MouvementLogistique.
     * @example
     * // Delete one MouvementLogistique
     * const MouvementLogistique = await prisma.mouvementLogistique.delete({
     *   where: {
     *     // ... filter to delete one MouvementLogistique
     *   }
     * })
     * 
     */
    delete<T extends MouvementLogistiqueDeleteArgs>(args: SelectSubset<T, MouvementLogistiqueDeleteArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MouvementLogistique.
     * @param {MouvementLogistiqueUpdateArgs} args - Arguments to update one MouvementLogistique.
     * @example
     * // Update one MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MouvementLogistiqueUpdateArgs>(args: SelectSubset<T, MouvementLogistiqueUpdateArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MouvementLogistiques.
     * @param {MouvementLogistiqueDeleteManyArgs} args - Arguments to filter MouvementLogistiques to delete.
     * @example
     * // Delete a few MouvementLogistiques
     * const { count } = await prisma.mouvementLogistique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MouvementLogistiqueDeleteManyArgs>(args?: SelectSubset<T, MouvementLogistiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementLogistiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MouvementLogistiques
     * const mouvementLogistique = await prisma.mouvementLogistique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MouvementLogistiqueUpdateManyArgs>(args: SelectSubset<T, MouvementLogistiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementLogistiques and returns the data updated in the database.
     * @param {MouvementLogistiqueUpdateManyAndReturnArgs} args - Arguments to update many MouvementLogistiques.
     * @example
     * // Update many MouvementLogistiques
     * const mouvementLogistique = await prisma.mouvementLogistique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MouvementLogistiques and only return the `id`
     * const mouvementLogistiqueWithIdOnly = await prisma.mouvementLogistique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MouvementLogistiqueUpdateManyAndReturnArgs>(args: SelectSubset<T, MouvementLogistiqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MouvementLogistique.
     * @param {MouvementLogistiqueUpsertArgs} args - Arguments to update or create a MouvementLogistique.
     * @example
     * // Update or create a MouvementLogistique
     * const mouvementLogistique = await prisma.mouvementLogistique.upsert({
     *   create: {
     *     // ... data to create a MouvementLogistique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MouvementLogistique we want to update
     *   }
     * })
     */
    upsert<T extends MouvementLogistiqueUpsertArgs>(args: SelectSubset<T, MouvementLogistiqueUpsertArgs<ExtArgs>>): Prisma__MouvementLogistiqueClient<$Result.GetResult<Prisma.$MouvementLogistiquePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MouvementLogistiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueCountArgs} args - Arguments to filter MouvementLogistiques to count.
     * @example
     * // Count the number of MouvementLogistiques
     * const count = await prisma.mouvementLogistique.count({
     *   where: {
     *     // ... the filter for the MouvementLogistiques we want to count
     *   }
     * })
    **/
    count<T extends MouvementLogistiqueCountArgs>(
      args?: Subset<T, MouvementLogistiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MouvementLogistiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MouvementLogistique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MouvementLogistiqueAggregateArgs>(args: Subset<T, MouvementLogistiqueAggregateArgs>): Prisma.PrismaPromise<GetMouvementLogistiqueAggregateType<T>>

    /**
     * Group by MouvementLogistique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementLogistiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MouvementLogistiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MouvementLogistiqueGroupByArgs['orderBy'] }
        : { orderBy?: MouvementLogistiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MouvementLogistiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMouvementLogistiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MouvementLogistique model
   */
  readonly fields: MouvementLogistiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MouvementLogistique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MouvementLogistiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends ArticleLogistiqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArticleLogistiqueDefaultArgs<ExtArgs>>): Prisma__ArticleLogistiqueClient<$Result.GetResult<Prisma.$ArticleLogistiquePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MouvementLogistique model
   */ 
  interface MouvementLogistiqueFieldRefs {
    readonly id: FieldRef<"MouvementLogistique", 'String'>
    readonly articleId: FieldRef<"MouvementLogistique", 'String'>
    readonly type: FieldRef<"MouvementLogistique", 'String'>
    readonly quantite: FieldRef<"MouvementLogistique", 'Int'>
    readonly serviceDestinataire: FieldRef<"MouvementLogistique", 'String'>
    readonly motif: FieldRef<"MouvementLogistique", 'String'>
    readonly utilisateur: FieldRef<"MouvementLogistique", 'String'>
    readonly createdAt: FieldRef<"MouvementLogistique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MouvementLogistique findUnique
   */
  export type MouvementLogistiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which MouvementLogistique to fetch.
     */
    where: MouvementLogistiqueWhereUniqueInput
  }

  /**
   * MouvementLogistique findUniqueOrThrow
   */
  export type MouvementLogistiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which MouvementLogistique to fetch.
     */
    where: MouvementLogistiqueWhereUniqueInput
  }

  /**
   * MouvementLogistique findFirst
   */
  export type MouvementLogistiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which MouvementLogistique to fetch.
     */
    where?: MouvementLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementLogistiques to fetch.
     */
    orderBy?: MouvementLogistiqueOrderByWithRelationInput | MouvementLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementLogistiques.
     */
    cursor?: MouvementLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementLogistiques.
     */
    distinct?: MouvementLogistiqueScalarFieldEnum | MouvementLogistiqueScalarFieldEnum[]
  }

  /**
   * MouvementLogistique findFirstOrThrow
   */
  export type MouvementLogistiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which MouvementLogistique to fetch.
     */
    where?: MouvementLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementLogistiques to fetch.
     */
    orderBy?: MouvementLogistiqueOrderByWithRelationInput | MouvementLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementLogistiques.
     */
    cursor?: MouvementLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementLogistiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementLogistiques.
     */
    distinct?: MouvementLogistiqueScalarFieldEnum | MouvementLogistiqueScalarFieldEnum[]
  }

  /**
   * MouvementLogistique findMany
   */
  export type MouvementLogistiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter, which MouvementLogistiques to fetch.
     */
    where?: MouvementLogistiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementLogistiques to fetch.
     */
    orderBy?: MouvementLogistiqueOrderByWithRelationInput | MouvementLogistiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MouvementLogistiques.
     */
    cursor?: MouvementLogistiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementLogistiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementLogistiques.
     */
    skip?: number
    distinct?: MouvementLogistiqueScalarFieldEnum | MouvementLogistiqueScalarFieldEnum[]
  }

  /**
   * MouvementLogistique create
   */
  export type MouvementLogistiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a MouvementLogistique.
     */
    data: XOR<MouvementLogistiqueCreateInput, MouvementLogistiqueUncheckedCreateInput>
  }

  /**
   * MouvementLogistique createMany
   */
  export type MouvementLogistiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MouvementLogistiques.
     */
    data: MouvementLogistiqueCreateManyInput | MouvementLogistiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MouvementLogistique createManyAndReturn
   */
  export type MouvementLogistiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * The data used to create many MouvementLogistiques.
     */
    data: MouvementLogistiqueCreateManyInput | MouvementLogistiqueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementLogistique update
   */
  export type MouvementLogistiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a MouvementLogistique.
     */
    data: XOR<MouvementLogistiqueUpdateInput, MouvementLogistiqueUncheckedUpdateInput>
    /**
     * Choose, which MouvementLogistique to update.
     */
    where: MouvementLogistiqueWhereUniqueInput
  }

  /**
   * MouvementLogistique updateMany
   */
  export type MouvementLogistiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MouvementLogistiques.
     */
    data: XOR<MouvementLogistiqueUpdateManyMutationInput, MouvementLogistiqueUncheckedUpdateManyInput>
    /**
     * Filter which MouvementLogistiques to update
     */
    where?: MouvementLogistiqueWhereInput
  }

  /**
   * MouvementLogistique updateManyAndReturn
   */
  export type MouvementLogistiqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * The data used to update MouvementLogistiques.
     */
    data: XOR<MouvementLogistiqueUpdateManyMutationInput, MouvementLogistiqueUncheckedUpdateManyInput>
    /**
     * Filter which MouvementLogistiques to update
     */
    where?: MouvementLogistiqueWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementLogistique upsert
   */
  export type MouvementLogistiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the MouvementLogistique to update in case it exists.
     */
    where: MouvementLogistiqueWhereUniqueInput
    /**
     * In case the MouvementLogistique found by the `where` argument doesn't exist, create a new MouvementLogistique with this data.
     */
    create: XOR<MouvementLogistiqueCreateInput, MouvementLogistiqueUncheckedCreateInput>
    /**
     * In case the MouvementLogistique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MouvementLogistiqueUpdateInput, MouvementLogistiqueUncheckedUpdateInput>
  }

  /**
   * MouvementLogistique delete
   */
  export type MouvementLogistiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
    /**
     * Filter which MouvementLogistique to delete.
     */
    where: MouvementLogistiqueWhereUniqueInput
  }

  /**
   * MouvementLogistique deleteMany
   */
  export type MouvementLogistiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementLogistiques to delete
     */
    where?: MouvementLogistiqueWhereInput
  }

  /**
   * MouvementLogistique without action
   */
  export type MouvementLogistiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementLogistique
     */
    select?: MouvementLogistiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementLogistique
     */
    omit?: MouvementLogistiqueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementLogistiqueInclude<ExtArgs> | null
  }


  /**
   * Model DocumentGED
   */

  export type AggregateDocumentGED = {
    _count: DocumentGEDCountAggregateOutputType | null
    _min: DocumentGEDMinAggregateOutputType | null
    _max: DocumentGEDMaxAggregateOutputType | null
  }

  export type DocumentGEDMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    titre: string | null
    type: string | null
    url: string | null
    module: string | null
    createdAt: Date | null
  }

  export type DocumentGEDMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    titre: string | null
    type: string | null
    url: string | null
    module: string | null
    createdAt: Date | null
  }

  export type DocumentGEDCountAggregateOutputType = {
    id: number
    patientId: number
    titre: number
    type: number
    url: number
    module: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type DocumentGEDMinAggregateInputType = {
    id?: true
    patientId?: true
    titre?: true
    type?: true
    url?: true
    module?: true
    createdAt?: true
  }

  export type DocumentGEDMaxAggregateInputType = {
    id?: true
    patientId?: true
    titre?: true
    type?: true
    url?: true
    module?: true
    createdAt?: true
  }

  export type DocumentGEDCountAggregateInputType = {
    id?: true
    patientId?: true
    titre?: true
    type?: true
    url?: true
    module?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentGEDAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentGED to aggregate.
     */
    where?: DocumentGEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGEDS to fetch.
     */
    orderBy?: DocumentGEDOrderByWithRelationInput | DocumentGEDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentGEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentGEDS
    **/
    _count?: true | DocumentGEDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentGEDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentGEDMaxAggregateInputType
  }

  export type GetDocumentGEDAggregateType<T extends DocumentGEDAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentGED]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentGED[P]>
      : GetScalarType<T[P], AggregateDocumentGED[P]>
  }




  export type DocumentGEDGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentGEDWhereInput
    orderBy?: DocumentGEDOrderByWithAggregationInput | DocumentGEDOrderByWithAggregationInput[]
    by: DocumentGEDScalarFieldEnum[] | DocumentGEDScalarFieldEnum
    having?: DocumentGEDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentGEDCountAggregateInputType | true
    _min?: DocumentGEDMinAggregateInputType
    _max?: DocumentGEDMaxAggregateInputType
  }

  export type DocumentGEDGroupByOutputType = {
    id: string
    patientId: string | null
    titre: string
    type: string
    url: string
    module: string
    metadata: JsonValue | null
    createdAt: Date
    _count: DocumentGEDCountAggregateOutputType | null
    _min: DocumentGEDMinAggregateOutputType | null
    _max: DocumentGEDMaxAggregateOutputType | null
  }

  type GetDocumentGEDGroupByPayload<T extends DocumentGEDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGEDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGEDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGEDGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGEDGroupByOutputType[P]>
        }
      >
    >


  export type DocumentGEDSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    titre?: boolean
    type?: boolean
    url?: boolean
    module?: boolean
    metadata?: boolean
    createdAt?: boolean
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }, ExtArgs["result"]["documentGED"]>

  export type DocumentGEDSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    titre?: boolean
    type?: boolean
    url?: boolean
    module?: boolean
    metadata?: boolean
    createdAt?: boolean
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }, ExtArgs["result"]["documentGED"]>

  export type DocumentGEDSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    titre?: boolean
    type?: boolean
    url?: boolean
    module?: boolean
    metadata?: boolean
    createdAt?: boolean
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }, ExtArgs["result"]["documentGED"]>

  export type DocumentGEDSelectScalar = {
    id?: boolean
    patientId?: boolean
    titre?: boolean
    type?: boolean
    url?: boolean
    module?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type DocumentGEDOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "titre" | "type" | "url" | "module" | "metadata" | "createdAt", ExtArgs["result"]["documentGED"]>
  export type DocumentGEDInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }
  export type DocumentGEDIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }
  export type DocumentGEDIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | DocumentGED$patientArgs<ExtArgs>
  }

  export type $DocumentGEDPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentGED"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string | null
      titre: string
      type: string
      url: string
      module: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["documentGED"]>
    composites: {}
  }

  type DocumentGEDGetPayload<S extends boolean | null | undefined | DocumentGEDDefaultArgs> = $Result.GetResult<Prisma.$DocumentGEDPayload, S>

  type DocumentGEDCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentGEDFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentGEDCountAggregateInputType | true
    }

  export interface DocumentGEDDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentGED'], meta: { name: 'DocumentGED' } }
    /**
     * Find zero or one DocumentGED that matches the filter.
     * @param {DocumentGEDFindUniqueArgs} args - Arguments to find a DocumentGED
     * @example
     * // Get one DocumentGED
     * const documentGED = await prisma.documentGED.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentGEDFindUniqueArgs>(args: SelectSubset<T, DocumentGEDFindUniqueArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DocumentGED that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentGEDFindUniqueOrThrowArgs} args - Arguments to find a DocumentGED
     * @example
     * // Get one DocumentGED
     * const documentGED = await prisma.documentGED.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentGEDFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentGEDFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DocumentGED that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDFindFirstArgs} args - Arguments to find a DocumentGED
     * @example
     * // Get one DocumentGED
     * const documentGED = await prisma.documentGED.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentGEDFindFirstArgs>(args?: SelectSubset<T, DocumentGEDFindFirstArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DocumentGED that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDFindFirstOrThrowArgs} args - Arguments to find a DocumentGED
     * @example
     * // Get one DocumentGED
     * const documentGED = await prisma.documentGED.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentGEDFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentGEDFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DocumentGEDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentGEDS
     * const documentGEDS = await prisma.documentGED.findMany()
     * 
     * // Get first 10 DocumentGEDS
     * const documentGEDS = await prisma.documentGED.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentGEDWithIdOnly = await prisma.documentGED.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentGEDFindManyArgs>(args?: SelectSubset<T, DocumentGEDFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DocumentGED.
     * @param {DocumentGEDCreateArgs} args - Arguments to create a DocumentGED.
     * @example
     * // Create one DocumentGED
     * const DocumentGED = await prisma.documentGED.create({
     *   data: {
     *     // ... data to create a DocumentGED
     *   }
     * })
     * 
     */
    create<T extends DocumentGEDCreateArgs>(args: SelectSubset<T, DocumentGEDCreateArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DocumentGEDS.
     * @param {DocumentGEDCreateManyArgs} args - Arguments to create many DocumentGEDS.
     * @example
     * // Create many DocumentGEDS
     * const documentGED = await prisma.documentGED.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentGEDCreateManyArgs>(args?: SelectSubset<T, DocumentGEDCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentGEDS and returns the data saved in the database.
     * @param {DocumentGEDCreateManyAndReturnArgs} args - Arguments to create many DocumentGEDS.
     * @example
     * // Create many DocumentGEDS
     * const documentGED = await prisma.documentGED.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentGEDS and only return the `id`
     * const documentGEDWithIdOnly = await prisma.documentGED.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentGEDCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentGEDCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a DocumentGED.
     * @param {DocumentGEDDeleteArgs} args - Arguments to delete one DocumentGED.
     * @example
     * // Delete one DocumentGED
     * const DocumentGED = await prisma.documentGED.delete({
     *   where: {
     *     // ... filter to delete one DocumentGED
     *   }
     * })
     * 
     */
    delete<T extends DocumentGEDDeleteArgs>(args: SelectSubset<T, DocumentGEDDeleteArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DocumentGED.
     * @param {DocumentGEDUpdateArgs} args - Arguments to update one DocumentGED.
     * @example
     * // Update one DocumentGED
     * const documentGED = await prisma.documentGED.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentGEDUpdateArgs>(args: SelectSubset<T, DocumentGEDUpdateArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DocumentGEDS.
     * @param {DocumentGEDDeleteManyArgs} args - Arguments to filter DocumentGEDS to delete.
     * @example
     * // Delete a few DocumentGEDS
     * const { count } = await prisma.documentGED.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentGEDDeleteManyArgs>(args?: SelectSubset<T, DocumentGEDDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentGEDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentGEDS
     * const documentGED = await prisma.documentGED.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentGEDUpdateManyArgs>(args: SelectSubset<T, DocumentGEDUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentGEDS and returns the data updated in the database.
     * @param {DocumentGEDUpdateManyAndReturnArgs} args - Arguments to update many DocumentGEDS.
     * @example
     * // Update many DocumentGEDS
     * const documentGED = await prisma.documentGED.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentGEDS and only return the `id`
     * const documentGEDWithIdOnly = await prisma.documentGED.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentGEDUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentGEDUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one DocumentGED.
     * @param {DocumentGEDUpsertArgs} args - Arguments to update or create a DocumentGED.
     * @example
     * // Update or create a DocumentGED
     * const documentGED = await prisma.documentGED.upsert({
     *   create: {
     *     // ... data to create a DocumentGED
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentGED we want to update
     *   }
     * })
     */
    upsert<T extends DocumentGEDUpsertArgs>(args: SelectSubset<T, DocumentGEDUpsertArgs<ExtArgs>>): Prisma__DocumentGEDClient<$Result.GetResult<Prisma.$DocumentGEDPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DocumentGEDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDCountArgs} args - Arguments to filter DocumentGEDS to count.
     * @example
     * // Count the number of DocumentGEDS
     * const count = await prisma.documentGED.count({
     *   where: {
     *     // ... the filter for the DocumentGEDS we want to count
     *   }
     * })
    **/
    count<T extends DocumentGEDCountArgs>(
      args?: Subset<T, DocumentGEDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentGEDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentGED.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentGEDAggregateArgs>(args: Subset<T, DocumentGEDAggregateArgs>): Prisma.PrismaPromise<GetDocumentGEDAggregateType<T>>

    /**
     * Group by DocumentGED.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGEDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGEDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGEDGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGEDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGEDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGEDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentGED model
   */
  readonly fields: DocumentGEDFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentGED.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentGEDClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends DocumentGED$patientArgs<ExtArgs> = {}>(args?: Subset<T, DocumentGED$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentGED model
   */ 
  interface DocumentGEDFieldRefs {
    readonly id: FieldRef<"DocumentGED", 'String'>
    readonly patientId: FieldRef<"DocumentGED", 'String'>
    readonly titre: FieldRef<"DocumentGED", 'String'>
    readonly type: FieldRef<"DocumentGED", 'String'>
    readonly url: FieldRef<"DocumentGED", 'String'>
    readonly module: FieldRef<"DocumentGED", 'String'>
    readonly metadata: FieldRef<"DocumentGED", 'Json'>
    readonly createdAt: FieldRef<"DocumentGED", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentGED findUnique
   */
  export type DocumentGEDFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGED to fetch.
     */
    where: DocumentGEDWhereUniqueInput
  }

  /**
   * DocumentGED findUniqueOrThrow
   */
  export type DocumentGEDFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGED to fetch.
     */
    where: DocumentGEDWhereUniqueInput
  }

  /**
   * DocumentGED findFirst
   */
  export type DocumentGEDFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGED to fetch.
     */
    where?: DocumentGEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGEDS to fetch.
     */
    orderBy?: DocumentGEDOrderByWithRelationInput | DocumentGEDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentGEDS.
     */
    cursor?: DocumentGEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentGEDS.
     */
    distinct?: DocumentGEDScalarFieldEnum | DocumentGEDScalarFieldEnum[]
  }

  /**
   * DocumentGED findFirstOrThrow
   */
  export type DocumentGEDFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGED to fetch.
     */
    where?: DocumentGEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGEDS to fetch.
     */
    orderBy?: DocumentGEDOrderByWithRelationInput | DocumentGEDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentGEDS.
     */
    cursor?: DocumentGEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentGEDS.
     */
    distinct?: DocumentGEDScalarFieldEnum | DocumentGEDScalarFieldEnum[]
  }

  /**
   * DocumentGED findMany
   */
  export type DocumentGEDFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter, which DocumentGEDS to fetch.
     */
    where?: DocumentGEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentGEDS to fetch.
     */
    orderBy?: DocumentGEDOrderByWithRelationInput | DocumentGEDOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentGEDS.
     */
    cursor?: DocumentGEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentGEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentGEDS.
     */
    skip?: number
    distinct?: DocumentGEDScalarFieldEnum | DocumentGEDScalarFieldEnum[]
  }

  /**
   * DocumentGED create
   */
  export type DocumentGEDCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentGED.
     */
    data: XOR<DocumentGEDCreateInput, DocumentGEDUncheckedCreateInput>
  }

  /**
   * DocumentGED createMany
   */
  export type DocumentGEDCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentGEDS.
     */
    data: DocumentGEDCreateManyInput | DocumentGEDCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentGED createManyAndReturn
   */
  export type DocumentGEDCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentGEDS.
     */
    data: DocumentGEDCreateManyInput | DocumentGEDCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentGED update
   */
  export type DocumentGEDUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentGED.
     */
    data: XOR<DocumentGEDUpdateInput, DocumentGEDUncheckedUpdateInput>
    /**
     * Choose, which DocumentGED to update.
     */
    where: DocumentGEDWhereUniqueInput
  }

  /**
   * DocumentGED updateMany
   */
  export type DocumentGEDUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentGEDS.
     */
    data: XOR<DocumentGEDUpdateManyMutationInput, DocumentGEDUncheckedUpdateManyInput>
    /**
     * Filter which DocumentGEDS to update
     */
    where?: DocumentGEDWhereInput
  }

  /**
   * DocumentGED updateManyAndReturn
   */
  export type DocumentGEDUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * The data used to update DocumentGEDS.
     */
    data: XOR<DocumentGEDUpdateManyMutationInput, DocumentGEDUncheckedUpdateManyInput>
    /**
     * Filter which DocumentGEDS to update
     */
    where?: DocumentGEDWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentGED upsert
   */
  export type DocumentGEDUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentGED to update in case it exists.
     */
    where: DocumentGEDWhereUniqueInput
    /**
     * In case the DocumentGED found by the `where` argument doesn't exist, create a new DocumentGED with this data.
     */
    create: XOR<DocumentGEDCreateInput, DocumentGEDUncheckedCreateInput>
    /**
     * In case the DocumentGED was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentGEDUpdateInput, DocumentGEDUncheckedUpdateInput>
  }

  /**
   * DocumentGED delete
   */
  export type DocumentGEDDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
    /**
     * Filter which DocumentGED to delete.
     */
    where: DocumentGEDWhereUniqueInput
  }

  /**
   * DocumentGED deleteMany
   */
  export type DocumentGEDDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentGEDS to delete
     */
    where?: DocumentGEDWhereInput
  }

  /**
   * DocumentGED.patient
   */
  export type DocumentGED$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * DocumentGED without action
   */
  export type DocumentGEDDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentGED
     */
    select?: DocumentGEDSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentGED
     */
    omit?: DocumentGEDOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentGEDInclude<ExtArgs> | null
  }


  /**
   * Model Employe
   */

  export type AggregateEmploye = {
    _count: EmployeCountAggregateOutputType | null
    _avg: EmployeAvgAggregateOutputType | null
    _sum: EmployeSumAggregateOutputType | null
    _min: EmployeMinAggregateOutputType | null
    _max: EmployeMaxAggregateOutputType | null
  }

  export type EmployeAvgAggregateOutputType = {
    salaireBrut: Decimal | null
  }

  export type EmployeSumAggregateOutputType = {
    salaireBrut: Decimal | null
  }

  export type EmployeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    matricule: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: string | null
    telephone: string | null
    email: string | null
    adresse: string | null
    categorie: string | null
    fonction: string | null
    specialite: string | null
    dateEmbauche: Date | null
    typeContrat: string | null
    salaireBrut: Decimal | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    matricule: string | null
    nom: string | null
    prenom: string | null
    dateNaissance: Date | null
    sexe: string | null
    telephone: string | null
    email: string | null
    adresse: string | null
    categorie: string | null
    fonction: string | null
    specialite: string | null
    dateEmbauche: Date | null
    typeContrat: string | null
    salaireBrut: Decimal | null
    actif: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeCountAggregateOutputType = {
    id: number
    userId: number
    matricule: number
    nom: number
    prenom: number
    dateNaissance: number
    sexe: number
    telephone: number
    email: number
    adresse: number
    categorie: number
    fonction: number
    specialite: number
    dateEmbauche: number
    typeContrat: number
    salaireBrut: number
    actif: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeAvgAggregateInputType = {
    salaireBrut?: true
  }

  export type EmployeSumAggregateInputType = {
    salaireBrut?: true
  }

  export type EmployeMinAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    categorie?: true
    fonction?: true
    specialite?: true
    dateEmbauche?: true
    typeContrat?: true
    salaireBrut?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeMaxAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    categorie?: true
    fonction?: true
    specialite?: true
    dateEmbauche?: true
    typeContrat?: true
    salaireBrut?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeCountAggregateInputType = {
    id?: true
    userId?: true
    matricule?: true
    nom?: true
    prenom?: true
    dateNaissance?: true
    sexe?: true
    telephone?: true
    email?: true
    adresse?: true
    categorie?: true
    fonction?: true
    specialite?: true
    dateEmbauche?: true
    typeContrat?: true
    salaireBrut?: true
    actif?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employe to aggregate.
     */
    where?: EmployeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employes to fetch.
     */
    orderBy?: EmployeOrderByWithRelationInput | EmployeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employes
    **/
    _count?: true | EmployeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeMaxAggregateInputType
  }

  export type GetEmployeAggregateType<T extends EmployeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploye]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploye[P]>
      : GetScalarType<T[P], AggregateEmploye[P]>
  }




  export type EmployeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeWhereInput
    orderBy?: EmployeOrderByWithAggregationInput | EmployeOrderByWithAggregationInput[]
    by: EmployeScalarFieldEnum[] | EmployeScalarFieldEnum
    having?: EmployeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeCountAggregateInputType | true
    _avg?: EmployeAvgAggregateInputType
    _sum?: EmployeSumAggregateInputType
    _min?: EmployeMinAggregateInputType
    _max?: EmployeMaxAggregateInputType
  }

  export type EmployeGroupByOutputType = {
    id: string
    userId: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date
    sexe: string
    telephone: string
    email: string | null
    adresse: string | null
    categorie: string
    fonction: string
    specialite: string | null
    dateEmbauche: Date
    typeContrat: string
    salaireBrut: Decimal
    actif: boolean
    createdAt: Date
    updatedAt: Date
    _count: EmployeCountAggregateOutputType | null
    _avg: EmployeAvgAggregateOutputType | null
    _sum: EmployeSumAggregateOutputType | null
    _min: EmployeMinAggregateOutputType | null
    _max: EmployeMaxAggregateOutputType | null
  }

  type GetEmployeGroupByPayload<T extends EmployeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    categorie?: boolean
    fonction?: boolean
    specialite?: boolean
    dateEmbauche?: boolean
    typeContrat?: boolean
    salaireBrut?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employe$userArgs<ExtArgs>
    conges?: boolean | Employe$congesArgs<ExtArgs>
    plannings?: boolean | Employe$planningsArgs<ExtArgs>
    bulletins?: boolean | Employe$bulletinsArgs<ExtArgs>
    _count?: boolean | EmployeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employe"]>

  export type EmployeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    categorie?: boolean
    fonction?: boolean
    specialite?: boolean
    dateEmbauche?: boolean
    typeContrat?: boolean
    salaireBrut?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employe$userArgs<ExtArgs>
  }, ExtArgs["result"]["employe"]>

  export type EmployeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    categorie?: boolean
    fonction?: boolean
    specialite?: boolean
    dateEmbauche?: boolean
    typeContrat?: boolean
    salaireBrut?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employe$userArgs<ExtArgs>
  }, ExtArgs["result"]["employe"]>

  export type EmployeSelectScalar = {
    id?: boolean
    userId?: boolean
    matricule?: boolean
    nom?: boolean
    prenom?: boolean
    dateNaissance?: boolean
    sexe?: boolean
    telephone?: boolean
    email?: boolean
    adresse?: boolean
    categorie?: boolean
    fonction?: boolean
    specialite?: boolean
    dateEmbauche?: boolean
    typeContrat?: boolean
    salaireBrut?: boolean
    actif?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "matricule" | "nom" | "prenom" | "dateNaissance" | "sexe" | "telephone" | "email" | "adresse" | "categorie" | "fonction" | "specialite" | "dateEmbauche" | "typeContrat" | "salaireBrut" | "actif" | "createdAt" | "updatedAt", ExtArgs["result"]["employe"]>
  export type EmployeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employe$userArgs<ExtArgs>
    conges?: boolean | Employe$congesArgs<ExtArgs>
    plannings?: boolean | Employe$planningsArgs<ExtArgs>
    bulletins?: boolean | Employe$bulletinsArgs<ExtArgs>
    _count?: boolean | EmployeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employe$userArgs<ExtArgs>
  }
  export type EmployeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employe$userArgs<ExtArgs>
  }

  export type $EmployePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employe"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      conges: Prisma.$CongePayload<ExtArgs>[]
      plannings: Prisma.$PlanningPayload<ExtArgs>[]
      bulletins: Prisma.$BulletinPaiePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      matricule: string
      nom: string
      prenom: string
      dateNaissance: Date
      sexe: string
      telephone: string
      email: string | null
      adresse: string | null
      categorie: string
      fonction: string
      specialite: string | null
      dateEmbauche: Date
      typeContrat: string
      salaireBrut: Prisma.Decimal
      actif: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employe"]>
    composites: {}
  }

  type EmployeGetPayload<S extends boolean | null | undefined | EmployeDefaultArgs> = $Result.GetResult<Prisma.$EmployePayload, S>

  type EmployeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeCountAggregateInputType | true
    }

  export interface EmployeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employe'], meta: { name: 'Employe' } }
    /**
     * Find zero or one Employe that matches the filter.
     * @param {EmployeFindUniqueArgs} args - Arguments to find a Employe
     * @example
     * // Get one Employe
     * const employe = await prisma.employe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeFindUniqueArgs>(args: SelectSubset<T, EmployeFindUniqueArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Employe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeFindUniqueOrThrowArgs} args - Arguments to find a Employe
     * @example
     * // Get one Employe
     * const employe = await prisma.employe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Employe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeFindFirstArgs} args - Arguments to find a Employe
     * @example
     * // Get one Employe
     * const employe = await prisma.employe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeFindFirstArgs>(args?: SelectSubset<T, EmployeFindFirstArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Employe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeFindFirstOrThrowArgs} args - Arguments to find a Employe
     * @example
     * // Get one Employe
     * const employe = await prisma.employe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Employes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employes
     * const employes = await prisma.employe.findMany()
     * 
     * // Get first 10 Employes
     * const employes = await prisma.employe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeWithIdOnly = await prisma.employe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeFindManyArgs>(args?: SelectSubset<T, EmployeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Employe.
     * @param {EmployeCreateArgs} args - Arguments to create a Employe.
     * @example
     * // Create one Employe
     * const Employe = await prisma.employe.create({
     *   data: {
     *     // ... data to create a Employe
     *   }
     * })
     * 
     */
    create<T extends EmployeCreateArgs>(args: SelectSubset<T, EmployeCreateArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Employes.
     * @param {EmployeCreateManyArgs} args - Arguments to create many Employes.
     * @example
     * // Create many Employes
     * const employe = await prisma.employe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeCreateManyArgs>(args?: SelectSubset<T, EmployeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employes and returns the data saved in the database.
     * @param {EmployeCreateManyAndReturnArgs} args - Arguments to create many Employes.
     * @example
     * // Create many Employes
     * const employe = await prisma.employe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employes and only return the `id`
     * const employeWithIdOnly = await prisma.employe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Employe.
     * @param {EmployeDeleteArgs} args - Arguments to delete one Employe.
     * @example
     * // Delete one Employe
     * const Employe = await prisma.employe.delete({
     *   where: {
     *     // ... filter to delete one Employe
     *   }
     * })
     * 
     */
    delete<T extends EmployeDeleteArgs>(args: SelectSubset<T, EmployeDeleteArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Employe.
     * @param {EmployeUpdateArgs} args - Arguments to update one Employe.
     * @example
     * // Update one Employe
     * const employe = await prisma.employe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeUpdateArgs>(args: SelectSubset<T, EmployeUpdateArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Employes.
     * @param {EmployeDeleteManyArgs} args - Arguments to filter Employes to delete.
     * @example
     * // Delete a few Employes
     * const { count } = await prisma.employe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeDeleteManyArgs>(args?: SelectSubset<T, EmployeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employes
     * const employe = await prisma.employe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeUpdateManyArgs>(args: SelectSubset<T, EmployeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employes and returns the data updated in the database.
     * @param {EmployeUpdateManyAndReturnArgs} args - Arguments to update many Employes.
     * @example
     * // Update many Employes
     * const employe = await prisma.employe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employes and only return the `id`
     * const employeWithIdOnly = await prisma.employe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Employe.
     * @param {EmployeUpsertArgs} args - Arguments to update or create a Employe.
     * @example
     * // Update or create a Employe
     * const employe = await prisma.employe.upsert({
     *   create: {
     *     // ... data to create a Employe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employe we want to update
     *   }
     * })
     */
    upsert<T extends EmployeUpsertArgs>(args: SelectSubset<T, EmployeUpsertArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Employes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeCountArgs} args - Arguments to filter Employes to count.
     * @example
     * // Count the number of Employes
     * const count = await prisma.employe.count({
     *   where: {
     *     // ... the filter for the Employes we want to count
     *   }
     * })
    **/
    count<T extends EmployeCountArgs>(
      args?: Subset<T, EmployeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeAggregateArgs>(args: Subset<T, EmployeAggregateArgs>): Prisma.PrismaPromise<GetEmployeAggregateType<T>>

    /**
     * Group by Employe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employe model
   */
  readonly fields: EmployeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Employe$userArgs<ExtArgs> = {}>(args?: Subset<T, Employe$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    conges<T extends Employe$congesArgs<ExtArgs> = {}>(args?: Subset<T, Employe$congesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    plannings<T extends Employe$planningsArgs<ExtArgs> = {}>(args?: Subset<T, Employe$planningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    bulletins<T extends Employe$bulletinsArgs<ExtArgs> = {}>(args?: Subset<T, Employe$bulletinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employe model
   */ 
  interface EmployeFieldRefs {
    readonly id: FieldRef<"Employe", 'String'>
    readonly userId: FieldRef<"Employe", 'String'>
    readonly matricule: FieldRef<"Employe", 'String'>
    readonly nom: FieldRef<"Employe", 'String'>
    readonly prenom: FieldRef<"Employe", 'String'>
    readonly dateNaissance: FieldRef<"Employe", 'DateTime'>
    readonly sexe: FieldRef<"Employe", 'String'>
    readonly telephone: FieldRef<"Employe", 'String'>
    readonly email: FieldRef<"Employe", 'String'>
    readonly adresse: FieldRef<"Employe", 'String'>
    readonly categorie: FieldRef<"Employe", 'String'>
    readonly fonction: FieldRef<"Employe", 'String'>
    readonly specialite: FieldRef<"Employe", 'String'>
    readonly dateEmbauche: FieldRef<"Employe", 'DateTime'>
    readonly typeContrat: FieldRef<"Employe", 'String'>
    readonly salaireBrut: FieldRef<"Employe", 'Decimal'>
    readonly actif: FieldRef<"Employe", 'Boolean'>
    readonly createdAt: FieldRef<"Employe", 'DateTime'>
    readonly updatedAt: FieldRef<"Employe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employe findUnique
   */
  export type EmployeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter, which Employe to fetch.
     */
    where: EmployeWhereUniqueInput
  }

  /**
   * Employe findUniqueOrThrow
   */
  export type EmployeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter, which Employe to fetch.
     */
    where: EmployeWhereUniqueInput
  }

  /**
   * Employe findFirst
   */
  export type EmployeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter, which Employe to fetch.
     */
    where?: EmployeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employes to fetch.
     */
    orderBy?: EmployeOrderByWithRelationInput | EmployeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employes.
     */
    cursor?: EmployeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employes.
     */
    distinct?: EmployeScalarFieldEnum | EmployeScalarFieldEnum[]
  }

  /**
   * Employe findFirstOrThrow
   */
  export type EmployeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter, which Employe to fetch.
     */
    where?: EmployeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employes to fetch.
     */
    orderBy?: EmployeOrderByWithRelationInput | EmployeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employes.
     */
    cursor?: EmployeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employes.
     */
    distinct?: EmployeScalarFieldEnum | EmployeScalarFieldEnum[]
  }

  /**
   * Employe findMany
   */
  export type EmployeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter, which Employes to fetch.
     */
    where?: EmployeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employes to fetch.
     */
    orderBy?: EmployeOrderByWithRelationInput | EmployeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employes.
     */
    cursor?: EmployeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employes.
     */
    skip?: number
    distinct?: EmployeScalarFieldEnum | EmployeScalarFieldEnum[]
  }

  /**
   * Employe create
   */
  export type EmployeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employe.
     */
    data: XOR<EmployeCreateInput, EmployeUncheckedCreateInput>
  }

  /**
   * Employe createMany
   */
  export type EmployeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employes.
     */
    data: EmployeCreateManyInput | EmployeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employe createManyAndReturn
   */
  export type EmployeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * The data used to create many Employes.
     */
    data: EmployeCreateManyInput | EmployeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employe update
   */
  export type EmployeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employe.
     */
    data: XOR<EmployeUpdateInput, EmployeUncheckedUpdateInput>
    /**
     * Choose, which Employe to update.
     */
    where: EmployeWhereUniqueInput
  }

  /**
   * Employe updateMany
   */
  export type EmployeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employes.
     */
    data: XOR<EmployeUpdateManyMutationInput, EmployeUncheckedUpdateManyInput>
    /**
     * Filter which Employes to update
     */
    where?: EmployeWhereInput
  }

  /**
   * Employe updateManyAndReturn
   */
  export type EmployeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * The data used to update Employes.
     */
    data: XOR<EmployeUpdateManyMutationInput, EmployeUncheckedUpdateManyInput>
    /**
     * Filter which Employes to update
     */
    where?: EmployeWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employe upsert
   */
  export type EmployeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employe to update in case it exists.
     */
    where: EmployeWhereUniqueInput
    /**
     * In case the Employe found by the `where` argument doesn't exist, create a new Employe with this data.
     */
    create: XOR<EmployeCreateInput, EmployeUncheckedCreateInput>
    /**
     * In case the Employe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeUpdateInput, EmployeUncheckedUpdateInput>
  }

  /**
   * Employe delete
   */
  export type EmployeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
    /**
     * Filter which Employe to delete.
     */
    where: EmployeWhereUniqueInput
  }

  /**
   * Employe deleteMany
   */
  export type EmployeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employes to delete
     */
    where?: EmployeWhereInput
  }

  /**
   * Employe.user
   */
  export type Employe$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employe.conges
   */
  export type Employe$congesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    where?: CongeWhereInput
    orderBy?: CongeOrderByWithRelationInput | CongeOrderByWithRelationInput[]
    cursor?: CongeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CongeScalarFieldEnum | CongeScalarFieldEnum[]
  }

  /**
   * Employe.plannings
   */
  export type Employe$planningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    cursor?: PlanningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Employe.bulletins
   */
  export type Employe$bulletinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    where?: BulletinPaieWhereInput
    orderBy?: BulletinPaieOrderByWithRelationInput | BulletinPaieOrderByWithRelationInput[]
    cursor?: BulletinPaieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BulletinPaieScalarFieldEnum | BulletinPaieScalarFieldEnum[]
  }

  /**
   * Employe without action
   */
  export type EmployeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employe
     */
    select?: EmployeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employe
     */
    omit?: EmployeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeInclude<ExtArgs> | null
  }


  /**
   * Model Conge
   */

  export type AggregateConge = {
    _count: CongeCountAggregateOutputType | null
    _avg: CongeAvgAggregateOutputType | null
    _sum: CongeSumAggregateOutputType | null
    _min: CongeMinAggregateOutputType | null
    _max: CongeMaxAggregateOutputType | null
  }

  export type CongeAvgAggregateOutputType = {
    nbJours: number | null
  }

  export type CongeSumAggregateOutputType = {
    nbJours: number | null
  }

  export type CongeMinAggregateOutputType = {
    id: string | null
    employeId: string | null
    type: string | null
    dateDebut: Date | null
    dateFin: Date | null
    nbJours: number | null
    motif: string | null
    statut: string | null
    createdAt: Date | null
  }

  export type CongeMaxAggregateOutputType = {
    id: string | null
    employeId: string | null
    type: string | null
    dateDebut: Date | null
    dateFin: Date | null
    nbJours: number | null
    motif: string | null
    statut: string | null
    createdAt: Date | null
  }

  export type CongeCountAggregateOutputType = {
    id: number
    employeId: number
    type: number
    dateDebut: number
    dateFin: number
    nbJours: number
    motif: number
    statut: number
    createdAt: number
    _all: number
  }


  export type CongeAvgAggregateInputType = {
    nbJours?: true
  }

  export type CongeSumAggregateInputType = {
    nbJours?: true
  }

  export type CongeMinAggregateInputType = {
    id?: true
    employeId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    nbJours?: true
    motif?: true
    statut?: true
    createdAt?: true
  }

  export type CongeMaxAggregateInputType = {
    id?: true
    employeId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    nbJours?: true
    motif?: true
    statut?: true
    createdAt?: true
  }

  export type CongeCountAggregateInputType = {
    id?: true
    employeId?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    nbJours?: true
    motif?: true
    statut?: true
    createdAt?: true
    _all?: true
  }

  export type CongeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conge to aggregate.
     */
    where?: CongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conges to fetch.
     */
    orderBy?: CongeOrderByWithRelationInput | CongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conges
    **/
    _count?: true | CongeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CongeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CongeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CongeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CongeMaxAggregateInputType
  }

  export type GetCongeAggregateType<T extends CongeAggregateArgs> = {
        [P in keyof T & keyof AggregateConge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConge[P]>
      : GetScalarType<T[P], AggregateConge[P]>
  }




  export type CongeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CongeWhereInput
    orderBy?: CongeOrderByWithAggregationInput | CongeOrderByWithAggregationInput[]
    by: CongeScalarFieldEnum[] | CongeScalarFieldEnum
    having?: CongeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CongeCountAggregateInputType | true
    _avg?: CongeAvgAggregateInputType
    _sum?: CongeSumAggregateInputType
    _min?: CongeMinAggregateInputType
    _max?: CongeMaxAggregateInputType
  }

  export type CongeGroupByOutputType = {
    id: string
    employeId: string
    type: string
    dateDebut: Date
    dateFin: Date
    nbJours: number
    motif: string | null
    statut: string
    createdAt: Date
    _count: CongeCountAggregateOutputType | null
    _avg: CongeAvgAggregateOutputType | null
    _sum: CongeSumAggregateOutputType | null
    _min: CongeMinAggregateOutputType | null
    _max: CongeMaxAggregateOutputType | null
  }

  type GetCongeGroupByPayload<T extends CongeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CongeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CongeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CongeGroupByOutputType[P]>
            : GetScalarType<T[P], CongeGroupByOutputType[P]>
        }
      >
    >


  export type CongeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nbJours?: boolean
    motif?: boolean
    statut?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conge"]>

  export type CongeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nbJours?: boolean
    motif?: boolean
    statut?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conge"]>

  export type CongeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nbJours?: boolean
    motif?: boolean
    statut?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conge"]>

  export type CongeSelectScalar = {
    id?: boolean
    employeId?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    nbJours?: boolean
    motif?: boolean
    statut?: boolean
    createdAt?: boolean
  }

  export type CongeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "type" | "dateDebut" | "dateFin" | "nbJours" | "motif" | "statut" | "createdAt", ExtArgs["result"]["conge"]>
  export type CongeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }
  export type CongeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }
  export type CongeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }

  export type $CongePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conge"
    objects: {
      employe: Prisma.$EmployePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeId: string
      type: string
      dateDebut: Date
      dateFin: Date
      nbJours: number
      motif: string | null
      statut: string
      createdAt: Date
    }, ExtArgs["result"]["conge"]>
    composites: {}
  }

  type CongeGetPayload<S extends boolean | null | undefined | CongeDefaultArgs> = $Result.GetResult<Prisma.$CongePayload, S>

  type CongeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CongeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CongeCountAggregateInputType | true
    }

  export interface CongeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conge'], meta: { name: 'Conge' } }
    /**
     * Find zero or one Conge that matches the filter.
     * @param {CongeFindUniqueArgs} args - Arguments to find a Conge
     * @example
     * // Get one Conge
     * const conge = await prisma.conge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CongeFindUniqueArgs>(args: SelectSubset<T, CongeFindUniqueArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Conge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CongeFindUniqueOrThrowArgs} args - Arguments to find a Conge
     * @example
     * // Get one Conge
     * const conge = await prisma.conge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CongeFindUniqueOrThrowArgs>(args: SelectSubset<T, CongeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Conge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeFindFirstArgs} args - Arguments to find a Conge
     * @example
     * // Get one Conge
     * const conge = await prisma.conge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CongeFindFirstArgs>(args?: SelectSubset<T, CongeFindFirstArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Conge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeFindFirstOrThrowArgs} args - Arguments to find a Conge
     * @example
     * // Get one Conge
     * const conge = await prisma.conge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CongeFindFirstOrThrowArgs>(args?: SelectSubset<T, CongeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Conges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conges
     * const conges = await prisma.conge.findMany()
     * 
     * // Get first 10 Conges
     * const conges = await prisma.conge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const congeWithIdOnly = await prisma.conge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CongeFindManyArgs>(args?: SelectSubset<T, CongeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Conge.
     * @param {CongeCreateArgs} args - Arguments to create a Conge.
     * @example
     * // Create one Conge
     * const Conge = await prisma.conge.create({
     *   data: {
     *     // ... data to create a Conge
     *   }
     * })
     * 
     */
    create<T extends CongeCreateArgs>(args: SelectSubset<T, CongeCreateArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Conges.
     * @param {CongeCreateManyArgs} args - Arguments to create many Conges.
     * @example
     * // Create many Conges
     * const conge = await prisma.conge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CongeCreateManyArgs>(args?: SelectSubset<T, CongeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conges and returns the data saved in the database.
     * @param {CongeCreateManyAndReturnArgs} args - Arguments to create many Conges.
     * @example
     * // Create many Conges
     * const conge = await prisma.conge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conges and only return the `id`
     * const congeWithIdOnly = await prisma.conge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CongeCreateManyAndReturnArgs>(args?: SelectSubset<T, CongeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Conge.
     * @param {CongeDeleteArgs} args - Arguments to delete one Conge.
     * @example
     * // Delete one Conge
     * const Conge = await prisma.conge.delete({
     *   where: {
     *     // ... filter to delete one Conge
     *   }
     * })
     * 
     */
    delete<T extends CongeDeleteArgs>(args: SelectSubset<T, CongeDeleteArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Conge.
     * @param {CongeUpdateArgs} args - Arguments to update one Conge.
     * @example
     * // Update one Conge
     * const conge = await prisma.conge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CongeUpdateArgs>(args: SelectSubset<T, CongeUpdateArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Conges.
     * @param {CongeDeleteManyArgs} args - Arguments to filter Conges to delete.
     * @example
     * // Delete a few Conges
     * const { count } = await prisma.conge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CongeDeleteManyArgs>(args?: SelectSubset<T, CongeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conges
     * const conge = await prisma.conge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CongeUpdateManyArgs>(args: SelectSubset<T, CongeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conges and returns the data updated in the database.
     * @param {CongeUpdateManyAndReturnArgs} args - Arguments to update many Conges.
     * @example
     * // Update many Conges
     * const conge = await prisma.conge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conges and only return the `id`
     * const congeWithIdOnly = await prisma.conge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CongeUpdateManyAndReturnArgs>(args: SelectSubset<T, CongeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Conge.
     * @param {CongeUpsertArgs} args - Arguments to update or create a Conge.
     * @example
     * // Update or create a Conge
     * const conge = await prisma.conge.upsert({
     *   create: {
     *     // ... data to create a Conge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conge we want to update
     *   }
     * })
     */
    upsert<T extends CongeUpsertArgs>(args: SelectSubset<T, CongeUpsertArgs<ExtArgs>>): Prisma__CongeClient<$Result.GetResult<Prisma.$CongePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Conges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeCountArgs} args - Arguments to filter Conges to count.
     * @example
     * // Count the number of Conges
     * const count = await prisma.conge.count({
     *   where: {
     *     // ... the filter for the Conges we want to count
     *   }
     * })
    **/
    count<T extends CongeCountArgs>(
      args?: Subset<T, CongeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CongeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CongeAggregateArgs>(args: Subset<T, CongeAggregateArgs>): Prisma.PrismaPromise<GetCongeAggregateType<T>>

    /**
     * Group by Conge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CongeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CongeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CongeGroupByArgs['orderBy'] }
        : { orderBy?: CongeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CongeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCongeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conge model
   */
  readonly fields: CongeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CongeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employe<T extends EmployeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeDefaultArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conge model
   */ 
  interface CongeFieldRefs {
    readonly id: FieldRef<"Conge", 'String'>
    readonly employeId: FieldRef<"Conge", 'String'>
    readonly type: FieldRef<"Conge", 'String'>
    readonly dateDebut: FieldRef<"Conge", 'DateTime'>
    readonly dateFin: FieldRef<"Conge", 'DateTime'>
    readonly nbJours: FieldRef<"Conge", 'Int'>
    readonly motif: FieldRef<"Conge", 'String'>
    readonly statut: FieldRef<"Conge", 'String'>
    readonly createdAt: FieldRef<"Conge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conge findUnique
   */
  export type CongeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter, which Conge to fetch.
     */
    where: CongeWhereUniqueInput
  }

  /**
   * Conge findUniqueOrThrow
   */
  export type CongeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter, which Conge to fetch.
     */
    where: CongeWhereUniqueInput
  }

  /**
   * Conge findFirst
   */
  export type CongeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter, which Conge to fetch.
     */
    where?: CongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conges to fetch.
     */
    orderBy?: CongeOrderByWithRelationInput | CongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conges.
     */
    cursor?: CongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conges.
     */
    distinct?: CongeScalarFieldEnum | CongeScalarFieldEnum[]
  }

  /**
   * Conge findFirstOrThrow
   */
  export type CongeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter, which Conge to fetch.
     */
    where?: CongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conges to fetch.
     */
    orderBy?: CongeOrderByWithRelationInput | CongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conges.
     */
    cursor?: CongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conges.
     */
    distinct?: CongeScalarFieldEnum | CongeScalarFieldEnum[]
  }

  /**
   * Conge findMany
   */
  export type CongeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter, which Conges to fetch.
     */
    where?: CongeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conges to fetch.
     */
    orderBy?: CongeOrderByWithRelationInput | CongeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conges.
     */
    cursor?: CongeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conges.
     */
    skip?: number
    distinct?: CongeScalarFieldEnum | CongeScalarFieldEnum[]
  }

  /**
   * Conge create
   */
  export type CongeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * The data needed to create a Conge.
     */
    data: XOR<CongeCreateInput, CongeUncheckedCreateInput>
  }

  /**
   * Conge createMany
   */
  export type CongeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conges.
     */
    data: CongeCreateManyInput | CongeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conge createManyAndReturn
   */
  export type CongeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * The data used to create many Conges.
     */
    data: CongeCreateManyInput | CongeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conge update
   */
  export type CongeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * The data needed to update a Conge.
     */
    data: XOR<CongeUpdateInput, CongeUncheckedUpdateInput>
    /**
     * Choose, which Conge to update.
     */
    where: CongeWhereUniqueInput
  }

  /**
   * Conge updateMany
   */
  export type CongeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conges.
     */
    data: XOR<CongeUpdateManyMutationInput, CongeUncheckedUpdateManyInput>
    /**
     * Filter which Conges to update
     */
    where?: CongeWhereInput
  }

  /**
   * Conge updateManyAndReturn
   */
  export type CongeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * The data used to update Conges.
     */
    data: XOR<CongeUpdateManyMutationInput, CongeUncheckedUpdateManyInput>
    /**
     * Filter which Conges to update
     */
    where?: CongeWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conge upsert
   */
  export type CongeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * The filter to search for the Conge to update in case it exists.
     */
    where: CongeWhereUniqueInput
    /**
     * In case the Conge found by the `where` argument doesn't exist, create a new Conge with this data.
     */
    create: XOR<CongeCreateInput, CongeUncheckedCreateInput>
    /**
     * In case the Conge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CongeUpdateInput, CongeUncheckedUpdateInput>
  }

  /**
   * Conge delete
   */
  export type CongeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
    /**
     * Filter which Conge to delete.
     */
    where: CongeWhereUniqueInput
  }

  /**
   * Conge deleteMany
   */
  export type CongeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conges to delete
     */
    where?: CongeWhereInput
  }

  /**
   * Conge without action
   */
  export type CongeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conge
     */
    select?: CongeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conge
     */
    omit?: CongeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CongeInclude<ExtArgs> | null
  }


  /**
   * Model BulletinPaie
   */

  export type AggregateBulletinPaie = {
    _count: BulletinPaieCountAggregateOutputType | null
    _avg: BulletinPaieAvgAggregateOutputType | null
    _sum: BulletinPaieSumAggregateOutputType | null
    _min: BulletinPaieMinAggregateOutputType | null
    _max: BulletinPaieMaxAggregateOutputType | null
  }

  export type BulletinPaieAvgAggregateOutputType = {
    salaireBase: Decimal | null
    totalPrimes: Decimal | null
    totalRetenues: Decimal | null
    salaireNet: Decimal | null
  }

  export type BulletinPaieSumAggregateOutputType = {
    salaireBase: Decimal | null
    totalPrimes: Decimal | null
    totalRetenues: Decimal | null
    salaireNet: Decimal | null
  }

  export type BulletinPaieMinAggregateOutputType = {
    id: string | null
    employeId: string | null
    periode: string | null
    dateEmission: Date | null
    salaireBase: Decimal | null
    totalPrimes: Decimal | null
    totalRetenues: Decimal | null
    salaireNet: Decimal | null
    statut: string | null
  }

  export type BulletinPaieMaxAggregateOutputType = {
    id: string | null
    employeId: string | null
    periode: string | null
    dateEmission: Date | null
    salaireBase: Decimal | null
    totalPrimes: Decimal | null
    totalRetenues: Decimal | null
    salaireNet: Decimal | null
    statut: string | null
  }

  export type BulletinPaieCountAggregateOutputType = {
    id: number
    employeId: number
    periode: number
    dateEmission: number
    salaireBase: number
    totalPrimes: number
    totalRetenues: number
    salaireNet: number
    statut: number
    _all: number
  }


  export type BulletinPaieAvgAggregateInputType = {
    salaireBase?: true
    totalPrimes?: true
    totalRetenues?: true
    salaireNet?: true
  }

  export type BulletinPaieSumAggregateInputType = {
    salaireBase?: true
    totalPrimes?: true
    totalRetenues?: true
    salaireNet?: true
  }

  export type BulletinPaieMinAggregateInputType = {
    id?: true
    employeId?: true
    periode?: true
    dateEmission?: true
    salaireBase?: true
    totalPrimes?: true
    totalRetenues?: true
    salaireNet?: true
    statut?: true
  }

  export type BulletinPaieMaxAggregateInputType = {
    id?: true
    employeId?: true
    periode?: true
    dateEmission?: true
    salaireBase?: true
    totalPrimes?: true
    totalRetenues?: true
    salaireNet?: true
    statut?: true
  }

  export type BulletinPaieCountAggregateInputType = {
    id?: true
    employeId?: true
    periode?: true
    dateEmission?: true
    salaireBase?: true
    totalPrimes?: true
    totalRetenues?: true
    salaireNet?: true
    statut?: true
    _all?: true
  }

  export type BulletinPaieAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulletinPaie to aggregate.
     */
    where?: BulletinPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulletinPaies to fetch.
     */
    orderBy?: BulletinPaieOrderByWithRelationInput | BulletinPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BulletinPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulletinPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulletinPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BulletinPaies
    **/
    _count?: true | BulletinPaieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BulletinPaieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BulletinPaieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BulletinPaieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BulletinPaieMaxAggregateInputType
  }

  export type GetBulletinPaieAggregateType<T extends BulletinPaieAggregateArgs> = {
        [P in keyof T & keyof AggregateBulletinPaie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBulletinPaie[P]>
      : GetScalarType<T[P], AggregateBulletinPaie[P]>
  }




  export type BulletinPaieGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BulletinPaieWhereInput
    orderBy?: BulletinPaieOrderByWithAggregationInput | BulletinPaieOrderByWithAggregationInput[]
    by: BulletinPaieScalarFieldEnum[] | BulletinPaieScalarFieldEnum
    having?: BulletinPaieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BulletinPaieCountAggregateInputType | true
    _avg?: BulletinPaieAvgAggregateInputType
    _sum?: BulletinPaieSumAggregateInputType
    _min?: BulletinPaieMinAggregateInputType
    _max?: BulletinPaieMaxAggregateInputType
  }

  export type BulletinPaieGroupByOutputType = {
    id: string
    employeId: string
    periode: string
    dateEmission: Date
    salaireBase: Decimal
    totalPrimes: Decimal
    totalRetenues: Decimal
    salaireNet: Decimal
    statut: string
    _count: BulletinPaieCountAggregateOutputType | null
    _avg: BulletinPaieAvgAggregateOutputType | null
    _sum: BulletinPaieSumAggregateOutputType | null
    _min: BulletinPaieMinAggregateOutputType | null
    _max: BulletinPaieMaxAggregateOutputType | null
  }

  type GetBulletinPaieGroupByPayload<T extends BulletinPaieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BulletinPaieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BulletinPaieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BulletinPaieGroupByOutputType[P]>
            : GetScalarType<T[P], BulletinPaieGroupByOutputType[P]>
        }
      >
    >


  export type BulletinPaieSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    periode?: boolean
    dateEmission?: boolean
    salaireBase?: boolean
    totalPrimes?: boolean
    totalRetenues?: boolean
    salaireNet?: boolean
    statut?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
    lignes?: boolean | BulletinPaie$lignesArgs<ExtArgs>
    _count?: boolean | BulletinPaieCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulletinPaie"]>

  export type BulletinPaieSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    periode?: boolean
    dateEmission?: boolean
    salaireBase?: boolean
    totalPrimes?: boolean
    totalRetenues?: boolean
    salaireNet?: boolean
    statut?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulletinPaie"]>

  export type BulletinPaieSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    periode?: boolean
    dateEmission?: boolean
    salaireBase?: boolean
    totalPrimes?: boolean
    totalRetenues?: boolean
    salaireNet?: boolean
    statut?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bulletinPaie"]>

  export type BulletinPaieSelectScalar = {
    id?: boolean
    employeId?: boolean
    periode?: boolean
    dateEmission?: boolean
    salaireBase?: boolean
    totalPrimes?: boolean
    totalRetenues?: boolean
    salaireNet?: boolean
    statut?: boolean
  }

  export type BulletinPaieOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "periode" | "dateEmission" | "salaireBase" | "totalPrimes" | "totalRetenues" | "salaireNet" | "statut", ExtArgs["result"]["bulletinPaie"]>
  export type BulletinPaieInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
    lignes?: boolean | BulletinPaie$lignesArgs<ExtArgs>
    _count?: boolean | BulletinPaieCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BulletinPaieIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }
  export type BulletinPaieIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }

  export type $BulletinPaiePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BulletinPaie"
    objects: {
      employe: Prisma.$EmployePayload<ExtArgs>
      lignes: Prisma.$LigneBulletinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeId: string
      periode: string
      dateEmission: Date
      salaireBase: Prisma.Decimal
      totalPrimes: Prisma.Decimal
      totalRetenues: Prisma.Decimal
      salaireNet: Prisma.Decimal
      statut: string
    }, ExtArgs["result"]["bulletinPaie"]>
    composites: {}
  }

  type BulletinPaieGetPayload<S extends boolean | null | undefined | BulletinPaieDefaultArgs> = $Result.GetResult<Prisma.$BulletinPaiePayload, S>

  type BulletinPaieCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BulletinPaieFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BulletinPaieCountAggregateInputType | true
    }

  export interface BulletinPaieDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BulletinPaie'], meta: { name: 'BulletinPaie' } }
    /**
     * Find zero or one BulletinPaie that matches the filter.
     * @param {BulletinPaieFindUniqueArgs} args - Arguments to find a BulletinPaie
     * @example
     * // Get one BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BulletinPaieFindUniqueArgs>(args: SelectSubset<T, BulletinPaieFindUniqueArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BulletinPaie that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BulletinPaieFindUniqueOrThrowArgs} args - Arguments to find a BulletinPaie
     * @example
     * // Get one BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BulletinPaieFindUniqueOrThrowArgs>(args: SelectSubset<T, BulletinPaieFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BulletinPaie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieFindFirstArgs} args - Arguments to find a BulletinPaie
     * @example
     * // Get one BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BulletinPaieFindFirstArgs>(args?: SelectSubset<T, BulletinPaieFindFirstArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BulletinPaie that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieFindFirstOrThrowArgs} args - Arguments to find a BulletinPaie
     * @example
     * // Get one BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BulletinPaieFindFirstOrThrowArgs>(args?: SelectSubset<T, BulletinPaieFindFirstOrThrowArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BulletinPaies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BulletinPaies
     * const bulletinPaies = await prisma.bulletinPaie.findMany()
     * 
     * // Get first 10 BulletinPaies
     * const bulletinPaies = await prisma.bulletinPaie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bulletinPaieWithIdOnly = await prisma.bulletinPaie.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BulletinPaieFindManyArgs>(args?: SelectSubset<T, BulletinPaieFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BulletinPaie.
     * @param {BulletinPaieCreateArgs} args - Arguments to create a BulletinPaie.
     * @example
     * // Create one BulletinPaie
     * const BulletinPaie = await prisma.bulletinPaie.create({
     *   data: {
     *     // ... data to create a BulletinPaie
     *   }
     * })
     * 
     */
    create<T extends BulletinPaieCreateArgs>(args: SelectSubset<T, BulletinPaieCreateArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BulletinPaies.
     * @param {BulletinPaieCreateManyArgs} args - Arguments to create many BulletinPaies.
     * @example
     * // Create many BulletinPaies
     * const bulletinPaie = await prisma.bulletinPaie.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BulletinPaieCreateManyArgs>(args?: SelectSubset<T, BulletinPaieCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BulletinPaies and returns the data saved in the database.
     * @param {BulletinPaieCreateManyAndReturnArgs} args - Arguments to create many BulletinPaies.
     * @example
     * // Create many BulletinPaies
     * const bulletinPaie = await prisma.bulletinPaie.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BulletinPaies and only return the `id`
     * const bulletinPaieWithIdOnly = await prisma.bulletinPaie.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BulletinPaieCreateManyAndReturnArgs>(args?: SelectSubset<T, BulletinPaieCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a BulletinPaie.
     * @param {BulletinPaieDeleteArgs} args - Arguments to delete one BulletinPaie.
     * @example
     * // Delete one BulletinPaie
     * const BulletinPaie = await prisma.bulletinPaie.delete({
     *   where: {
     *     // ... filter to delete one BulletinPaie
     *   }
     * })
     * 
     */
    delete<T extends BulletinPaieDeleteArgs>(args: SelectSubset<T, BulletinPaieDeleteArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BulletinPaie.
     * @param {BulletinPaieUpdateArgs} args - Arguments to update one BulletinPaie.
     * @example
     * // Update one BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BulletinPaieUpdateArgs>(args: SelectSubset<T, BulletinPaieUpdateArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BulletinPaies.
     * @param {BulletinPaieDeleteManyArgs} args - Arguments to filter BulletinPaies to delete.
     * @example
     * // Delete a few BulletinPaies
     * const { count } = await prisma.bulletinPaie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BulletinPaieDeleteManyArgs>(args?: SelectSubset<T, BulletinPaieDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulletinPaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BulletinPaies
     * const bulletinPaie = await prisma.bulletinPaie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BulletinPaieUpdateManyArgs>(args: SelectSubset<T, BulletinPaieUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BulletinPaies and returns the data updated in the database.
     * @param {BulletinPaieUpdateManyAndReturnArgs} args - Arguments to update many BulletinPaies.
     * @example
     * // Update many BulletinPaies
     * const bulletinPaie = await prisma.bulletinPaie.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BulletinPaies and only return the `id`
     * const bulletinPaieWithIdOnly = await prisma.bulletinPaie.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BulletinPaieUpdateManyAndReturnArgs>(args: SelectSubset<T, BulletinPaieUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one BulletinPaie.
     * @param {BulletinPaieUpsertArgs} args - Arguments to update or create a BulletinPaie.
     * @example
     * // Update or create a BulletinPaie
     * const bulletinPaie = await prisma.bulletinPaie.upsert({
     *   create: {
     *     // ... data to create a BulletinPaie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BulletinPaie we want to update
     *   }
     * })
     */
    upsert<T extends BulletinPaieUpsertArgs>(args: SelectSubset<T, BulletinPaieUpsertArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BulletinPaies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieCountArgs} args - Arguments to filter BulletinPaies to count.
     * @example
     * // Count the number of BulletinPaies
     * const count = await prisma.bulletinPaie.count({
     *   where: {
     *     // ... the filter for the BulletinPaies we want to count
     *   }
     * })
    **/
    count<T extends BulletinPaieCountArgs>(
      args?: Subset<T, BulletinPaieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BulletinPaieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BulletinPaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BulletinPaieAggregateArgs>(args: Subset<T, BulletinPaieAggregateArgs>): Prisma.PrismaPromise<GetBulletinPaieAggregateType<T>>

    /**
     * Group by BulletinPaie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BulletinPaieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BulletinPaieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BulletinPaieGroupByArgs['orderBy'] }
        : { orderBy?: BulletinPaieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BulletinPaieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBulletinPaieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BulletinPaie model
   */
  readonly fields: BulletinPaieFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BulletinPaie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BulletinPaieClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employe<T extends EmployeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeDefaultArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    lignes<T extends BulletinPaie$lignesArgs<ExtArgs> = {}>(args?: Subset<T, BulletinPaie$lignesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BulletinPaie model
   */ 
  interface BulletinPaieFieldRefs {
    readonly id: FieldRef<"BulletinPaie", 'String'>
    readonly employeId: FieldRef<"BulletinPaie", 'String'>
    readonly periode: FieldRef<"BulletinPaie", 'String'>
    readonly dateEmission: FieldRef<"BulletinPaie", 'DateTime'>
    readonly salaireBase: FieldRef<"BulletinPaie", 'Decimal'>
    readonly totalPrimes: FieldRef<"BulletinPaie", 'Decimal'>
    readonly totalRetenues: FieldRef<"BulletinPaie", 'Decimal'>
    readonly salaireNet: FieldRef<"BulletinPaie", 'Decimal'>
    readonly statut: FieldRef<"BulletinPaie", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BulletinPaie findUnique
   */
  export type BulletinPaieFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter, which BulletinPaie to fetch.
     */
    where: BulletinPaieWhereUniqueInput
  }

  /**
   * BulletinPaie findUniqueOrThrow
   */
  export type BulletinPaieFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter, which BulletinPaie to fetch.
     */
    where: BulletinPaieWhereUniqueInput
  }

  /**
   * BulletinPaie findFirst
   */
  export type BulletinPaieFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter, which BulletinPaie to fetch.
     */
    where?: BulletinPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulletinPaies to fetch.
     */
    orderBy?: BulletinPaieOrderByWithRelationInput | BulletinPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulletinPaies.
     */
    cursor?: BulletinPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulletinPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulletinPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulletinPaies.
     */
    distinct?: BulletinPaieScalarFieldEnum | BulletinPaieScalarFieldEnum[]
  }

  /**
   * BulletinPaie findFirstOrThrow
   */
  export type BulletinPaieFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter, which BulletinPaie to fetch.
     */
    where?: BulletinPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulletinPaies to fetch.
     */
    orderBy?: BulletinPaieOrderByWithRelationInput | BulletinPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BulletinPaies.
     */
    cursor?: BulletinPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulletinPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulletinPaies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BulletinPaies.
     */
    distinct?: BulletinPaieScalarFieldEnum | BulletinPaieScalarFieldEnum[]
  }

  /**
   * BulletinPaie findMany
   */
  export type BulletinPaieFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter, which BulletinPaies to fetch.
     */
    where?: BulletinPaieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BulletinPaies to fetch.
     */
    orderBy?: BulletinPaieOrderByWithRelationInput | BulletinPaieOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BulletinPaies.
     */
    cursor?: BulletinPaieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BulletinPaies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BulletinPaies.
     */
    skip?: number
    distinct?: BulletinPaieScalarFieldEnum | BulletinPaieScalarFieldEnum[]
  }

  /**
   * BulletinPaie create
   */
  export type BulletinPaieCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * The data needed to create a BulletinPaie.
     */
    data: XOR<BulletinPaieCreateInput, BulletinPaieUncheckedCreateInput>
  }

  /**
   * BulletinPaie createMany
   */
  export type BulletinPaieCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BulletinPaies.
     */
    data: BulletinPaieCreateManyInput | BulletinPaieCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BulletinPaie createManyAndReturn
   */
  export type BulletinPaieCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * The data used to create many BulletinPaies.
     */
    data: BulletinPaieCreateManyInput | BulletinPaieCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulletinPaie update
   */
  export type BulletinPaieUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * The data needed to update a BulletinPaie.
     */
    data: XOR<BulletinPaieUpdateInput, BulletinPaieUncheckedUpdateInput>
    /**
     * Choose, which BulletinPaie to update.
     */
    where: BulletinPaieWhereUniqueInput
  }

  /**
   * BulletinPaie updateMany
   */
  export type BulletinPaieUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BulletinPaies.
     */
    data: XOR<BulletinPaieUpdateManyMutationInput, BulletinPaieUncheckedUpdateManyInput>
    /**
     * Filter which BulletinPaies to update
     */
    where?: BulletinPaieWhereInput
  }

  /**
   * BulletinPaie updateManyAndReturn
   */
  export type BulletinPaieUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * The data used to update BulletinPaies.
     */
    data: XOR<BulletinPaieUpdateManyMutationInput, BulletinPaieUncheckedUpdateManyInput>
    /**
     * Filter which BulletinPaies to update
     */
    where?: BulletinPaieWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BulletinPaie upsert
   */
  export type BulletinPaieUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * The filter to search for the BulletinPaie to update in case it exists.
     */
    where: BulletinPaieWhereUniqueInput
    /**
     * In case the BulletinPaie found by the `where` argument doesn't exist, create a new BulletinPaie with this data.
     */
    create: XOR<BulletinPaieCreateInput, BulletinPaieUncheckedCreateInput>
    /**
     * In case the BulletinPaie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BulletinPaieUpdateInput, BulletinPaieUncheckedUpdateInput>
  }

  /**
   * BulletinPaie delete
   */
  export type BulletinPaieDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
    /**
     * Filter which BulletinPaie to delete.
     */
    where: BulletinPaieWhereUniqueInput
  }

  /**
   * BulletinPaie deleteMany
   */
  export type BulletinPaieDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BulletinPaies to delete
     */
    where?: BulletinPaieWhereInput
  }

  /**
   * BulletinPaie.lignes
   */
  export type BulletinPaie$lignesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    where?: LigneBulletinWhereInput
    orderBy?: LigneBulletinOrderByWithRelationInput | LigneBulletinOrderByWithRelationInput[]
    cursor?: LigneBulletinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LigneBulletinScalarFieldEnum | LigneBulletinScalarFieldEnum[]
  }

  /**
   * BulletinPaie without action
   */
  export type BulletinPaieDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BulletinPaie
     */
    select?: BulletinPaieSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BulletinPaie
     */
    omit?: BulletinPaieOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BulletinPaieInclude<ExtArgs> | null
  }


  /**
   * Model LigneBulletin
   */

  export type AggregateLigneBulletin = {
    _count: LigneBulletinCountAggregateOutputType | null
    _avg: LigneBulletinAvgAggregateOutputType | null
    _sum: LigneBulletinSumAggregateOutputType | null
    _min: LigneBulletinMinAggregateOutputType | null
    _max: LigneBulletinMaxAggregateOutputType | null
  }

  export type LigneBulletinAvgAggregateOutputType = {
    base: Decimal | null
    taux: Decimal | null
    montant: Decimal | null
  }

  export type LigneBulletinSumAggregateOutputType = {
    base: Decimal | null
    taux: Decimal | null
    montant: Decimal | null
  }

  export type LigneBulletinMinAggregateOutputType = {
    id: string | null
    bulletinId: string | null
    libelle: string | null
    type: string | null
    base: Decimal | null
    taux: Decimal | null
    montant: Decimal | null
  }

  export type LigneBulletinMaxAggregateOutputType = {
    id: string | null
    bulletinId: string | null
    libelle: string | null
    type: string | null
    base: Decimal | null
    taux: Decimal | null
    montant: Decimal | null
  }

  export type LigneBulletinCountAggregateOutputType = {
    id: number
    bulletinId: number
    libelle: number
    type: number
    base: number
    taux: number
    montant: number
    _all: number
  }


  export type LigneBulletinAvgAggregateInputType = {
    base?: true
    taux?: true
    montant?: true
  }

  export type LigneBulletinSumAggregateInputType = {
    base?: true
    taux?: true
    montant?: true
  }

  export type LigneBulletinMinAggregateInputType = {
    id?: true
    bulletinId?: true
    libelle?: true
    type?: true
    base?: true
    taux?: true
    montant?: true
  }

  export type LigneBulletinMaxAggregateInputType = {
    id?: true
    bulletinId?: true
    libelle?: true
    type?: true
    base?: true
    taux?: true
    montant?: true
  }

  export type LigneBulletinCountAggregateInputType = {
    id?: true
    bulletinId?: true
    libelle?: true
    type?: true
    base?: true
    taux?: true
    montant?: true
    _all?: true
  }

  export type LigneBulletinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneBulletin to aggregate.
     */
    where?: LigneBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneBulletins to fetch.
     */
    orderBy?: LigneBulletinOrderByWithRelationInput | LigneBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LigneBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LigneBulletins
    **/
    _count?: true | LigneBulletinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LigneBulletinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LigneBulletinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LigneBulletinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LigneBulletinMaxAggregateInputType
  }

  export type GetLigneBulletinAggregateType<T extends LigneBulletinAggregateArgs> = {
        [P in keyof T & keyof AggregateLigneBulletin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLigneBulletin[P]>
      : GetScalarType<T[P], AggregateLigneBulletin[P]>
  }




  export type LigneBulletinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LigneBulletinWhereInput
    orderBy?: LigneBulletinOrderByWithAggregationInput | LigneBulletinOrderByWithAggregationInput[]
    by: LigneBulletinScalarFieldEnum[] | LigneBulletinScalarFieldEnum
    having?: LigneBulletinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LigneBulletinCountAggregateInputType | true
    _avg?: LigneBulletinAvgAggregateInputType
    _sum?: LigneBulletinSumAggregateInputType
    _min?: LigneBulletinMinAggregateInputType
    _max?: LigneBulletinMaxAggregateInputType
  }

  export type LigneBulletinGroupByOutputType = {
    id: string
    bulletinId: string
    libelle: string
    type: string
    base: Decimal | null
    taux: Decimal | null
    montant: Decimal
    _count: LigneBulletinCountAggregateOutputType | null
    _avg: LigneBulletinAvgAggregateOutputType | null
    _sum: LigneBulletinSumAggregateOutputType | null
    _min: LigneBulletinMinAggregateOutputType | null
    _max: LigneBulletinMaxAggregateOutputType | null
  }

  type GetLigneBulletinGroupByPayload<T extends LigneBulletinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LigneBulletinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LigneBulletinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LigneBulletinGroupByOutputType[P]>
            : GetScalarType<T[P], LigneBulletinGroupByOutputType[P]>
        }
      >
    >


  export type LigneBulletinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulletinId?: boolean
    libelle?: boolean
    type?: boolean
    base?: boolean
    taux?: boolean
    montant?: boolean
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneBulletin"]>

  export type LigneBulletinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulletinId?: boolean
    libelle?: boolean
    type?: boolean
    base?: boolean
    taux?: boolean
    montant?: boolean
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneBulletin"]>

  export type LigneBulletinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bulletinId?: boolean
    libelle?: boolean
    type?: boolean
    base?: boolean
    taux?: boolean
    montant?: boolean
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ligneBulletin"]>

  export type LigneBulletinSelectScalar = {
    id?: boolean
    bulletinId?: boolean
    libelle?: boolean
    type?: boolean
    base?: boolean
    taux?: boolean
    montant?: boolean
  }

  export type LigneBulletinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bulletinId" | "libelle" | "type" | "base" | "taux" | "montant", ExtArgs["result"]["ligneBulletin"]>
  export type LigneBulletinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }
  export type LigneBulletinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }
  export type LigneBulletinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bulletin?: boolean | BulletinPaieDefaultArgs<ExtArgs>
  }

  export type $LigneBulletinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LigneBulletin"
    objects: {
      bulletin: Prisma.$BulletinPaiePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bulletinId: string
      libelle: string
      type: string
      base: Prisma.Decimal | null
      taux: Prisma.Decimal | null
      montant: Prisma.Decimal
    }, ExtArgs["result"]["ligneBulletin"]>
    composites: {}
  }

  type LigneBulletinGetPayload<S extends boolean | null | undefined | LigneBulletinDefaultArgs> = $Result.GetResult<Prisma.$LigneBulletinPayload, S>

  type LigneBulletinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LigneBulletinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LigneBulletinCountAggregateInputType | true
    }

  export interface LigneBulletinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LigneBulletin'], meta: { name: 'LigneBulletin' } }
    /**
     * Find zero or one LigneBulletin that matches the filter.
     * @param {LigneBulletinFindUniqueArgs} args - Arguments to find a LigneBulletin
     * @example
     * // Get one LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LigneBulletinFindUniqueArgs>(args: SelectSubset<T, LigneBulletinFindUniqueArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one LigneBulletin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LigneBulletinFindUniqueOrThrowArgs} args - Arguments to find a LigneBulletin
     * @example
     * // Get one LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LigneBulletinFindUniqueOrThrowArgs>(args: SelectSubset<T, LigneBulletinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first LigneBulletin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinFindFirstArgs} args - Arguments to find a LigneBulletin
     * @example
     * // Get one LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LigneBulletinFindFirstArgs>(args?: SelectSubset<T, LigneBulletinFindFirstArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first LigneBulletin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinFindFirstOrThrowArgs} args - Arguments to find a LigneBulletin
     * @example
     * // Get one LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LigneBulletinFindFirstOrThrowArgs>(args?: SelectSubset<T, LigneBulletinFindFirstOrThrowArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more LigneBulletins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LigneBulletins
     * const ligneBulletins = await prisma.ligneBulletin.findMany()
     * 
     * // Get first 10 LigneBulletins
     * const ligneBulletins = await prisma.ligneBulletin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ligneBulletinWithIdOnly = await prisma.ligneBulletin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LigneBulletinFindManyArgs>(args?: SelectSubset<T, LigneBulletinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a LigneBulletin.
     * @param {LigneBulletinCreateArgs} args - Arguments to create a LigneBulletin.
     * @example
     * // Create one LigneBulletin
     * const LigneBulletin = await prisma.ligneBulletin.create({
     *   data: {
     *     // ... data to create a LigneBulletin
     *   }
     * })
     * 
     */
    create<T extends LigneBulletinCreateArgs>(args: SelectSubset<T, LigneBulletinCreateArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many LigneBulletins.
     * @param {LigneBulletinCreateManyArgs} args - Arguments to create many LigneBulletins.
     * @example
     * // Create many LigneBulletins
     * const ligneBulletin = await prisma.ligneBulletin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LigneBulletinCreateManyArgs>(args?: SelectSubset<T, LigneBulletinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LigneBulletins and returns the data saved in the database.
     * @param {LigneBulletinCreateManyAndReturnArgs} args - Arguments to create many LigneBulletins.
     * @example
     * // Create many LigneBulletins
     * const ligneBulletin = await prisma.ligneBulletin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LigneBulletins and only return the `id`
     * const ligneBulletinWithIdOnly = await prisma.ligneBulletin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LigneBulletinCreateManyAndReturnArgs>(args?: SelectSubset<T, LigneBulletinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a LigneBulletin.
     * @param {LigneBulletinDeleteArgs} args - Arguments to delete one LigneBulletin.
     * @example
     * // Delete one LigneBulletin
     * const LigneBulletin = await prisma.ligneBulletin.delete({
     *   where: {
     *     // ... filter to delete one LigneBulletin
     *   }
     * })
     * 
     */
    delete<T extends LigneBulletinDeleteArgs>(args: SelectSubset<T, LigneBulletinDeleteArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one LigneBulletin.
     * @param {LigneBulletinUpdateArgs} args - Arguments to update one LigneBulletin.
     * @example
     * // Update one LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LigneBulletinUpdateArgs>(args: SelectSubset<T, LigneBulletinUpdateArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more LigneBulletins.
     * @param {LigneBulletinDeleteManyArgs} args - Arguments to filter LigneBulletins to delete.
     * @example
     * // Delete a few LigneBulletins
     * const { count } = await prisma.ligneBulletin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LigneBulletinDeleteManyArgs>(args?: SelectSubset<T, LigneBulletinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneBulletins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LigneBulletins
     * const ligneBulletin = await prisma.ligneBulletin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LigneBulletinUpdateManyArgs>(args: SelectSubset<T, LigneBulletinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LigneBulletins and returns the data updated in the database.
     * @param {LigneBulletinUpdateManyAndReturnArgs} args - Arguments to update many LigneBulletins.
     * @example
     * // Update many LigneBulletins
     * const ligneBulletin = await prisma.ligneBulletin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LigneBulletins and only return the `id`
     * const ligneBulletinWithIdOnly = await prisma.ligneBulletin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LigneBulletinUpdateManyAndReturnArgs>(args: SelectSubset<T, LigneBulletinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one LigneBulletin.
     * @param {LigneBulletinUpsertArgs} args - Arguments to update or create a LigneBulletin.
     * @example
     * // Update or create a LigneBulletin
     * const ligneBulletin = await prisma.ligneBulletin.upsert({
     *   create: {
     *     // ... data to create a LigneBulletin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LigneBulletin we want to update
     *   }
     * })
     */
    upsert<T extends LigneBulletinUpsertArgs>(args: SelectSubset<T, LigneBulletinUpsertArgs<ExtArgs>>): Prisma__LigneBulletinClient<$Result.GetResult<Prisma.$LigneBulletinPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of LigneBulletins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinCountArgs} args - Arguments to filter LigneBulletins to count.
     * @example
     * // Count the number of LigneBulletins
     * const count = await prisma.ligneBulletin.count({
     *   where: {
     *     // ... the filter for the LigneBulletins we want to count
     *   }
     * })
    **/
    count<T extends LigneBulletinCountArgs>(
      args?: Subset<T, LigneBulletinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LigneBulletinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LigneBulletin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LigneBulletinAggregateArgs>(args: Subset<T, LigneBulletinAggregateArgs>): Prisma.PrismaPromise<GetLigneBulletinAggregateType<T>>

    /**
     * Group by LigneBulletin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LigneBulletinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LigneBulletinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LigneBulletinGroupByArgs['orderBy'] }
        : { orderBy?: LigneBulletinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LigneBulletinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLigneBulletinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LigneBulletin model
   */
  readonly fields: LigneBulletinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LigneBulletin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LigneBulletinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bulletin<T extends BulletinPaieDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BulletinPaieDefaultArgs<ExtArgs>>): Prisma__BulletinPaieClient<$Result.GetResult<Prisma.$BulletinPaiePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LigneBulletin model
   */ 
  interface LigneBulletinFieldRefs {
    readonly id: FieldRef<"LigneBulletin", 'String'>
    readonly bulletinId: FieldRef<"LigneBulletin", 'String'>
    readonly libelle: FieldRef<"LigneBulletin", 'String'>
    readonly type: FieldRef<"LigneBulletin", 'String'>
    readonly base: FieldRef<"LigneBulletin", 'Decimal'>
    readonly taux: FieldRef<"LigneBulletin", 'Decimal'>
    readonly montant: FieldRef<"LigneBulletin", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * LigneBulletin findUnique
   */
  export type LigneBulletinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter, which LigneBulletin to fetch.
     */
    where: LigneBulletinWhereUniqueInput
  }

  /**
   * LigneBulletin findUniqueOrThrow
   */
  export type LigneBulletinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter, which LigneBulletin to fetch.
     */
    where: LigneBulletinWhereUniqueInput
  }

  /**
   * LigneBulletin findFirst
   */
  export type LigneBulletinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter, which LigneBulletin to fetch.
     */
    where?: LigneBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneBulletins to fetch.
     */
    orderBy?: LigneBulletinOrderByWithRelationInput | LigneBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneBulletins.
     */
    cursor?: LigneBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneBulletins.
     */
    distinct?: LigneBulletinScalarFieldEnum | LigneBulletinScalarFieldEnum[]
  }

  /**
   * LigneBulletin findFirstOrThrow
   */
  export type LigneBulletinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter, which LigneBulletin to fetch.
     */
    where?: LigneBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneBulletins to fetch.
     */
    orderBy?: LigneBulletinOrderByWithRelationInput | LigneBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LigneBulletins.
     */
    cursor?: LigneBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneBulletins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LigneBulletins.
     */
    distinct?: LigneBulletinScalarFieldEnum | LigneBulletinScalarFieldEnum[]
  }

  /**
   * LigneBulletin findMany
   */
  export type LigneBulletinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter, which LigneBulletins to fetch.
     */
    where?: LigneBulletinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LigneBulletins to fetch.
     */
    orderBy?: LigneBulletinOrderByWithRelationInput | LigneBulletinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LigneBulletins.
     */
    cursor?: LigneBulletinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LigneBulletins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LigneBulletins.
     */
    skip?: number
    distinct?: LigneBulletinScalarFieldEnum | LigneBulletinScalarFieldEnum[]
  }

  /**
   * LigneBulletin create
   */
  export type LigneBulletinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * The data needed to create a LigneBulletin.
     */
    data: XOR<LigneBulletinCreateInput, LigneBulletinUncheckedCreateInput>
  }

  /**
   * LigneBulletin createMany
   */
  export type LigneBulletinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LigneBulletins.
     */
    data: LigneBulletinCreateManyInput | LigneBulletinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LigneBulletin createManyAndReturn
   */
  export type LigneBulletinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * The data used to create many LigneBulletins.
     */
    data: LigneBulletinCreateManyInput | LigneBulletinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneBulletin update
   */
  export type LigneBulletinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * The data needed to update a LigneBulletin.
     */
    data: XOR<LigneBulletinUpdateInput, LigneBulletinUncheckedUpdateInput>
    /**
     * Choose, which LigneBulletin to update.
     */
    where: LigneBulletinWhereUniqueInput
  }

  /**
   * LigneBulletin updateMany
   */
  export type LigneBulletinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LigneBulletins.
     */
    data: XOR<LigneBulletinUpdateManyMutationInput, LigneBulletinUncheckedUpdateManyInput>
    /**
     * Filter which LigneBulletins to update
     */
    where?: LigneBulletinWhereInput
  }

  /**
   * LigneBulletin updateManyAndReturn
   */
  export type LigneBulletinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * The data used to update LigneBulletins.
     */
    data: XOR<LigneBulletinUpdateManyMutationInput, LigneBulletinUncheckedUpdateManyInput>
    /**
     * Filter which LigneBulletins to update
     */
    where?: LigneBulletinWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LigneBulletin upsert
   */
  export type LigneBulletinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * The filter to search for the LigneBulletin to update in case it exists.
     */
    where: LigneBulletinWhereUniqueInput
    /**
     * In case the LigneBulletin found by the `where` argument doesn't exist, create a new LigneBulletin with this data.
     */
    create: XOR<LigneBulletinCreateInput, LigneBulletinUncheckedCreateInput>
    /**
     * In case the LigneBulletin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LigneBulletinUpdateInput, LigneBulletinUncheckedUpdateInput>
  }

  /**
   * LigneBulletin delete
   */
  export type LigneBulletinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
    /**
     * Filter which LigneBulletin to delete.
     */
    where: LigneBulletinWhereUniqueInput
  }

  /**
   * LigneBulletin deleteMany
   */
  export type LigneBulletinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LigneBulletins to delete
     */
    where?: LigneBulletinWhereInput
  }

  /**
   * LigneBulletin without action
   */
  export type LigneBulletinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LigneBulletin
     */
    select?: LigneBulletinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LigneBulletin
     */
    omit?: LigneBulletinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LigneBulletinInclude<ExtArgs> | null
  }


  /**
   * Model Planning
   */

  export type AggregatePlanning = {
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  export type PlanningMinAggregateOutputType = {
    id: string | null
    employeId: string | null
    date: Date | null
    heureDebut: string | null
    heureFin: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PlanningMaxAggregateOutputType = {
    id: string | null
    employeId: string | null
    date: Date | null
    heureDebut: string | null
    heureFin: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PlanningCountAggregateOutputType = {
    id: number
    employeId: number
    date: number
    heureDebut: number
    heureFin: number
    type: number
    createdAt: number
    _all: number
  }


  export type PlanningMinAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    createdAt?: true
  }

  export type PlanningMaxAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    createdAt?: true
  }

  export type PlanningCountAggregateInputType = {
    id?: true
    employeId?: true
    date?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PlanningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planning to aggregate.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plannings
    **/
    _count?: true | PlanningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanningMaxAggregateInputType
  }

  export type GetPlanningAggregateType<T extends PlanningAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanning[P]>
      : GetScalarType<T[P], AggregatePlanning[P]>
  }




  export type PlanningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanningWhereInput
    orderBy?: PlanningOrderByWithAggregationInput | PlanningOrderByWithAggregationInput[]
    by: PlanningScalarFieldEnum[] | PlanningScalarFieldEnum
    having?: PlanningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanningCountAggregateInputType | true
    _min?: PlanningMinAggregateInputType
    _max?: PlanningMaxAggregateInputType
  }

  export type PlanningGroupByOutputType = {
    id: string
    employeId: string
    date: Date
    heureDebut: string
    heureFin: string
    type: string
    createdAt: Date
    _count: PlanningCountAggregateOutputType | null
    _min: PlanningMinAggregateOutputType | null
    _max: PlanningMaxAggregateOutputType | null
  }

  type GetPlanningGroupByPayload<T extends PlanningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanningGroupByOutputType[P]>
            : GetScalarType<T[P], PlanningGroupByOutputType[P]>
        }
      >
    >


  export type PlanningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    createdAt?: boolean
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planning"]>

  export type PlanningSelectScalar = {
    id?: boolean
    employeId?: boolean
    date?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PlanningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeId" | "date" | "heureDebut" | "heureFin" | "type" | "createdAt", ExtArgs["result"]["planning"]>
  export type PlanningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }
  export type PlanningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }
  export type PlanningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employe?: boolean | EmployeDefaultArgs<ExtArgs>
  }

  export type $PlanningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planning"
    objects: {
      employe: Prisma.$EmployePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeId: string
      date: Date
      heureDebut: string
      heureFin: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["planning"]>
    composites: {}
  }

  type PlanningGetPayload<S extends boolean | null | undefined | PlanningDefaultArgs> = $Result.GetResult<Prisma.$PlanningPayload, S>

  type PlanningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanningCountAggregateInputType | true
    }

  export interface PlanningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planning'], meta: { name: 'Planning' } }
    /**
     * Find zero or one Planning that matches the filter.
     * @param {PlanningFindUniqueArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanningFindUniqueArgs>(args: SelectSubset<T, PlanningFindUniqueArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Planning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanningFindUniqueOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanningFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Planning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanningFindFirstArgs>(args?: SelectSubset<T, PlanningFindFirstArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Planning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindFirstOrThrowArgs} args - Arguments to find a Planning
     * @example
     * // Get one Planning
     * const planning = await prisma.planning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanningFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanningFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Plannings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plannings
     * const plannings = await prisma.planning.findMany()
     * 
     * // Get first 10 Plannings
     * const plannings = await prisma.planning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planningWithIdOnly = await prisma.planning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanningFindManyArgs>(args?: SelectSubset<T, PlanningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Planning.
     * @param {PlanningCreateArgs} args - Arguments to create a Planning.
     * @example
     * // Create one Planning
     * const Planning = await prisma.planning.create({
     *   data: {
     *     // ... data to create a Planning
     *   }
     * })
     * 
     */
    create<T extends PlanningCreateArgs>(args: SelectSubset<T, PlanningCreateArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Plannings.
     * @param {PlanningCreateManyArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanningCreateManyArgs>(args?: SelectSubset<T, PlanningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plannings and returns the data saved in the database.
     * @param {PlanningCreateManyAndReturnArgs} args - Arguments to create many Plannings.
     * @example
     * // Create many Plannings
     * const planning = await prisma.planning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plannings and only return the `id`
     * const planningWithIdOnly = await prisma.planning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanningCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Planning.
     * @param {PlanningDeleteArgs} args - Arguments to delete one Planning.
     * @example
     * // Delete one Planning
     * const Planning = await prisma.planning.delete({
     *   where: {
     *     // ... filter to delete one Planning
     *   }
     * })
     * 
     */
    delete<T extends PlanningDeleteArgs>(args: SelectSubset<T, PlanningDeleteArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Planning.
     * @param {PlanningUpdateArgs} args - Arguments to update one Planning.
     * @example
     * // Update one Planning
     * const planning = await prisma.planning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanningUpdateArgs>(args: SelectSubset<T, PlanningUpdateArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Plannings.
     * @param {PlanningDeleteManyArgs} args - Arguments to filter Plannings to delete.
     * @example
     * // Delete a few Plannings
     * const { count } = await prisma.planning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanningDeleteManyArgs>(args?: SelectSubset<T, PlanningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plannings
     * const planning = await prisma.planning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanningUpdateManyArgs>(args: SelectSubset<T, PlanningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plannings and returns the data updated in the database.
     * @param {PlanningUpdateManyAndReturnArgs} args - Arguments to update many Plannings.
     * @example
     * // Update many Plannings
     * const planning = await prisma.planning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plannings and only return the `id`
     * const planningWithIdOnly = await prisma.planning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanningUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Planning.
     * @param {PlanningUpsertArgs} args - Arguments to update or create a Planning.
     * @example
     * // Update or create a Planning
     * const planning = await prisma.planning.upsert({
     *   create: {
     *     // ... data to create a Planning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planning we want to update
     *   }
     * })
     */
    upsert<T extends PlanningUpsertArgs>(args: SelectSubset<T, PlanningUpsertArgs<ExtArgs>>): Prisma__PlanningClient<$Result.GetResult<Prisma.$PlanningPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Plannings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningCountArgs} args - Arguments to filter Plannings to count.
     * @example
     * // Count the number of Plannings
     * const count = await prisma.planning.count({
     *   where: {
     *     // ... the filter for the Plannings we want to count
     *   }
     * })
    **/
    count<T extends PlanningCountArgs>(
      args?: Subset<T, PlanningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanningAggregateArgs>(args: Subset<T, PlanningAggregateArgs>): Prisma.PrismaPromise<GetPlanningAggregateType<T>>

    /**
     * Group by Planning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanningGroupByArgs['orderBy'] }
        : { orderBy?: PlanningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planning model
   */
  readonly fields: PlanningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employe<T extends EmployeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeDefaultArgs<ExtArgs>>): Prisma__EmployeClient<$Result.GetResult<Prisma.$EmployePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Planning model
   */ 
  interface PlanningFieldRefs {
    readonly id: FieldRef<"Planning", 'String'>
    readonly employeId: FieldRef<"Planning", 'String'>
    readonly date: FieldRef<"Planning", 'DateTime'>
    readonly heureDebut: FieldRef<"Planning", 'String'>
    readonly heureFin: FieldRef<"Planning", 'String'>
    readonly type: FieldRef<"Planning", 'String'>
    readonly createdAt: FieldRef<"Planning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Planning findUnique
   */
  export type PlanningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findUniqueOrThrow
   */
  export type PlanningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning findFirst
   */
  export type PlanningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findFirstOrThrow
   */
  export type PlanningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Planning to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plannings.
     */
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning findMany
   */
  export type PlanningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter, which Plannings to fetch.
     */
    where?: PlanningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plannings to fetch.
     */
    orderBy?: PlanningOrderByWithRelationInput | PlanningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plannings.
     */
    cursor?: PlanningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plannings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plannings.
     */
    skip?: number
    distinct?: PlanningScalarFieldEnum | PlanningScalarFieldEnum[]
  }

  /**
   * Planning create
   */
  export type PlanningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to create a Planning.
     */
    data: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
  }

  /**
   * Planning createMany
   */
  export type PlanningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Planning createManyAndReturn
   */
  export type PlanningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * The data used to create many Plannings.
     */
    data: PlanningCreateManyInput | PlanningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planning update
   */
  export type PlanningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The data needed to update a Planning.
     */
    data: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
    /**
     * Choose, which Planning to update.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning updateMany
   */
  export type PlanningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plannings.
     */
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyInput>
    /**
     * Filter which Plannings to update
     */
    where?: PlanningWhereInput
  }

  /**
   * Planning updateManyAndReturn
   */
  export type PlanningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * The data used to update Plannings.
     */
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyInput>
    /**
     * Filter which Plannings to update
     */
    where?: PlanningWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Planning upsert
   */
  export type PlanningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * The filter to search for the Planning to update in case it exists.
     */
    where: PlanningWhereUniqueInput
    /**
     * In case the Planning found by the `where` argument doesn't exist, create a new Planning with this data.
     */
    create: XOR<PlanningCreateInput, PlanningUncheckedCreateInput>
    /**
     * In case the Planning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanningUpdateInput, PlanningUncheckedUpdateInput>
  }

  /**
   * Planning delete
   */
  export type PlanningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
    /**
     * Filter which Planning to delete.
     */
    where: PlanningWhereUniqueInput
  }

  /**
   * Planning deleteMany
   */
  export type PlanningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plannings to delete
     */
    where?: PlanningWhereInput
  }

  /**
   * Planning without action
   */
  export type PlanningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planning
     */
    select?: PlanningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planning
     */
    omit?: PlanningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanningInclude<ExtArgs> | null
  }


  /**
   * Model Equipement
   */

  export type AggregateEquipement = {
    _count: EquipementCountAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  export type EquipementMinAggregateOutputType = {
    id: string | null
    code: string | null
    nom: string | null
    type: string | null
    marque: string | null
    modele: string | null
    serie: string | null
    dateAchat: Date | null
    dateDerniereMaintenace: Date | null
    dateProchaineMaintenance: Date | null
    statut: string | null
    localisation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipementMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nom: string | null
    type: string | null
    marque: string | null
    modele: string | null
    serie: string | null
    dateAchat: Date | null
    dateDerniereMaintenace: Date | null
    dateProchaineMaintenance: Date | null
    statut: string | null
    localisation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipementCountAggregateOutputType = {
    id: number
    code: number
    nom: number
    type: number
    marque: number
    modele: number
    serie: number
    dateAchat: number
    dateDerniereMaintenace: number
    dateProchaineMaintenance: number
    statut: number
    localisation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipementMinAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    marque?: true
    modele?: true
    serie?: true
    dateAchat?: true
    dateDerniereMaintenace?: true
    dateProchaineMaintenance?: true
    statut?: true
    localisation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipementMaxAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    marque?: true
    modele?: true
    serie?: true
    dateAchat?: true
    dateDerniereMaintenace?: true
    dateProchaineMaintenance?: true
    statut?: true
    localisation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipementCountAggregateInputType = {
    id?: true
    code?: true
    nom?: true
    type?: true
    marque?: true
    modele?: true
    serie?: true
    dateAchat?: true
    dateDerniereMaintenace?: true
    dateProchaineMaintenance?: true
    statut?: true
    localisation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipement to aggregate.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipements
    **/
    _count?: true | EquipementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipementMaxAggregateInputType
  }

  export type GetEquipementAggregateType<T extends EquipementAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipement[P]>
      : GetScalarType<T[P], AggregateEquipement[P]>
  }




  export type EquipementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipementWhereInput
    orderBy?: EquipementOrderByWithAggregationInput | EquipementOrderByWithAggregationInput[]
    by: EquipementScalarFieldEnum[] | EquipementScalarFieldEnum
    having?: EquipementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipementCountAggregateInputType | true
    _min?: EquipementMinAggregateInputType
    _max?: EquipementMaxAggregateInputType
  }

  export type EquipementGroupByOutputType = {
    id: string
    code: string
    nom: string
    type: string
    marque: string | null
    modele: string | null
    serie: string | null
    dateAchat: Date | null
    dateDerniereMaintenace: Date | null
    dateProchaineMaintenance: Date | null
    statut: string
    localisation: string | null
    createdAt: Date
    updatedAt: Date
    _count: EquipementCountAggregateOutputType | null
    _min: EquipementMinAggregateOutputType | null
    _max: EquipementMaxAggregateOutputType | null
  }

  type GetEquipementGroupByPayload<T extends EquipementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipementGroupByOutputType[P]>
            : GetScalarType<T[P], EquipementGroupByOutputType[P]>
        }
      >
    >


  export type EquipementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    marque?: boolean
    modele?: boolean
    serie?: boolean
    dateAchat?: boolean
    dateDerniereMaintenace?: boolean
    dateProchaineMaintenance?: boolean
    statut?: boolean
    localisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tickets?: boolean | Equipement$ticketsArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    marque?: boolean
    modele?: boolean
    serie?: boolean
    dateAchat?: boolean
    dateDerniereMaintenace?: boolean
    dateProchaineMaintenance?: boolean
    statut?: boolean
    localisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    marque?: boolean
    modele?: boolean
    serie?: boolean
    dateAchat?: boolean
    dateDerniereMaintenace?: boolean
    dateProchaineMaintenance?: boolean
    statut?: boolean
    localisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["equipement"]>

  export type EquipementSelectScalar = {
    id?: boolean
    code?: boolean
    nom?: boolean
    type?: boolean
    marque?: boolean
    modele?: boolean
    serie?: boolean
    dateAchat?: boolean
    dateDerniereMaintenace?: boolean
    dateProchaineMaintenance?: boolean
    statut?: boolean
    localisation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "nom" | "type" | "marque" | "modele" | "serie" | "dateAchat" | "dateDerniereMaintenace" | "dateProchaineMaintenance" | "statut" | "localisation" | "createdAt" | "updatedAt", ExtArgs["result"]["equipement"]>
  export type EquipementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | Equipement$ticketsArgs<ExtArgs>
    _count?: boolean | EquipementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EquipementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EquipementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipement"
    objects: {
      tickets: Prisma.$TicketMaintenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      nom: string
      type: string
      marque: string | null
      modele: string | null
      serie: string | null
      dateAchat: Date | null
      dateDerniereMaintenace: Date | null
      dateProchaineMaintenance: Date | null
      statut: string
      localisation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipement"]>
    composites: {}
  }

  type EquipementGetPayload<S extends boolean | null | undefined | EquipementDefaultArgs> = $Result.GetResult<Prisma.$EquipementPayload, S>

  type EquipementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipementCountAggregateInputType | true
    }

  export interface EquipementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipement'], meta: { name: 'Equipement' } }
    /**
     * Find zero or one Equipement that matches the filter.
     * @param {EquipementFindUniqueArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipementFindUniqueArgs>(args: SelectSubset<T, EquipementFindUniqueArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Equipement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipementFindUniqueOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipementFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Equipement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipementFindFirstArgs>(args?: SelectSubset<T, EquipementFindFirstArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Equipement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindFirstOrThrowArgs} args - Arguments to find a Equipement
     * @example
     * // Get one Equipement
     * const equipement = await prisma.equipement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipementFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Equipements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipements
     * const equipements = await prisma.equipement.findMany()
     * 
     * // Get first 10 Equipements
     * const equipements = await prisma.equipement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipementWithIdOnly = await prisma.equipement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipementFindManyArgs>(args?: SelectSubset<T, EquipementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Equipement.
     * @param {EquipementCreateArgs} args - Arguments to create a Equipement.
     * @example
     * // Create one Equipement
     * const Equipement = await prisma.equipement.create({
     *   data: {
     *     // ... data to create a Equipement
     *   }
     * })
     * 
     */
    create<T extends EquipementCreateArgs>(args: SelectSubset<T, EquipementCreateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Equipements.
     * @param {EquipementCreateManyArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipementCreateManyArgs>(args?: SelectSubset<T, EquipementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipements and returns the data saved in the database.
     * @param {EquipementCreateManyAndReturnArgs} args - Arguments to create many Equipements.
     * @example
     * // Create many Equipements
     * const equipement = await prisma.equipement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipements and only return the `id`
     * const equipementWithIdOnly = await prisma.equipement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipementCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Equipement.
     * @param {EquipementDeleteArgs} args - Arguments to delete one Equipement.
     * @example
     * // Delete one Equipement
     * const Equipement = await prisma.equipement.delete({
     *   where: {
     *     // ... filter to delete one Equipement
     *   }
     * })
     * 
     */
    delete<T extends EquipementDeleteArgs>(args: SelectSubset<T, EquipementDeleteArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Equipement.
     * @param {EquipementUpdateArgs} args - Arguments to update one Equipement.
     * @example
     * // Update one Equipement
     * const equipement = await prisma.equipement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipementUpdateArgs>(args: SelectSubset<T, EquipementUpdateArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Equipements.
     * @param {EquipementDeleteManyArgs} args - Arguments to filter Equipements to delete.
     * @example
     * // Delete a few Equipements
     * const { count } = await prisma.equipement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipementDeleteManyArgs>(args?: SelectSubset<T, EquipementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipements
     * const equipement = await prisma.equipement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipementUpdateManyArgs>(args: SelectSubset<T, EquipementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipements and returns the data updated in the database.
     * @param {EquipementUpdateManyAndReturnArgs} args - Arguments to update many Equipements.
     * @example
     * // Update many Equipements
     * const equipement = await prisma.equipement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipements and only return the `id`
     * const equipementWithIdOnly = await prisma.equipement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipementUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Equipement.
     * @param {EquipementUpsertArgs} args - Arguments to update or create a Equipement.
     * @example
     * // Update or create a Equipement
     * const equipement = await prisma.equipement.upsert({
     *   create: {
     *     // ... data to create a Equipement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipement we want to update
     *   }
     * })
     */
    upsert<T extends EquipementUpsertArgs>(args: SelectSubset<T, EquipementUpsertArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Equipements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementCountArgs} args - Arguments to filter Equipements to count.
     * @example
     * // Count the number of Equipements
     * const count = await prisma.equipement.count({
     *   where: {
     *     // ... the filter for the Equipements we want to count
     *   }
     * })
    **/
    count<T extends EquipementCountArgs>(
      args?: Subset<T, EquipementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipementAggregateArgs>(args: Subset<T, EquipementAggregateArgs>): Prisma.PrismaPromise<GetEquipementAggregateType<T>>

    /**
     * Group by Equipement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipementGroupByArgs['orderBy'] }
        : { orderBy?: EquipementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipement model
   */
  readonly fields: EquipementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends Equipement$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Equipement$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipement model
   */ 
  interface EquipementFieldRefs {
    readonly id: FieldRef<"Equipement", 'String'>
    readonly code: FieldRef<"Equipement", 'String'>
    readonly nom: FieldRef<"Equipement", 'String'>
    readonly type: FieldRef<"Equipement", 'String'>
    readonly marque: FieldRef<"Equipement", 'String'>
    readonly modele: FieldRef<"Equipement", 'String'>
    readonly serie: FieldRef<"Equipement", 'String'>
    readonly dateAchat: FieldRef<"Equipement", 'DateTime'>
    readonly dateDerniereMaintenace: FieldRef<"Equipement", 'DateTime'>
    readonly dateProchaineMaintenance: FieldRef<"Equipement", 'DateTime'>
    readonly statut: FieldRef<"Equipement", 'String'>
    readonly localisation: FieldRef<"Equipement", 'String'>
    readonly createdAt: FieldRef<"Equipement", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipement findUnique
   */
  export type EquipementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findUniqueOrThrow
   */
  export type EquipementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement findFirst
   */
  export type EquipementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findFirstOrThrow
   */
  export type EquipementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipement to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipements.
     */
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement findMany
   */
  export type EquipementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter, which Equipements to fetch.
     */
    where?: EquipementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipements to fetch.
     */
    orderBy?: EquipementOrderByWithRelationInput | EquipementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipements.
     */
    cursor?: EquipementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipements.
     */
    skip?: number
    distinct?: EquipementScalarFieldEnum | EquipementScalarFieldEnum[]
  }

  /**
   * Equipement create
   */
  export type EquipementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipement.
     */
    data: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
  }

  /**
   * Equipement createMany
   */
  export type EquipementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement createManyAndReturn
   */
  export type EquipementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * The data used to create many Equipements.
     */
    data: EquipementCreateManyInput | EquipementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipement update
   */
  export type EquipementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipement.
     */
    data: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
    /**
     * Choose, which Equipement to update.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement updateMany
   */
  export type EquipementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipements.
     */
    data: XOR<EquipementUpdateManyMutationInput, EquipementUncheckedUpdateManyInput>
    /**
     * Filter which Equipements to update
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement updateManyAndReturn
   */
  export type EquipementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * The data used to update Equipements.
     */
    data: XOR<EquipementUpdateManyMutationInput, EquipementUncheckedUpdateManyInput>
    /**
     * Filter which Equipements to update
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement upsert
   */
  export type EquipementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipement to update in case it exists.
     */
    where: EquipementWhereUniqueInput
    /**
     * In case the Equipement found by the `where` argument doesn't exist, create a new Equipement with this data.
     */
    create: XOR<EquipementCreateInput, EquipementUncheckedCreateInput>
    /**
     * In case the Equipement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipementUpdateInput, EquipementUncheckedUpdateInput>
  }

  /**
   * Equipement delete
   */
  export type EquipementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
    /**
     * Filter which Equipement to delete.
     */
    where: EquipementWhereUniqueInput
  }

  /**
   * Equipement deleteMany
   */
  export type EquipementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipements to delete
     */
    where?: EquipementWhereInput
  }

  /**
   * Equipement.tickets
   */
  export type Equipement$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    where?: TicketMaintenanceWhereInput
    orderBy?: TicketMaintenanceOrderByWithRelationInput | TicketMaintenanceOrderByWithRelationInput[]
    cursor?: TicketMaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketMaintenanceScalarFieldEnum | TicketMaintenanceScalarFieldEnum[]
  }

  /**
   * Equipement without action
   */
  export type EquipementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipement
     */
    select?: EquipementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipement
     */
    omit?: EquipementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipementInclude<ExtArgs> | null
  }


  /**
   * Model TicketMaintenance
   */

  export type AggregateTicketMaintenance = {
    _count: TicketMaintenanceCountAggregateOutputType | null
    _avg: TicketMaintenanceAvgAggregateOutputType | null
    _sum: TicketMaintenanceSumAggregateOutputType | null
    _min: TicketMaintenanceMinAggregateOutputType | null
    _max: TicketMaintenanceMaxAggregateOutputType | null
  }

  export type TicketMaintenanceAvgAggregateOutputType = {
    coutEstime: Decimal | null
  }

  export type TicketMaintenanceSumAggregateOutputType = {
    coutEstime: Decimal | null
  }

  export type TicketMaintenanceMinAggregateOutputType = {
    id: string | null
    equipementId: string | null
    type: string | null
    priorite: string | null
    objet: string | null
    description: string | null
    statut: string | null
    intervenant: string | null
    dateResolution: Date | null
    coutEstime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaintenanceMaxAggregateOutputType = {
    id: string | null
    equipementId: string | null
    type: string | null
    priorite: string | null
    objet: string | null
    description: string | null
    statut: string | null
    intervenant: string | null
    dateResolution: Date | null
    coutEstime: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaintenanceCountAggregateOutputType = {
    id: number
    equipementId: number
    type: number
    priorite: number
    objet: number
    description: number
    statut: number
    intervenant: number
    dateResolution: number
    coutEstime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketMaintenanceAvgAggregateInputType = {
    coutEstime?: true
  }

  export type TicketMaintenanceSumAggregateInputType = {
    coutEstime?: true
  }

  export type TicketMaintenanceMinAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    priorite?: true
    objet?: true
    description?: true
    statut?: true
    intervenant?: true
    dateResolution?: true
    coutEstime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaintenanceMaxAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    priorite?: true
    objet?: true
    description?: true
    statut?: true
    intervenant?: true
    dateResolution?: true
    coutEstime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaintenanceCountAggregateInputType = {
    id?: true
    equipementId?: true
    type?: true
    priorite?: true
    objet?: true
    description?: true
    statut?: true
    intervenant?: true
    dateResolution?: true
    coutEstime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketMaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMaintenance to aggregate.
     */
    where?: TicketMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMaintenances to fetch.
     */
    orderBy?: TicketMaintenanceOrderByWithRelationInput | TicketMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketMaintenances
    **/
    _count?: true | TicketMaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketMaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketMaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaintenanceMaxAggregateInputType
  }

  export type GetTicketMaintenanceAggregateType<T extends TicketMaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketMaintenance[P]>
      : GetScalarType<T[P], AggregateTicketMaintenance[P]>
  }




  export type TicketMaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketMaintenanceWhereInput
    orderBy?: TicketMaintenanceOrderByWithAggregationInput | TicketMaintenanceOrderByWithAggregationInput[]
    by: TicketMaintenanceScalarFieldEnum[] | TicketMaintenanceScalarFieldEnum
    having?: TicketMaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketMaintenanceCountAggregateInputType | true
    _avg?: TicketMaintenanceAvgAggregateInputType
    _sum?: TicketMaintenanceSumAggregateInputType
    _min?: TicketMaintenanceMinAggregateInputType
    _max?: TicketMaintenanceMaxAggregateInputType
  }

  export type TicketMaintenanceGroupByOutputType = {
    id: string
    equipementId: string
    type: string
    priorite: string
    objet: string
    description: string
    statut: string
    intervenant: string | null
    dateResolution: Date | null
    coutEstime: Decimal | null
    createdAt: Date
    updatedAt: Date
    _count: TicketMaintenanceCountAggregateOutputType | null
    _avg: TicketMaintenanceAvgAggregateOutputType | null
    _sum: TicketMaintenanceSumAggregateOutputType | null
    _min: TicketMaintenanceMinAggregateOutputType | null
    _max: TicketMaintenanceMaxAggregateOutputType | null
  }

  type GetTicketMaintenanceGroupByPayload<T extends TicketMaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketMaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketMaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketMaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], TicketMaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type TicketMaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipementId?: boolean
    type?: boolean
    priorite?: boolean
    objet?: boolean
    description?: boolean
    statut?: boolean
    intervenant?: boolean
    dateResolution?: boolean
    coutEstime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMaintenance"]>

  export type TicketMaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipementId?: boolean
    type?: boolean
    priorite?: boolean
    objet?: boolean
    description?: boolean
    statut?: boolean
    intervenant?: boolean
    dateResolution?: boolean
    coutEstime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMaintenance"]>

  export type TicketMaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipementId?: boolean
    type?: boolean
    priorite?: boolean
    objet?: boolean
    description?: boolean
    statut?: boolean
    intervenant?: boolean
    dateResolution?: boolean
    coutEstime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketMaintenance"]>

  export type TicketMaintenanceSelectScalar = {
    id?: boolean
    equipementId?: boolean
    type?: boolean
    priorite?: boolean
    objet?: boolean
    description?: boolean
    statut?: boolean
    intervenant?: boolean
    dateResolution?: boolean
    coutEstime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketMaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipementId" | "type" | "priorite" | "objet" | "description" | "statut" | "intervenant" | "dateResolution" | "coutEstime" | "createdAt" | "updatedAt", ExtArgs["result"]["ticketMaintenance"]>
  export type TicketMaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }
  export type TicketMaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }
  export type TicketMaintenanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipement?: boolean | EquipementDefaultArgs<ExtArgs>
  }

  export type $TicketMaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketMaintenance"
    objects: {
      equipement: Prisma.$EquipementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipementId: string
      type: string
      priorite: string
      objet: string
      description: string
      statut: string
      intervenant: string | null
      dateResolution: Date | null
      coutEstime: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticketMaintenance"]>
    composites: {}
  }

  type TicketMaintenanceGetPayload<S extends boolean | null | undefined | TicketMaintenanceDefaultArgs> = $Result.GetResult<Prisma.$TicketMaintenancePayload, S>

  type TicketMaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketMaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketMaintenanceCountAggregateInputType | true
    }

  export interface TicketMaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketMaintenance'], meta: { name: 'TicketMaintenance' } }
    /**
     * Find zero or one TicketMaintenance that matches the filter.
     * @param {TicketMaintenanceFindUniqueArgs} args - Arguments to find a TicketMaintenance
     * @example
     * // Get one TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketMaintenanceFindUniqueArgs>(args: SelectSubset<T, TicketMaintenanceFindUniqueArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TicketMaintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketMaintenanceFindUniqueOrThrowArgs} args - Arguments to find a TicketMaintenance
     * @example
     * // Get one TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketMaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketMaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TicketMaintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceFindFirstArgs} args - Arguments to find a TicketMaintenance
     * @example
     * // Get one TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketMaintenanceFindFirstArgs>(args?: SelectSubset<T, TicketMaintenanceFindFirstArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TicketMaintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceFindFirstOrThrowArgs} args - Arguments to find a TicketMaintenance
     * @example
     * // Get one TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketMaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketMaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TicketMaintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketMaintenances
     * const ticketMaintenances = await prisma.ticketMaintenance.findMany()
     * 
     * // Get first 10 TicketMaintenances
     * const ticketMaintenances = await prisma.ticketMaintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketMaintenanceWithIdOnly = await prisma.ticketMaintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketMaintenanceFindManyArgs>(args?: SelectSubset<T, TicketMaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TicketMaintenance.
     * @param {TicketMaintenanceCreateArgs} args - Arguments to create a TicketMaintenance.
     * @example
     * // Create one TicketMaintenance
     * const TicketMaintenance = await prisma.ticketMaintenance.create({
     *   data: {
     *     // ... data to create a TicketMaintenance
     *   }
     * })
     * 
     */
    create<T extends TicketMaintenanceCreateArgs>(args: SelectSubset<T, TicketMaintenanceCreateArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TicketMaintenances.
     * @param {TicketMaintenanceCreateManyArgs} args - Arguments to create many TicketMaintenances.
     * @example
     * // Create many TicketMaintenances
     * const ticketMaintenance = await prisma.ticketMaintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketMaintenanceCreateManyArgs>(args?: SelectSubset<T, TicketMaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketMaintenances and returns the data saved in the database.
     * @param {TicketMaintenanceCreateManyAndReturnArgs} args - Arguments to create many TicketMaintenances.
     * @example
     * // Create many TicketMaintenances
     * const ticketMaintenance = await prisma.ticketMaintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketMaintenances and only return the `id`
     * const ticketMaintenanceWithIdOnly = await prisma.ticketMaintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketMaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketMaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TicketMaintenance.
     * @param {TicketMaintenanceDeleteArgs} args - Arguments to delete one TicketMaintenance.
     * @example
     * // Delete one TicketMaintenance
     * const TicketMaintenance = await prisma.ticketMaintenance.delete({
     *   where: {
     *     // ... filter to delete one TicketMaintenance
     *   }
     * })
     * 
     */
    delete<T extends TicketMaintenanceDeleteArgs>(args: SelectSubset<T, TicketMaintenanceDeleteArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TicketMaintenance.
     * @param {TicketMaintenanceUpdateArgs} args - Arguments to update one TicketMaintenance.
     * @example
     * // Update one TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketMaintenanceUpdateArgs>(args: SelectSubset<T, TicketMaintenanceUpdateArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TicketMaintenances.
     * @param {TicketMaintenanceDeleteManyArgs} args - Arguments to filter TicketMaintenances to delete.
     * @example
     * // Delete a few TicketMaintenances
     * const { count } = await prisma.ticketMaintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketMaintenanceDeleteManyArgs>(args?: SelectSubset<T, TicketMaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketMaintenances
     * const ticketMaintenance = await prisma.ticketMaintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketMaintenanceUpdateManyArgs>(args: SelectSubset<T, TicketMaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketMaintenances and returns the data updated in the database.
     * @param {TicketMaintenanceUpdateManyAndReturnArgs} args - Arguments to update many TicketMaintenances.
     * @example
     * // Update many TicketMaintenances
     * const ticketMaintenance = await prisma.ticketMaintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketMaintenances and only return the `id`
     * const ticketMaintenanceWithIdOnly = await prisma.ticketMaintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketMaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketMaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TicketMaintenance.
     * @param {TicketMaintenanceUpsertArgs} args - Arguments to update or create a TicketMaintenance.
     * @example
     * // Update or create a TicketMaintenance
     * const ticketMaintenance = await prisma.ticketMaintenance.upsert({
     *   create: {
     *     // ... data to create a TicketMaintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketMaintenance we want to update
     *   }
     * })
     */
    upsert<T extends TicketMaintenanceUpsertArgs>(args: SelectSubset<T, TicketMaintenanceUpsertArgs<ExtArgs>>): Prisma__TicketMaintenanceClient<$Result.GetResult<Prisma.$TicketMaintenancePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TicketMaintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceCountArgs} args - Arguments to filter TicketMaintenances to count.
     * @example
     * // Count the number of TicketMaintenances
     * const count = await prisma.ticketMaintenance.count({
     *   where: {
     *     // ... the filter for the TicketMaintenances we want to count
     *   }
     * })
    **/
    count<T extends TicketMaintenanceCountArgs>(
      args?: Subset<T, TicketMaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketMaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketMaintenanceAggregateArgs>(args: Subset<T, TicketMaintenanceAggregateArgs>): Prisma.PrismaPromise<GetTicketMaintenanceAggregateType<T>>

    /**
     * Group by TicketMaintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketMaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketMaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketMaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: TicketMaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketMaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketMaintenance model
   */
  readonly fields: TicketMaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketMaintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketMaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipement<T extends EquipementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipementDefaultArgs<ExtArgs>>): Prisma__EquipementClient<$Result.GetResult<Prisma.$EquipementPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketMaintenance model
   */ 
  interface TicketMaintenanceFieldRefs {
    readonly id: FieldRef<"TicketMaintenance", 'String'>
    readonly equipementId: FieldRef<"TicketMaintenance", 'String'>
    readonly type: FieldRef<"TicketMaintenance", 'String'>
    readonly priorite: FieldRef<"TicketMaintenance", 'String'>
    readonly objet: FieldRef<"TicketMaintenance", 'String'>
    readonly description: FieldRef<"TicketMaintenance", 'String'>
    readonly statut: FieldRef<"TicketMaintenance", 'String'>
    readonly intervenant: FieldRef<"TicketMaintenance", 'String'>
    readonly dateResolution: FieldRef<"TicketMaintenance", 'DateTime'>
    readonly coutEstime: FieldRef<"TicketMaintenance", 'Decimal'>
    readonly createdAt: FieldRef<"TicketMaintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketMaintenance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketMaintenance findUnique
   */
  export type TicketMaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TicketMaintenance to fetch.
     */
    where: TicketMaintenanceWhereUniqueInput
  }

  /**
   * TicketMaintenance findUniqueOrThrow
   */
  export type TicketMaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TicketMaintenance to fetch.
     */
    where: TicketMaintenanceWhereUniqueInput
  }

  /**
   * TicketMaintenance findFirst
   */
  export type TicketMaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TicketMaintenance to fetch.
     */
    where?: TicketMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMaintenances to fetch.
     */
    orderBy?: TicketMaintenanceOrderByWithRelationInput | TicketMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMaintenances.
     */
    cursor?: TicketMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMaintenances.
     */
    distinct?: TicketMaintenanceScalarFieldEnum | TicketMaintenanceScalarFieldEnum[]
  }

  /**
   * TicketMaintenance findFirstOrThrow
   */
  export type TicketMaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TicketMaintenance to fetch.
     */
    where?: TicketMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMaintenances to fetch.
     */
    orderBy?: TicketMaintenanceOrderByWithRelationInput | TicketMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketMaintenances.
     */
    cursor?: TicketMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMaintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketMaintenances.
     */
    distinct?: TicketMaintenanceScalarFieldEnum | TicketMaintenanceScalarFieldEnum[]
  }

  /**
   * TicketMaintenance findMany
   */
  export type TicketMaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which TicketMaintenances to fetch.
     */
    where?: TicketMaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketMaintenances to fetch.
     */
    orderBy?: TicketMaintenanceOrderByWithRelationInput | TicketMaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketMaintenances.
     */
    cursor?: TicketMaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketMaintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketMaintenances.
     */
    skip?: number
    distinct?: TicketMaintenanceScalarFieldEnum | TicketMaintenanceScalarFieldEnum[]
  }

  /**
   * TicketMaintenance create
   */
  export type TicketMaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketMaintenance.
     */
    data: XOR<TicketMaintenanceCreateInput, TicketMaintenanceUncheckedCreateInput>
  }

  /**
   * TicketMaintenance createMany
   */
  export type TicketMaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketMaintenances.
     */
    data: TicketMaintenanceCreateManyInput | TicketMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketMaintenance createManyAndReturn
   */
  export type TicketMaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many TicketMaintenances.
     */
    data: TicketMaintenanceCreateManyInput | TicketMaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMaintenance update
   */
  export type TicketMaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketMaintenance.
     */
    data: XOR<TicketMaintenanceUpdateInput, TicketMaintenanceUncheckedUpdateInput>
    /**
     * Choose, which TicketMaintenance to update.
     */
    where: TicketMaintenanceWhereUniqueInput
  }

  /**
   * TicketMaintenance updateMany
   */
  export type TicketMaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketMaintenances.
     */
    data: XOR<TicketMaintenanceUpdateManyMutationInput, TicketMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which TicketMaintenances to update
     */
    where?: TicketMaintenanceWhereInput
  }

  /**
   * TicketMaintenance updateManyAndReturn
   */
  export type TicketMaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update TicketMaintenances.
     */
    data: XOR<TicketMaintenanceUpdateManyMutationInput, TicketMaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which TicketMaintenances to update
     */
    where?: TicketMaintenanceWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketMaintenance upsert
   */
  export type TicketMaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketMaintenance to update in case it exists.
     */
    where: TicketMaintenanceWhereUniqueInput
    /**
     * In case the TicketMaintenance found by the `where` argument doesn't exist, create a new TicketMaintenance with this data.
     */
    create: XOR<TicketMaintenanceCreateInput, TicketMaintenanceUncheckedCreateInput>
    /**
     * In case the TicketMaintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketMaintenanceUpdateInput, TicketMaintenanceUncheckedUpdateInput>
  }

  /**
   * TicketMaintenance delete
   */
  export type TicketMaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
    /**
     * Filter which TicketMaintenance to delete.
     */
    where: TicketMaintenanceWhereUniqueInput
  }

  /**
   * TicketMaintenance deleteMany
   */
  export type TicketMaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketMaintenances to delete
     */
    where?: TicketMaintenanceWhereInput
  }

  /**
   * TicketMaintenance without action
   */
  export type TicketMaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketMaintenance
     */
    select?: TicketMaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketMaintenance
     */
    omit?: TicketMaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketMaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model EvenementIndesirable
   */

  export type AggregateEvenementIndesirable = {
    _count: EvenementIndesirableCountAggregateOutputType | null
    _min: EvenementIndesirableMinAggregateOutputType | null
    _max: EvenementIndesirableMaxAggregateOutputType | null
  }

  export type EvenementIndesirableMinAggregateOutputType = {
    id: string | null
    dateEvenement: Date | null
    service: string | null
    type: string | null
    gravite: string | null
    description: string | null
    mesuresPrises: string | null
    statut: string | null
    declaréPar: string | null
    patientId: string | null
    createdAt: Date | null
  }

  export type EvenementIndesirableMaxAggregateOutputType = {
    id: string | null
    dateEvenement: Date | null
    service: string | null
    type: string | null
    gravite: string | null
    description: string | null
    mesuresPrises: string | null
    statut: string | null
    declaréPar: string | null
    patientId: string | null
    createdAt: Date | null
  }

  export type EvenementIndesirableCountAggregateOutputType = {
    id: number
    dateEvenement: number
    service: number
    type: number
    gravite: number
    description: number
    mesuresPrises: number
    statut: number
    declaréPar: number
    patientId: number
    createdAt: number
    _all: number
  }


  export type EvenementIndesirableMinAggregateInputType = {
    id?: true
    dateEvenement?: true
    service?: true
    type?: true
    gravite?: true
    description?: true
    mesuresPrises?: true
    statut?: true
    declaréPar?: true
    patientId?: true
    createdAt?: true
  }

  export type EvenementIndesirableMaxAggregateInputType = {
    id?: true
    dateEvenement?: true
    service?: true
    type?: true
    gravite?: true
    description?: true
    mesuresPrises?: true
    statut?: true
    declaréPar?: true
    patientId?: true
    createdAt?: true
  }

  export type EvenementIndesirableCountAggregateInputType = {
    id?: true
    dateEvenement?: true
    service?: true
    type?: true
    gravite?: true
    description?: true
    mesuresPrises?: true
    statut?: true
    declaréPar?: true
    patientId?: true
    createdAt?: true
    _all?: true
  }

  export type EvenementIndesirableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvenementIndesirable to aggregate.
     */
    where?: EvenementIndesirableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementIndesirables to fetch.
     */
    orderBy?: EvenementIndesirableOrderByWithRelationInput | EvenementIndesirableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvenementIndesirableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementIndesirables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementIndesirables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvenementIndesirables
    **/
    _count?: true | EvenementIndesirableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvenementIndesirableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvenementIndesirableMaxAggregateInputType
  }

  export type GetEvenementIndesirableAggregateType<T extends EvenementIndesirableAggregateArgs> = {
        [P in keyof T & keyof AggregateEvenementIndesirable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvenementIndesirable[P]>
      : GetScalarType<T[P], AggregateEvenementIndesirable[P]>
  }




  export type EvenementIndesirableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvenementIndesirableWhereInput
    orderBy?: EvenementIndesirableOrderByWithAggregationInput | EvenementIndesirableOrderByWithAggregationInput[]
    by: EvenementIndesirableScalarFieldEnum[] | EvenementIndesirableScalarFieldEnum
    having?: EvenementIndesirableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvenementIndesirableCountAggregateInputType | true
    _min?: EvenementIndesirableMinAggregateInputType
    _max?: EvenementIndesirableMaxAggregateInputType
  }

  export type EvenementIndesirableGroupByOutputType = {
    id: string
    dateEvenement: Date
    service: string | null
    type: string
    gravite: string
    description: string
    mesuresPrises: string | null
    statut: string
    declaréPar: string | null
    patientId: string | null
    createdAt: Date
    _count: EvenementIndesirableCountAggregateOutputType | null
    _min: EvenementIndesirableMinAggregateOutputType | null
    _max: EvenementIndesirableMaxAggregateOutputType | null
  }

  type GetEvenementIndesirableGroupByPayload<T extends EvenementIndesirableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvenementIndesirableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvenementIndesirableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvenementIndesirableGroupByOutputType[P]>
            : GetScalarType<T[P], EvenementIndesirableGroupByOutputType[P]>
        }
      >
    >


  export type EvenementIndesirableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateEvenement?: boolean
    service?: boolean
    type?: boolean
    gravite?: boolean
    description?: boolean
    mesuresPrises?: boolean
    statut?: boolean
    declaréPar?: boolean
    patientId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["evenementIndesirable"]>

  export type EvenementIndesirableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateEvenement?: boolean
    service?: boolean
    type?: boolean
    gravite?: boolean
    description?: boolean
    mesuresPrises?: boolean
    statut?: boolean
    declaréPar?: boolean
    patientId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["evenementIndesirable"]>

  export type EvenementIndesirableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateEvenement?: boolean
    service?: boolean
    type?: boolean
    gravite?: boolean
    description?: boolean
    mesuresPrises?: boolean
    statut?: boolean
    declaréPar?: boolean
    patientId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["evenementIndesirable"]>

  export type EvenementIndesirableSelectScalar = {
    id?: boolean
    dateEvenement?: boolean
    service?: boolean
    type?: boolean
    gravite?: boolean
    description?: boolean
    mesuresPrises?: boolean
    statut?: boolean
    declaréPar?: boolean
    patientId?: boolean
    createdAt?: boolean
  }

  export type EvenementIndesirableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateEvenement" | "service" | "type" | "gravite" | "description" | "mesuresPrises" | "statut" | "declaréPar" | "patientId" | "createdAt", ExtArgs["result"]["evenementIndesirable"]>

  export type $EvenementIndesirablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvenementIndesirable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateEvenement: Date
      service: string | null
      type: string
      gravite: string
      description: string
      mesuresPrises: string | null
      statut: string
      declaréPar: string | null
      patientId: string | null
      createdAt: Date
    }, ExtArgs["result"]["evenementIndesirable"]>
    composites: {}
  }

  type EvenementIndesirableGetPayload<S extends boolean | null | undefined | EvenementIndesirableDefaultArgs> = $Result.GetResult<Prisma.$EvenementIndesirablePayload, S>

  type EvenementIndesirableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvenementIndesirableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvenementIndesirableCountAggregateInputType | true
    }

  export interface EvenementIndesirableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvenementIndesirable'], meta: { name: 'EvenementIndesirable' } }
    /**
     * Find zero or one EvenementIndesirable that matches the filter.
     * @param {EvenementIndesirableFindUniqueArgs} args - Arguments to find a EvenementIndesirable
     * @example
     * // Get one EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvenementIndesirableFindUniqueArgs>(args: SelectSubset<T, EvenementIndesirableFindUniqueArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EvenementIndesirable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvenementIndesirableFindUniqueOrThrowArgs} args - Arguments to find a EvenementIndesirable
     * @example
     * // Get one EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvenementIndesirableFindUniqueOrThrowArgs>(args: SelectSubset<T, EvenementIndesirableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EvenementIndesirable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableFindFirstArgs} args - Arguments to find a EvenementIndesirable
     * @example
     * // Get one EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvenementIndesirableFindFirstArgs>(args?: SelectSubset<T, EvenementIndesirableFindFirstArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EvenementIndesirable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableFindFirstOrThrowArgs} args - Arguments to find a EvenementIndesirable
     * @example
     * // Get one EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvenementIndesirableFindFirstOrThrowArgs>(args?: SelectSubset<T, EvenementIndesirableFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EvenementIndesirables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvenementIndesirables
     * const evenementIndesirables = await prisma.evenementIndesirable.findMany()
     * 
     * // Get first 10 EvenementIndesirables
     * const evenementIndesirables = await prisma.evenementIndesirable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evenementIndesirableWithIdOnly = await prisma.evenementIndesirable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvenementIndesirableFindManyArgs>(args?: SelectSubset<T, EvenementIndesirableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EvenementIndesirable.
     * @param {EvenementIndesirableCreateArgs} args - Arguments to create a EvenementIndesirable.
     * @example
     * // Create one EvenementIndesirable
     * const EvenementIndesirable = await prisma.evenementIndesirable.create({
     *   data: {
     *     // ... data to create a EvenementIndesirable
     *   }
     * })
     * 
     */
    create<T extends EvenementIndesirableCreateArgs>(args: SelectSubset<T, EvenementIndesirableCreateArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EvenementIndesirables.
     * @param {EvenementIndesirableCreateManyArgs} args - Arguments to create many EvenementIndesirables.
     * @example
     * // Create many EvenementIndesirables
     * const evenementIndesirable = await prisma.evenementIndesirable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvenementIndesirableCreateManyArgs>(args?: SelectSubset<T, EvenementIndesirableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvenementIndesirables and returns the data saved in the database.
     * @param {EvenementIndesirableCreateManyAndReturnArgs} args - Arguments to create many EvenementIndesirables.
     * @example
     * // Create many EvenementIndesirables
     * const evenementIndesirable = await prisma.evenementIndesirable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvenementIndesirables and only return the `id`
     * const evenementIndesirableWithIdOnly = await prisma.evenementIndesirable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvenementIndesirableCreateManyAndReturnArgs>(args?: SelectSubset<T, EvenementIndesirableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EvenementIndesirable.
     * @param {EvenementIndesirableDeleteArgs} args - Arguments to delete one EvenementIndesirable.
     * @example
     * // Delete one EvenementIndesirable
     * const EvenementIndesirable = await prisma.evenementIndesirable.delete({
     *   where: {
     *     // ... filter to delete one EvenementIndesirable
     *   }
     * })
     * 
     */
    delete<T extends EvenementIndesirableDeleteArgs>(args: SelectSubset<T, EvenementIndesirableDeleteArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EvenementIndesirable.
     * @param {EvenementIndesirableUpdateArgs} args - Arguments to update one EvenementIndesirable.
     * @example
     * // Update one EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvenementIndesirableUpdateArgs>(args: SelectSubset<T, EvenementIndesirableUpdateArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EvenementIndesirables.
     * @param {EvenementIndesirableDeleteManyArgs} args - Arguments to filter EvenementIndesirables to delete.
     * @example
     * // Delete a few EvenementIndesirables
     * const { count } = await prisma.evenementIndesirable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvenementIndesirableDeleteManyArgs>(args?: SelectSubset<T, EvenementIndesirableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvenementIndesirables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvenementIndesirables
     * const evenementIndesirable = await prisma.evenementIndesirable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvenementIndesirableUpdateManyArgs>(args: SelectSubset<T, EvenementIndesirableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvenementIndesirables and returns the data updated in the database.
     * @param {EvenementIndesirableUpdateManyAndReturnArgs} args - Arguments to update many EvenementIndesirables.
     * @example
     * // Update many EvenementIndesirables
     * const evenementIndesirable = await prisma.evenementIndesirable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvenementIndesirables and only return the `id`
     * const evenementIndesirableWithIdOnly = await prisma.evenementIndesirable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvenementIndesirableUpdateManyAndReturnArgs>(args: SelectSubset<T, EvenementIndesirableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EvenementIndesirable.
     * @param {EvenementIndesirableUpsertArgs} args - Arguments to update or create a EvenementIndesirable.
     * @example
     * // Update or create a EvenementIndesirable
     * const evenementIndesirable = await prisma.evenementIndesirable.upsert({
     *   create: {
     *     // ... data to create a EvenementIndesirable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvenementIndesirable we want to update
     *   }
     * })
     */
    upsert<T extends EvenementIndesirableUpsertArgs>(args: SelectSubset<T, EvenementIndesirableUpsertArgs<ExtArgs>>): Prisma__EvenementIndesirableClient<$Result.GetResult<Prisma.$EvenementIndesirablePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EvenementIndesirables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableCountArgs} args - Arguments to filter EvenementIndesirables to count.
     * @example
     * // Count the number of EvenementIndesirables
     * const count = await prisma.evenementIndesirable.count({
     *   where: {
     *     // ... the filter for the EvenementIndesirables we want to count
     *   }
     * })
    **/
    count<T extends EvenementIndesirableCountArgs>(
      args?: Subset<T, EvenementIndesirableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvenementIndesirableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvenementIndesirable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvenementIndesirableAggregateArgs>(args: Subset<T, EvenementIndesirableAggregateArgs>): Prisma.PrismaPromise<GetEvenementIndesirableAggregateType<T>>

    /**
     * Group by EvenementIndesirable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvenementIndesirableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvenementIndesirableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvenementIndesirableGroupByArgs['orderBy'] }
        : { orderBy?: EvenementIndesirableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvenementIndesirableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvenementIndesirableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvenementIndesirable model
   */
  readonly fields: EvenementIndesirableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvenementIndesirable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvenementIndesirableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvenementIndesirable model
   */ 
  interface EvenementIndesirableFieldRefs {
    readonly id: FieldRef<"EvenementIndesirable", 'String'>
    readonly dateEvenement: FieldRef<"EvenementIndesirable", 'DateTime'>
    readonly service: FieldRef<"EvenementIndesirable", 'String'>
    readonly type: FieldRef<"EvenementIndesirable", 'String'>
    readonly gravite: FieldRef<"EvenementIndesirable", 'String'>
    readonly description: FieldRef<"EvenementIndesirable", 'String'>
    readonly mesuresPrises: FieldRef<"EvenementIndesirable", 'String'>
    readonly statut: FieldRef<"EvenementIndesirable", 'String'>
    readonly declaréPar: FieldRef<"EvenementIndesirable", 'String'>
    readonly patientId: FieldRef<"EvenementIndesirable", 'String'>
    readonly createdAt: FieldRef<"EvenementIndesirable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvenementIndesirable findUnique
   */
  export type EvenementIndesirableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter, which EvenementIndesirable to fetch.
     */
    where: EvenementIndesirableWhereUniqueInput
  }

  /**
   * EvenementIndesirable findUniqueOrThrow
   */
  export type EvenementIndesirableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter, which EvenementIndesirable to fetch.
     */
    where: EvenementIndesirableWhereUniqueInput
  }

  /**
   * EvenementIndesirable findFirst
   */
  export type EvenementIndesirableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter, which EvenementIndesirable to fetch.
     */
    where?: EvenementIndesirableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementIndesirables to fetch.
     */
    orderBy?: EvenementIndesirableOrderByWithRelationInput | EvenementIndesirableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvenementIndesirables.
     */
    cursor?: EvenementIndesirableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementIndesirables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementIndesirables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvenementIndesirables.
     */
    distinct?: EvenementIndesirableScalarFieldEnum | EvenementIndesirableScalarFieldEnum[]
  }

  /**
   * EvenementIndesirable findFirstOrThrow
   */
  export type EvenementIndesirableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter, which EvenementIndesirable to fetch.
     */
    where?: EvenementIndesirableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementIndesirables to fetch.
     */
    orderBy?: EvenementIndesirableOrderByWithRelationInput | EvenementIndesirableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvenementIndesirables.
     */
    cursor?: EvenementIndesirableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementIndesirables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementIndesirables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvenementIndesirables.
     */
    distinct?: EvenementIndesirableScalarFieldEnum | EvenementIndesirableScalarFieldEnum[]
  }

  /**
   * EvenementIndesirable findMany
   */
  export type EvenementIndesirableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter, which EvenementIndesirables to fetch.
     */
    where?: EvenementIndesirableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvenementIndesirables to fetch.
     */
    orderBy?: EvenementIndesirableOrderByWithRelationInput | EvenementIndesirableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvenementIndesirables.
     */
    cursor?: EvenementIndesirableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvenementIndesirables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvenementIndesirables.
     */
    skip?: number
    distinct?: EvenementIndesirableScalarFieldEnum | EvenementIndesirableScalarFieldEnum[]
  }

  /**
   * EvenementIndesirable create
   */
  export type EvenementIndesirableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * The data needed to create a EvenementIndesirable.
     */
    data: XOR<EvenementIndesirableCreateInput, EvenementIndesirableUncheckedCreateInput>
  }

  /**
   * EvenementIndesirable createMany
   */
  export type EvenementIndesirableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvenementIndesirables.
     */
    data: EvenementIndesirableCreateManyInput | EvenementIndesirableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvenementIndesirable createManyAndReturn
   */
  export type EvenementIndesirableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * The data used to create many EvenementIndesirables.
     */
    data: EvenementIndesirableCreateManyInput | EvenementIndesirableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvenementIndesirable update
   */
  export type EvenementIndesirableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * The data needed to update a EvenementIndesirable.
     */
    data: XOR<EvenementIndesirableUpdateInput, EvenementIndesirableUncheckedUpdateInput>
    /**
     * Choose, which EvenementIndesirable to update.
     */
    where: EvenementIndesirableWhereUniqueInput
  }

  /**
   * EvenementIndesirable updateMany
   */
  export type EvenementIndesirableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvenementIndesirables.
     */
    data: XOR<EvenementIndesirableUpdateManyMutationInput, EvenementIndesirableUncheckedUpdateManyInput>
    /**
     * Filter which EvenementIndesirables to update
     */
    where?: EvenementIndesirableWhereInput
  }

  /**
   * EvenementIndesirable updateManyAndReturn
   */
  export type EvenementIndesirableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * The data used to update EvenementIndesirables.
     */
    data: XOR<EvenementIndesirableUpdateManyMutationInput, EvenementIndesirableUncheckedUpdateManyInput>
    /**
     * Filter which EvenementIndesirables to update
     */
    where?: EvenementIndesirableWhereInput
  }

  /**
   * EvenementIndesirable upsert
   */
  export type EvenementIndesirableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * The filter to search for the EvenementIndesirable to update in case it exists.
     */
    where: EvenementIndesirableWhereUniqueInput
    /**
     * In case the EvenementIndesirable found by the `where` argument doesn't exist, create a new EvenementIndesirable with this data.
     */
    create: XOR<EvenementIndesirableCreateInput, EvenementIndesirableUncheckedCreateInput>
    /**
     * In case the EvenementIndesirable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvenementIndesirableUpdateInput, EvenementIndesirableUncheckedUpdateInput>
  }

  /**
   * EvenementIndesirable delete
   */
  export type EvenementIndesirableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
    /**
     * Filter which EvenementIndesirable to delete.
     */
    where: EvenementIndesirableWhereUniqueInput
  }

  /**
   * EvenementIndesirable deleteMany
   */
  export type EvenementIndesirableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvenementIndesirables to delete
     */
    where?: EvenementIndesirableWhereInput
  }

  /**
   * EvenementIndesirable without action
   */
  export type EvenementIndesirableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvenementIndesirable
     */
    select?: EvenementIndesirableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvenementIndesirable
     */
    omit?: EvenementIndesirableOmit<ExtArgs> | null
  }


  /**
   * Model AuditQualite
   */

  export type AggregateAuditQualite = {
    _count: AuditQualiteCountAggregateOutputType | null
    _avg: AuditQualiteAvgAggregateOutputType | null
    _sum: AuditQualiteSumAggregateOutputType | null
    _min: AuditQualiteMinAggregateOutputType | null
    _max: AuditQualiteMaxAggregateOutputType | null
  }

  export type AuditQualiteAvgAggregateOutputType = {
    score: number | null
  }

  export type AuditQualiteSumAggregateOutputType = {
    score: number | null
  }

  export type AuditQualiteMinAggregateOutputType = {
    id: string | null
    dateAudit: Date | null
    service: string | null
    auditeur: string | null
    type: string | null
    score: number | null
    observations: string | null
    createdAt: Date | null
  }

  export type AuditQualiteMaxAggregateOutputType = {
    id: string | null
    dateAudit: Date | null
    service: string | null
    auditeur: string | null
    type: string | null
    score: number | null
    observations: string | null
    createdAt: Date | null
  }

  export type AuditQualiteCountAggregateOutputType = {
    id: number
    dateAudit: number
    service: number
    auditeur: number
    type: number
    score: number
    observations: number
    createdAt: number
    _all: number
  }


  export type AuditQualiteAvgAggregateInputType = {
    score?: true
  }

  export type AuditQualiteSumAggregateInputType = {
    score?: true
  }

  export type AuditQualiteMinAggregateInputType = {
    id?: true
    dateAudit?: true
    service?: true
    auditeur?: true
    type?: true
    score?: true
    observations?: true
    createdAt?: true
  }

  export type AuditQualiteMaxAggregateInputType = {
    id?: true
    dateAudit?: true
    service?: true
    auditeur?: true
    type?: true
    score?: true
    observations?: true
    createdAt?: true
  }

  export type AuditQualiteCountAggregateInputType = {
    id?: true
    dateAudit?: true
    service?: true
    auditeur?: true
    type?: true
    score?: true
    observations?: true
    createdAt?: true
    _all?: true
  }

  export type AuditQualiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditQualite to aggregate.
     */
    where?: AuditQualiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditQualites to fetch.
     */
    orderBy?: AuditQualiteOrderByWithRelationInput | AuditQualiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditQualiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditQualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditQualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditQualites
    **/
    _count?: true | AuditQualiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditQualiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditQualiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditQualiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditQualiteMaxAggregateInputType
  }

  export type GetAuditQualiteAggregateType<T extends AuditQualiteAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditQualite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditQualite[P]>
      : GetScalarType<T[P], AggregateAuditQualite[P]>
  }




  export type AuditQualiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditQualiteWhereInput
    orderBy?: AuditQualiteOrderByWithAggregationInput | AuditQualiteOrderByWithAggregationInput[]
    by: AuditQualiteScalarFieldEnum[] | AuditQualiteScalarFieldEnum
    having?: AuditQualiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditQualiteCountAggregateInputType | true
    _avg?: AuditQualiteAvgAggregateInputType
    _sum?: AuditQualiteSumAggregateInputType
    _min?: AuditQualiteMinAggregateInputType
    _max?: AuditQualiteMaxAggregateInputType
  }

  export type AuditQualiteGroupByOutputType = {
    id: string
    dateAudit: Date
    service: string
    auditeur: string
    type: string
    score: number
    observations: string | null
    createdAt: Date
    _count: AuditQualiteCountAggregateOutputType | null
    _avg: AuditQualiteAvgAggregateOutputType | null
    _sum: AuditQualiteSumAggregateOutputType | null
    _min: AuditQualiteMinAggregateOutputType | null
    _max: AuditQualiteMaxAggregateOutputType | null
  }

  type GetAuditQualiteGroupByPayload<T extends AuditQualiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditQualiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditQualiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditQualiteGroupByOutputType[P]>
            : GetScalarType<T[P], AuditQualiteGroupByOutputType[P]>
        }
      >
    >


  export type AuditQualiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateAudit?: boolean
    service?: boolean
    auditeur?: boolean
    type?: boolean
    score?: boolean
    observations?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditQualite"]>

  export type AuditQualiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateAudit?: boolean
    service?: boolean
    auditeur?: boolean
    type?: boolean
    score?: boolean
    observations?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditQualite"]>

  export type AuditQualiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateAudit?: boolean
    service?: boolean
    auditeur?: boolean
    type?: boolean
    score?: boolean
    observations?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditQualite"]>

  export type AuditQualiteSelectScalar = {
    id?: boolean
    dateAudit?: boolean
    service?: boolean
    auditeur?: boolean
    type?: boolean
    score?: boolean
    observations?: boolean
    createdAt?: boolean
  }

  export type AuditQualiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateAudit" | "service" | "auditeur" | "type" | "score" | "observations" | "createdAt", ExtArgs["result"]["auditQualite"]>

  export type $AuditQualitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditQualite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateAudit: Date
      service: string
      auditeur: string
      type: string
      score: number
      observations: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditQualite"]>
    composites: {}
  }

  type AuditQualiteGetPayload<S extends boolean | null | undefined | AuditQualiteDefaultArgs> = $Result.GetResult<Prisma.$AuditQualitePayload, S>

  type AuditQualiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditQualiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditQualiteCountAggregateInputType | true
    }

  export interface AuditQualiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditQualite'], meta: { name: 'AuditQualite' } }
    /**
     * Find zero or one AuditQualite that matches the filter.
     * @param {AuditQualiteFindUniqueArgs} args - Arguments to find a AuditQualite
     * @example
     * // Get one AuditQualite
     * const auditQualite = await prisma.auditQualite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditQualiteFindUniqueArgs>(args: SelectSubset<T, AuditQualiteFindUniqueArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AuditQualite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditQualiteFindUniqueOrThrowArgs} args - Arguments to find a AuditQualite
     * @example
     * // Get one AuditQualite
     * const auditQualite = await prisma.auditQualite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditQualiteFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditQualiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AuditQualite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteFindFirstArgs} args - Arguments to find a AuditQualite
     * @example
     * // Get one AuditQualite
     * const auditQualite = await prisma.auditQualite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditQualiteFindFirstArgs>(args?: SelectSubset<T, AuditQualiteFindFirstArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AuditQualite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteFindFirstOrThrowArgs} args - Arguments to find a AuditQualite
     * @example
     * // Get one AuditQualite
     * const auditQualite = await prisma.auditQualite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditQualiteFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditQualiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AuditQualites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditQualites
     * const auditQualites = await prisma.auditQualite.findMany()
     * 
     * // Get first 10 AuditQualites
     * const auditQualites = await prisma.auditQualite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditQualiteWithIdOnly = await prisma.auditQualite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditQualiteFindManyArgs>(args?: SelectSubset<T, AuditQualiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AuditQualite.
     * @param {AuditQualiteCreateArgs} args - Arguments to create a AuditQualite.
     * @example
     * // Create one AuditQualite
     * const AuditQualite = await prisma.auditQualite.create({
     *   data: {
     *     // ... data to create a AuditQualite
     *   }
     * })
     * 
     */
    create<T extends AuditQualiteCreateArgs>(args: SelectSubset<T, AuditQualiteCreateArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AuditQualites.
     * @param {AuditQualiteCreateManyArgs} args - Arguments to create many AuditQualites.
     * @example
     * // Create many AuditQualites
     * const auditQualite = await prisma.auditQualite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditQualiteCreateManyArgs>(args?: SelectSubset<T, AuditQualiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditQualites and returns the data saved in the database.
     * @param {AuditQualiteCreateManyAndReturnArgs} args - Arguments to create many AuditQualites.
     * @example
     * // Create many AuditQualites
     * const auditQualite = await prisma.auditQualite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditQualites and only return the `id`
     * const auditQualiteWithIdOnly = await prisma.auditQualite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditQualiteCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditQualiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AuditQualite.
     * @param {AuditQualiteDeleteArgs} args - Arguments to delete one AuditQualite.
     * @example
     * // Delete one AuditQualite
     * const AuditQualite = await prisma.auditQualite.delete({
     *   where: {
     *     // ... filter to delete one AuditQualite
     *   }
     * })
     * 
     */
    delete<T extends AuditQualiteDeleteArgs>(args: SelectSubset<T, AuditQualiteDeleteArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AuditQualite.
     * @param {AuditQualiteUpdateArgs} args - Arguments to update one AuditQualite.
     * @example
     * // Update one AuditQualite
     * const auditQualite = await prisma.auditQualite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditQualiteUpdateArgs>(args: SelectSubset<T, AuditQualiteUpdateArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AuditQualites.
     * @param {AuditQualiteDeleteManyArgs} args - Arguments to filter AuditQualites to delete.
     * @example
     * // Delete a few AuditQualites
     * const { count } = await prisma.auditQualite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditQualiteDeleteManyArgs>(args?: SelectSubset<T, AuditQualiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditQualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditQualites
     * const auditQualite = await prisma.auditQualite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditQualiteUpdateManyArgs>(args: SelectSubset<T, AuditQualiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditQualites and returns the data updated in the database.
     * @param {AuditQualiteUpdateManyAndReturnArgs} args - Arguments to update many AuditQualites.
     * @example
     * // Update many AuditQualites
     * const auditQualite = await prisma.auditQualite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditQualites and only return the `id`
     * const auditQualiteWithIdOnly = await prisma.auditQualite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditQualiteUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditQualiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AuditQualite.
     * @param {AuditQualiteUpsertArgs} args - Arguments to update or create a AuditQualite.
     * @example
     * // Update or create a AuditQualite
     * const auditQualite = await prisma.auditQualite.upsert({
     *   create: {
     *     // ... data to create a AuditQualite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditQualite we want to update
     *   }
     * })
     */
    upsert<T extends AuditQualiteUpsertArgs>(args: SelectSubset<T, AuditQualiteUpsertArgs<ExtArgs>>): Prisma__AuditQualiteClient<$Result.GetResult<Prisma.$AuditQualitePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AuditQualites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteCountArgs} args - Arguments to filter AuditQualites to count.
     * @example
     * // Count the number of AuditQualites
     * const count = await prisma.auditQualite.count({
     *   where: {
     *     // ... the filter for the AuditQualites we want to count
     *   }
     * })
    **/
    count<T extends AuditQualiteCountArgs>(
      args?: Subset<T, AuditQualiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditQualiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditQualite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditQualiteAggregateArgs>(args: Subset<T, AuditQualiteAggregateArgs>): Prisma.PrismaPromise<GetAuditQualiteAggregateType<T>>

    /**
     * Group by AuditQualite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditQualiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditQualiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditQualiteGroupByArgs['orderBy'] }
        : { orderBy?: AuditQualiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditQualiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditQualiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditQualite model
   */
  readonly fields: AuditQualiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditQualite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditQualiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditQualite model
   */ 
  interface AuditQualiteFieldRefs {
    readonly id: FieldRef<"AuditQualite", 'String'>
    readonly dateAudit: FieldRef<"AuditQualite", 'DateTime'>
    readonly service: FieldRef<"AuditQualite", 'String'>
    readonly auditeur: FieldRef<"AuditQualite", 'String'>
    readonly type: FieldRef<"AuditQualite", 'String'>
    readonly score: FieldRef<"AuditQualite", 'Int'>
    readonly observations: FieldRef<"AuditQualite", 'String'>
    readonly createdAt: FieldRef<"AuditQualite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditQualite findUnique
   */
  export type AuditQualiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter, which AuditQualite to fetch.
     */
    where: AuditQualiteWhereUniqueInput
  }

  /**
   * AuditQualite findUniqueOrThrow
   */
  export type AuditQualiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter, which AuditQualite to fetch.
     */
    where: AuditQualiteWhereUniqueInput
  }

  /**
   * AuditQualite findFirst
   */
  export type AuditQualiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter, which AuditQualite to fetch.
     */
    where?: AuditQualiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditQualites to fetch.
     */
    orderBy?: AuditQualiteOrderByWithRelationInput | AuditQualiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditQualites.
     */
    cursor?: AuditQualiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditQualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditQualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditQualites.
     */
    distinct?: AuditQualiteScalarFieldEnum | AuditQualiteScalarFieldEnum[]
  }

  /**
   * AuditQualite findFirstOrThrow
   */
  export type AuditQualiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter, which AuditQualite to fetch.
     */
    where?: AuditQualiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditQualites to fetch.
     */
    orderBy?: AuditQualiteOrderByWithRelationInput | AuditQualiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditQualites.
     */
    cursor?: AuditQualiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditQualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditQualites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditQualites.
     */
    distinct?: AuditQualiteScalarFieldEnum | AuditQualiteScalarFieldEnum[]
  }

  /**
   * AuditQualite findMany
   */
  export type AuditQualiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter, which AuditQualites to fetch.
     */
    where?: AuditQualiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditQualites to fetch.
     */
    orderBy?: AuditQualiteOrderByWithRelationInput | AuditQualiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditQualites.
     */
    cursor?: AuditQualiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditQualites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditQualites.
     */
    skip?: number
    distinct?: AuditQualiteScalarFieldEnum | AuditQualiteScalarFieldEnum[]
  }

  /**
   * AuditQualite create
   */
  export type AuditQualiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * The data needed to create a AuditQualite.
     */
    data: XOR<AuditQualiteCreateInput, AuditQualiteUncheckedCreateInput>
  }

  /**
   * AuditQualite createMany
   */
  export type AuditQualiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditQualites.
     */
    data: AuditQualiteCreateManyInput | AuditQualiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditQualite createManyAndReturn
   */
  export type AuditQualiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * The data used to create many AuditQualites.
     */
    data: AuditQualiteCreateManyInput | AuditQualiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditQualite update
   */
  export type AuditQualiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * The data needed to update a AuditQualite.
     */
    data: XOR<AuditQualiteUpdateInput, AuditQualiteUncheckedUpdateInput>
    /**
     * Choose, which AuditQualite to update.
     */
    where: AuditQualiteWhereUniqueInput
  }

  /**
   * AuditQualite updateMany
   */
  export type AuditQualiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditQualites.
     */
    data: XOR<AuditQualiteUpdateManyMutationInput, AuditQualiteUncheckedUpdateManyInput>
    /**
     * Filter which AuditQualites to update
     */
    where?: AuditQualiteWhereInput
  }

  /**
   * AuditQualite updateManyAndReturn
   */
  export type AuditQualiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * The data used to update AuditQualites.
     */
    data: XOR<AuditQualiteUpdateManyMutationInput, AuditQualiteUncheckedUpdateManyInput>
    /**
     * Filter which AuditQualites to update
     */
    where?: AuditQualiteWhereInput
  }

  /**
   * AuditQualite upsert
   */
  export type AuditQualiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * The filter to search for the AuditQualite to update in case it exists.
     */
    where: AuditQualiteWhereUniqueInput
    /**
     * In case the AuditQualite found by the `where` argument doesn't exist, create a new AuditQualite with this data.
     */
    create: XOR<AuditQualiteCreateInput, AuditQualiteUncheckedCreateInput>
    /**
     * In case the AuditQualite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditQualiteUpdateInput, AuditQualiteUncheckedUpdateInput>
  }

  /**
   * AuditQualite delete
   */
  export type AuditQualiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
    /**
     * Filter which AuditQualite to delete.
     */
    where: AuditQualiteWhereUniqueInput
  }

  /**
   * AuditQualite deleteMany
   */
  export type AuditQualiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditQualites to delete
     */
    where?: AuditQualiteWhereInput
  }

  /**
   * AuditQualite without action
   */
  export type AuditQualiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditQualite
     */
    select?: AuditQualiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditQualite
     */
    omit?: AuditQualiteOmit<ExtArgs> | null
  }


  /**
   * Model Configuration
   */

  export type AggregateConfiguration = {
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  export type ConfigurationMinAggregateOutputType = {
    id: string | null
    cle: string | null
    valeur: string | null
    type: string | null
    module: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigurationMaxAggregateOutputType = {
    id: string | null
    cle: string | null
    valeur: string | null
    type: string | null
    module: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfigurationCountAggregateOutputType = {
    id: number
    cle: number
    valeur: number
    type: number
    module: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfigurationMinAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    type?: true
    module?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigurationMaxAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    type?: true
    module?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfigurationCountAggregateInputType = {
    id?: true
    cle?: true
    valeur?: true
    type?: true
    module?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuration to aggregate.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configurations
    **/
    _count?: true | ConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigurationMaxAggregateInputType
  }

  export type GetConfigurationAggregateType<T extends ConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguration[P]>
      : GetScalarType<T[P], AggregateConfiguration[P]>
  }




  export type ConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigurationWhereInput
    orderBy?: ConfigurationOrderByWithAggregationInput | ConfigurationOrderByWithAggregationInput[]
    by: ConfigurationScalarFieldEnum[] | ConfigurationScalarFieldEnum
    having?: ConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigurationCountAggregateInputType | true
    _min?: ConfigurationMinAggregateInputType
    _max?: ConfigurationMaxAggregateInputType
  }

  export type ConfigurationGroupByOutputType = {
    id: string
    cle: string
    valeur: string
    type: string
    module: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfigurationCountAggregateOutputType | null
    _min: ConfigurationMinAggregateOutputType | null
    _max: ConfigurationMaxAggregateOutputType | null
  }

  type GetConfigurationGroupByPayload<T extends ConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type ConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cle?: boolean
    valeur?: boolean
    type?: boolean
    module?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cle?: boolean
    valeur?: boolean
    type?: boolean
    module?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cle?: boolean
    valeur?: boolean
    type?: boolean
    module?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["configuration"]>

  export type ConfigurationSelectScalar = {
    id?: boolean
    cle?: boolean
    valeur?: boolean
    type?: boolean
    module?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cle" | "valeur" | "type" | "module" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["configuration"]>

  export type $ConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cle: string
      valeur: string
      type: string
      module: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["configuration"]>
    composites: {}
  }

  type ConfigurationGetPayload<S extends boolean | null | undefined | ConfigurationDefaultArgs> = $Result.GetResult<Prisma.$ConfigurationPayload, S>

  type ConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigurationCountAggregateInputType | true
    }

  export interface ConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuration'], meta: { name: 'Configuration' } }
    /**
     * Find zero or one Configuration that matches the filter.
     * @param {ConfigurationFindUniqueArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigurationFindUniqueArgs>(args: SelectSubset<T, ConfigurationFindUniqueArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Configuration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigurationFindUniqueOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Configuration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigurationFindFirstArgs>(args?: SelectSubset<T, ConfigurationFindFirstArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Configuration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindFirstOrThrowArgs} args - Arguments to find a Configuration
     * @example
     * // Get one Configuration
     * const configuration = await prisma.configuration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Configurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configurations
     * const configurations = await prisma.configuration.findMany()
     * 
     * // Get first 10 Configurations
     * const configurations = await prisma.configuration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configurationWithIdOnly = await prisma.configuration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigurationFindManyArgs>(args?: SelectSubset<T, ConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Configuration.
     * @param {ConfigurationCreateArgs} args - Arguments to create a Configuration.
     * @example
     * // Create one Configuration
     * const Configuration = await prisma.configuration.create({
     *   data: {
     *     // ... data to create a Configuration
     *   }
     * })
     * 
     */
    create<T extends ConfigurationCreateArgs>(args: SelectSubset<T, ConfigurationCreateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Configurations.
     * @param {ConfigurationCreateManyArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigurationCreateManyArgs>(args?: SelectSubset<T, ConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configurations and returns the data saved in the database.
     * @param {ConfigurationCreateManyAndReturnArgs} args - Arguments to create many Configurations.
     * @example
     * // Create many Configurations
     * const configuration = await prisma.configuration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configurations and only return the `id`
     * const configurationWithIdOnly = await prisma.configuration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigurationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigurationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Configuration.
     * @param {ConfigurationDeleteArgs} args - Arguments to delete one Configuration.
     * @example
     * // Delete one Configuration
     * const Configuration = await prisma.configuration.delete({
     *   where: {
     *     // ... filter to delete one Configuration
     *   }
     * })
     * 
     */
    delete<T extends ConfigurationDeleteArgs>(args: SelectSubset<T, ConfigurationDeleteArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Configuration.
     * @param {ConfigurationUpdateArgs} args - Arguments to update one Configuration.
     * @example
     * // Update one Configuration
     * const configuration = await prisma.configuration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigurationUpdateArgs>(args: SelectSubset<T, ConfigurationUpdateArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Configurations.
     * @param {ConfigurationDeleteManyArgs} args - Arguments to filter Configurations to delete.
     * @example
     * // Delete a few Configurations
     * const { count } = await prisma.configuration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigurationDeleteManyArgs>(args?: SelectSubset<T, ConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigurationUpdateManyArgs>(args: SelectSubset<T, ConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configurations and returns the data updated in the database.
     * @param {ConfigurationUpdateManyAndReturnArgs} args - Arguments to update many Configurations.
     * @example
     * // Update many Configurations
     * const configuration = await prisma.configuration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Configurations and only return the `id`
     * const configurationWithIdOnly = await prisma.configuration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigurationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigurationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Configuration.
     * @param {ConfigurationUpsertArgs} args - Arguments to update or create a Configuration.
     * @example
     * // Update or create a Configuration
     * const configuration = await prisma.configuration.upsert({
     *   create: {
     *     // ... data to create a Configuration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuration we want to update
     *   }
     * })
     */
    upsert<T extends ConfigurationUpsertArgs>(args: SelectSubset<T, ConfigurationUpsertArgs<ExtArgs>>): Prisma__ConfigurationClient<$Result.GetResult<Prisma.$ConfigurationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Configurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationCountArgs} args - Arguments to filter Configurations to count.
     * @example
     * // Count the number of Configurations
     * const count = await prisma.configuration.count({
     *   where: {
     *     // ... the filter for the Configurations we want to count
     *   }
     * })
    **/
    count<T extends ConfigurationCountArgs>(
      args?: Subset<T, ConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigurationAggregateArgs>(args: Subset<T, ConfigurationAggregateArgs>): Prisma.PrismaPromise<GetConfigurationAggregateType<T>>

    /**
     * Group by Configuration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: ConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuration model
   */
  readonly fields: ConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuration model
   */ 
  interface ConfigurationFieldRefs {
    readonly id: FieldRef<"Configuration", 'String'>
    readonly cle: FieldRef<"Configuration", 'String'>
    readonly valeur: FieldRef<"Configuration", 'String'>
    readonly type: FieldRef<"Configuration", 'String'>
    readonly module: FieldRef<"Configuration", 'String'>
    readonly description: FieldRef<"Configuration", 'String'>
    readonly createdAt: FieldRef<"Configuration", 'DateTime'>
    readonly updatedAt: FieldRef<"Configuration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Configuration findUnique
   */
  export type ConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findUniqueOrThrow
   */
  export type ConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration findFirst
   */
  export type ConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findFirstOrThrow
   */
  export type ConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which Configuration to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configurations.
     */
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration findMany
   */
  export type ConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which Configurations to fetch.
     */
    where?: ConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configurations to fetch.
     */
    orderBy?: ConfigurationOrderByWithRelationInput | ConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configurations.
     */
    cursor?: ConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configurations.
     */
    skip?: number
    distinct?: ConfigurationScalarFieldEnum | ConfigurationScalarFieldEnum[]
  }

  /**
   * Configuration create
   */
  export type ConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a Configuration.
     */
    data: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
  }

  /**
   * Configuration createMany
   */
  export type ConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration createManyAndReturn
   */
  export type ConfigurationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * The data used to create many Configurations.
     */
    data: ConfigurationCreateManyInput | ConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuration update
   */
  export type ConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a Configuration.
     */
    data: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
    /**
     * Choose, which Configuration to update.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration updateMany
   */
  export type ConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration updateManyAndReturn
   */
  export type ConfigurationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * The data used to update Configurations.
     */
    data: XOR<ConfigurationUpdateManyMutationInput, ConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which Configurations to update
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration upsert
   */
  export type ConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the Configuration to update in case it exists.
     */
    where: ConfigurationWhereUniqueInput
    /**
     * In case the Configuration found by the `where` argument doesn't exist, create a new Configuration with this data.
     */
    create: XOR<ConfigurationCreateInput, ConfigurationUncheckedCreateInput>
    /**
     * In case the Configuration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigurationUpdateInput, ConfigurationUncheckedUpdateInput>
  }

  /**
   * Configuration delete
   */
  export type ConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
    /**
     * Filter which Configuration to delete.
     */
    where: ConfigurationWhereUniqueInput
  }

  /**
   * Configuration deleteMany
   */
  export type ConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configurations to delete
     */
    where?: ConfigurationWhereInput
  }

  /**
   * Configuration without action
   */
  export type ConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuration
     */
    select?: ConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Configuration
     */
    omit?: ConfigurationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    nom: 'nom',
    prenom: 'prenom',
    telephone: 'telephone',
    photo: 'photo',
    actif: 'actif',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    module: 'module',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    module: 'module',
    entityType: 'entityType',
    entityId: 'entityId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const CompteComptableScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    libelle: 'libelle',
    classe: 'classe',
    type: 'type',
    sens: 'sens',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompteComptableScalarFieldEnum = (typeof CompteComptableScalarFieldEnum)[keyof typeof CompteComptableScalarFieldEnum]


  export const JournalScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    type: 'type',
    actif: 'actif',
    createdAt: 'createdAt'
  };

  export type JournalScalarFieldEnum = (typeof JournalScalarFieldEnum)[keyof typeof JournalScalarFieldEnum]


  export const ExerciceComptableScalarFieldEnum: {
    id: 'id',
    annee: 'annee',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    cloture: 'cloture',
    createdAt: 'createdAt'
  };

  export type ExerciceComptableScalarFieldEnum = (typeof ExerciceComptableScalarFieldEnum)[keyof typeof ExerciceComptableScalarFieldEnum]


  export const EcritureComptableScalarFieldEnum: {
    id: 'id',
    journalId: 'journalId',
    compteId: 'compteId',
    exerciceId: 'exerciceId',
    dateEcriture: 'dateEcriture',
    libelle: 'libelle',
    debit: 'debit',
    credit: 'credit',
    pieceRef: 'pieceRef',
    centreAnalytiqueId: 'centreAnalytiqueId',
    valide: 'valide',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EcritureComptableScalarFieldEnum = (typeof EcritureComptableScalarFieldEnum)[keyof typeof EcritureComptableScalarFieldEnum]


  export const CentreAnalytiqueScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    type: 'type',
    actif: 'actif',
    createdAt: 'createdAt'
  };

  export type CentreAnalytiqueScalarFieldEnum = (typeof CentreAnalytiqueScalarFieldEnum)[keyof typeof CentreAnalytiqueScalarFieldEnum]


  export const BudgetScalarFieldEnum: {
    id: 'id',
    exerciceId: 'exerciceId',
    compte: 'compte',
    libelle: 'libelle',
    montant: 'montant',
    type: 'type',
    mois: 'mois',
    createdAt: 'createdAt'
  };

  export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    numeroPatient: 'numeroPatient',
    nom: 'nom',
    prenom: 'prenom',
    dateNaissance: 'dateNaissance',
    sexe: 'sexe',
    telephone: 'telephone',
    email: 'email',
    adresse: 'adresse',
    ville: 'ville',
    profession: 'profession',
    situationMatrimoniale: 'situationMatrimoniale',
    assureur: 'assureur',
    numeroAssure: 'numeroAssure',
    tauxCouverture: 'tauxCouverture',
    contactUrgenceNom: 'contactUrgenceNom',
    contactUrgenceTel: 'contactUrgenceTel',
    contactUrgenceLien: 'contactUrgenceLien',
    photo: 'photo',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AntecedentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    type: 'type',
    description: 'description',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type AntecedentScalarFieldEnum = (typeof AntecedentScalarFieldEnum)[keyof typeof AntecedentScalarFieldEnum]


  export const AllergieScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    type: 'type',
    allergene: 'allergene',
    severite: 'severite',
    reaction: 'reaction',
    createdAt: 'createdAt'
  };

  export type AllergieScalarFieldEnum = (typeof AllergieScalarFieldEnum)[keyof typeof AllergieScalarFieldEnum]


  export const VaccinationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    vaccin: 'vaccin',
    dateVaccin: 'dateVaccin',
    rappel: 'rappel',
    lot: 'lot',
    createdAt: 'createdAt'
  };

  export type VaccinationScalarFieldEnum = (typeof VaccinationScalarFieldEnum)[keyof typeof VaccinationScalarFieldEnum]


  export const RendezVousScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    medecinId: 'medecinId',
    dateHeure: 'dateHeure',
    duree: 'duree',
    motif: 'motif',
    statut: 'statut',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RendezVousScalarFieldEnum = (typeof RendezVousScalarFieldEnum)[keyof typeof RendezVousScalarFieldEnum]


  export const ConsultationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    medecinId: 'medecinId',
    dateConsultation: 'dateConsultation',
    motifConsultation: 'motifConsultation',
    anamnese: 'anamnese',
    examenClinique: 'examenClinique',
    diagnostic: 'diagnostic',
    planTraitement: 'planTraitement',
    poids: 'poids',
    taille: 'taille',
    temperature: 'temperature',
    tensionSystolique: 'tensionSystolique',
    tensionDiastolique: 'tensionDiastolique',
    frequenceCardiaque: 'frequenceCardiaque',
    saturationOxygene: 'saturationOxygene',
    donneesSpecialite: 'donneesSpecialite',
    factureId: 'factureId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConsultationScalarFieldEnum = (typeof ConsultationScalarFieldEnum)[keyof typeof ConsultationScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    medicament: 'medicament',
    dosage: 'dosage',
    forme: 'forme',
    posologie: 'posologie',
    duree: 'duree',
    quantite: 'quantite',
    instructions: 'instructions',
    createdAt: 'createdAt'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const NomenclatureActeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    libelle: 'libelle',
    specialite: 'specialite',
    tarif: 'tarif',
    duree: 'duree',
    actif: 'actif',
    createdAt: 'createdAt'
  };

  export type NomenclatureActeScalarFieldEnum = (typeof NomenclatureActeScalarFieldEnum)[keyof typeof NomenclatureActeScalarFieldEnum]


  export const ActeRealiseScalarFieldEnum: {
    id: 'id',
    consultationId: 'consultationId',
    acteId: 'acteId',
    quantite: 'quantite',
    tarif: 'tarif',
    montant: 'montant',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ActeRealiseScalarFieldEnum = (typeof ActeRealiseScalarFieldEnum)[keyof typeof ActeRealiseScalarFieldEnum]


  export const ResultatExamenScalarFieldEnum: {
    id: 'id',
    acteRealiseId: 'acteRealiseId',
    valeurs: 'valeurs',
    conclusion: 'conclusion',
    compteRendu: 'compteRendu',
    images: 'images',
    dateExamen: 'dateExamen',
    validePar: 'validePar',
    dateValidation: 'dateValidation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultatExamenScalarFieldEnum = (typeof ResultatExamenScalarFieldEnum)[keyof typeof ResultatExamenScalarFieldEnum]


  export const MedicamentScalarFieldEnum: {
    id: 'id',
    codeANIS: 'codeANIS',
    dci: 'dci',
    nomCommercial: 'nomCommercial',
    forme: 'forme',
    dosage: 'dosage',
    fabricant: 'fabricant',
    prixAchat: 'prixAchat',
    prixVente: 'prixVente',
    stockMinimum: 'stockMinimum',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicamentScalarFieldEnum = (typeof MedicamentScalarFieldEnum)[keyof typeof MedicamentScalarFieldEnum]


  export const FournisseurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    contact: 'contact',
    email: 'email',
    telephone: 'telephone',
    adresse: 'adresse',
    ninea: 'ninea',
    rccm: 'rccm',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FournisseurScalarFieldEnum = (typeof FournisseurScalarFieldEnum)[keyof typeof FournisseurScalarFieldEnum]


  export const CommandePharmacieScalarFieldEnum: {
    id: 'id',
    numeroCommande: 'numeroCommande',
    fournisseurId: 'fournisseurId',
    dateCommande: 'dateCommande',
    dateLivraison: 'dateLivraison',
    montantTotal: 'montantTotal',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandePharmacieScalarFieldEnum = (typeof CommandePharmacieScalarFieldEnum)[keyof typeof CommandePharmacieScalarFieldEnum]


  export const LigneCommandePharmacieScalarFieldEnum: {
    id: 'id',
    commandeId: 'commandeId',
    medicamentId: 'medicamentId',
    quantiteCommandee: 'quantiteCommandee',
    quantiteRecue: 'quantiteRecue',
    prixUnitaire: 'prixUnitaire',
    createdAt: 'createdAt'
  };

  export type LigneCommandePharmacieScalarFieldEnum = (typeof LigneCommandePharmacieScalarFieldEnum)[keyof typeof LigneCommandePharmacieScalarFieldEnum]


  export const StockScalarFieldEnum: {
    id: 'id',
    medicamentId: 'medicamentId',
    lot: 'lot',
    datePeremption: 'datePeremption',
    quantite: 'quantite',
    emplacement: 'emplacement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockScalarFieldEnum = (typeof StockScalarFieldEnum)[keyof typeof StockScalarFieldEnum]


  export const MouvementStockScalarFieldEnum: {
    id: 'id',
    medicamentId: 'medicamentId',
    type: 'type',
    quantite: 'quantite',
    motif: 'motif',
    reference: 'reference',
    utilisateur: 'utilisateur',
    createdAt: 'createdAt'
  };

  export type MouvementStockScalarFieldEnum = (typeof MouvementStockScalarFieldEnum)[keyof typeof MouvementStockScalarFieldEnum]


  export const DispensationScalarFieldEnum: {
    id: 'id',
    medicamentId: 'medicamentId',
    patientId: 'patientId',
    quantite: 'quantite',
    prescription: 'prescription',
    pharmacien: 'pharmacien',
    createdAt: 'createdAt'
  };

  export type DispensationScalarFieldEnum = (typeof DispensationScalarFieldEnum)[keyof typeof DispensationScalarFieldEnum]


  export const FactureScalarFieldEnum: {
    id: 'id',
    numeroFacture: 'numeroFacture',
    patientId: 'patientId',
    dateFacture: 'dateFacture',
    dateEcheance: 'dateEcheance',
    montantHT: 'montantHT',
    montantTVA: 'montantTVA',
    montantTTC: 'montantTTC',
    partAssurance: 'partAssurance',
    partPatient: 'partPatient',
    statut: 'statut',
    ecritureComptableId: 'ecritureComptableId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FactureScalarFieldEnum = (typeof FactureScalarFieldEnum)[keyof typeof FactureScalarFieldEnum]


  export const LigneFactureScalarFieldEnum: {
    id: 'id',
    factureId: 'factureId',
    designation: 'designation',
    quantite: 'quantite',
    prixUnitaire: 'prixUnitaire',
    montant: 'montant',
    createdAt: 'createdAt'
  };

  export type LigneFactureScalarFieldEnum = (typeof LigneFactureScalarFieldEnum)[keyof typeof LigneFactureScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    factureId: 'factureId',
    datePaiement: 'datePaiement',
    montant: 'montant',
    modePaiement: 'modePaiement',
    reference: 'reference',
    notes: 'notes',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const LitScalarFieldEnum: {
    id: 'id',
    numero: 'numero',
    chambre: 'chambre',
    service: 'service',
    categorie: 'categorie',
    prixJournalier: 'prixJournalier',
    occupe: 'occupe',
    createdAt: 'createdAt'
  };

  export type LitScalarFieldEnum = (typeof LitScalarFieldEnum)[keyof typeof LitScalarFieldEnum]


  export const HospitalisationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    litId: 'litId',
    dateEntree: 'dateEntree',
    dateSortie: 'dateSortie',
    motif: 'motif',
    diagnosticEntree: 'diagnosticEntree',
    diagnosticSortie: 'diagnosticSortie',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HospitalisationScalarFieldEnum = (typeof HospitalisationScalarFieldEnum)[keyof typeof HospitalisationScalarFieldEnum]


  export const ObservationInfirmierScalarFieldEnum: {
    id: 'id',
    hospitalisationId: 'hospitalisationId',
    infirmierId: 'infirmierId',
    pressionArterielle: 'pressionArterielle',
    temperature: 'temperature',
    note: 'note',
    dateHeure: 'dateHeure'
  };

  export type ObservationInfirmierScalarFieldEnum = (typeof ObservationInfirmierScalarFieldEnum)[keyof typeof ObservationInfirmierScalarFieldEnum]


  export const InterventionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    chirurgienId: 'chirurgienId',
    anesthesisteId: 'anesthesisteId',
    typeIntervention: 'typeIntervention',
    dateHeure: 'dateHeure',
    salle: 'salle',
    statut: 'statut',
    protocoleOp: 'protocoleOp',
    typeAnesthesie: 'typeAnesthesie',
    duree: 'duree',
    createdAt: 'createdAt'
  };

  export type InterventionScalarFieldEnum = (typeof InterventionScalarFieldEnum)[keyof typeof InterventionScalarFieldEnum]


  export const DossierMaterniteScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    dateDebutGrossesse: 'dateDebutGrossesse',
    parite: 'parite',
    gestite: 'gestite',
    groupageRhesus: 'groupageRhesus',
    examensPrenataux: 'examensPrenataux',
    accouchement: 'accouchement',
    createdAt: 'createdAt'
  };

  export type DossierMaterniteScalarFieldEnum = (typeof DossierMaterniteScalarFieldEnum)[keyof typeof DossierMaterniteScalarFieldEnum]


  export const NouveauNeScalarFieldEnum: {
    id: 'id',
    dossierMaterniteId: 'dossierMaterniteId',
    nom: 'nom',
    prenom: 'prenom',
    dateHeureNaissance: 'dateHeureNaissance',
    sexe: 'sexe',
    poids: 'poids',
    scoreApgar: 'scoreApgar',
    createdAt: 'createdAt'
  };

  export type NouveauNeScalarFieldEnum = (typeof NouveauNeScalarFieldEnum)[keyof typeof NouveauNeScalarFieldEnum]


  export const ArticleLogistiqueScalarFieldEnum: {
    id: 'id',
    designation: 'designation',
    categorie: 'categorie',
    famille: 'famille',
    uniteMesure: 'uniteMesure',
    stockAlerte: 'stockAlerte',
    stockActuel: 'stockActuel',
    createdAt: 'createdAt'
  };

  export type ArticleLogistiqueScalarFieldEnum = (typeof ArticleLogistiqueScalarFieldEnum)[keyof typeof ArticleLogistiqueScalarFieldEnum]


  export const MouvementLogistiqueScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    type: 'type',
    quantite: 'quantite',
    serviceDestinataire: 'serviceDestinataire',
    motif: 'motif',
    utilisateur: 'utilisateur',
    createdAt: 'createdAt'
  };

  export type MouvementLogistiqueScalarFieldEnum = (typeof MouvementLogistiqueScalarFieldEnum)[keyof typeof MouvementLogistiqueScalarFieldEnum]


  export const DocumentGEDScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    titre: 'titre',
    type: 'type',
    url: 'url',
    module: 'module',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type DocumentGEDScalarFieldEnum = (typeof DocumentGEDScalarFieldEnum)[keyof typeof DocumentGEDScalarFieldEnum]


  export const EmployeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    matricule: 'matricule',
    nom: 'nom',
    prenom: 'prenom',
    dateNaissance: 'dateNaissance',
    sexe: 'sexe',
    telephone: 'telephone',
    email: 'email',
    adresse: 'adresse',
    categorie: 'categorie',
    fonction: 'fonction',
    specialite: 'specialite',
    dateEmbauche: 'dateEmbauche',
    typeContrat: 'typeContrat',
    salaireBrut: 'salaireBrut',
    actif: 'actif',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeScalarFieldEnum = (typeof EmployeScalarFieldEnum)[keyof typeof EmployeScalarFieldEnum]


  export const CongeScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    type: 'type',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    nbJours: 'nbJours',
    motif: 'motif',
    statut: 'statut',
    createdAt: 'createdAt'
  };

  export type CongeScalarFieldEnum = (typeof CongeScalarFieldEnum)[keyof typeof CongeScalarFieldEnum]


  export const BulletinPaieScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    periode: 'periode',
    dateEmission: 'dateEmission',
    salaireBase: 'salaireBase',
    totalPrimes: 'totalPrimes',
    totalRetenues: 'totalRetenues',
    salaireNet: 'salaireNet',
    statut: 'statut'
  };

  export type BulletinPaieScalarFieldEnum = (typeof BulletinPaieScalarFieldEnum)[keyof typeof BulletinPaieScalarFieldEnum]


  export const LigneBulletinScalarFieldEnum: {
    id: 'id',
    bulletinId: 'bulletinId',
    libelle: 'libelle',
    type: 'type',
    base: 'base',
    taux: 'taux',
    montant: 'montant'
  };

  export type LigneBulletinScalarFieldEnum = (typeof LigneBulletinScalarFieldEnum)[keyof typeof LigneBulletinScalarFieldEnum]


  export const PlanningScalarFieldEnum: {
    id: 'id',
    employeId: 'employeId',
    date: 'date',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PlanningScalarFieldEnum = (typeof PlanningScalarFieldEnum)[keyof typeof PlanningScalarFieldEnum]


  export const EquipementScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nom: 'nom',
    type: 'type',
    marque: 'marque',
    modele: 'modele',
    serie: 'serie',
    dateAchat: 'dateAchat',
    dateDerniereMaintenace: 'dateDerniereMaintenace',
    dateProchaineMaintenance: 'dateProchaineMaintenance',
    statut: 'statut',
    localisation: 'localisation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipementScalarFieldEnum = (typeof EquipementScalarFieldEnum)[keyof typeof EquipementScalarFieldEnum]


  export const TicketMaintenanceScalarFieldEnum: {
    id: 'id',
    equipementId: 'equipementId',
    type: 'type',
    priorite: 'priorite',
    objet: 'objet',
    description: 'description',
    statut: 'statut',
    intervenant: 'intervenant',
    dateResolution: 'dateResolution',
    coutEstime: 'coutEstime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketMaintenanceScalarFieldEnum = (typeof TicketMaintenanceScalarFieldEnum)[keyof typeof TicketMaintenanceScalarFieldEnum]


  export const EvenementIndesirableScalarFieldEnum: {
    id: 'id',
    dateEvenement: 'dateEvenement',
    service: 'service',
    type: 'type',
    gravite: 'gravite',
    description: 'description',
    mesuresPrises: 'mesuresPrises',
    statut: 'statut',
    declaréPar: 'declaréPar',
    patientId: 'patientId',
    createdAt: 'createdAt'
  };

  export type EvenementIndesirableScalarFieldEnum = (typeof EvenementIndesirableScalarFieldEnum)[keyof typeof EvenementIndesirableScalarFieldEnum]


  export const AuditQualiteScalarFieldEnum: {
    id: 'id',
    dateAudit: 'dateAudit',
    service: 'service',
    auditeur: 'auditeur',
    type: 'type',
    score: 'score',
    observations: 'observations',
    createdAt: 'createdAt'
  };

  export type AuditQualiteScalarFieldEnum = (typeof AuditQualiteScalarFieldEnum)[keyof typeof AuditQualiteScalarFieldEnum]


  export const ConfigurationScalarFieldEnum: {
    id: 'id',
    cle: 'cle',
    valeur: 'valeur',
    type: 'type',
    module: 'module',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfigurationScalarFieldEnum = (typeof ConfigurationScalarFieldEnum)[keyof typeof ConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    nom?: StringFilter<"User"> | string
    prenom?: StringFilter<"User"> | string
    telephone?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    actif?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    consultations?: ConsultationListRelationFilter
    rendezvous?: RendezVousListRelationFilter
    ecritures?: EcritureComptableListRelationFilter
    paiements?: PaiementListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    observationsCrees?: ObservationInfirmierListRelationFilter
    chirurgies?: InterventionListRelationFilter
    anesthesies?: InterventionListRelationFilter
    employe?: XOR<EmployeNullableScalarRelationFilter, EmployeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    telephone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    actif?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    consultations?: ConsultationOrderByRelationAggregateInput
    rendezvous?: RendezVousOrderByRelationAggregateInput
    ecritures?: EcritureComptableOrderByRelationAggregateInput
    paiements?: PaiementOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    observationsCrees?: ObservationInfirmierOrderByRelationAggregateInput
    chirurgies?: InterventionOrderByRelationAggregateInput
    anesthesies?: InterventionOrderByRelationAggregateInput
    employe?: EmployeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    nom?: StringFilter<"User"> | string
    prenom?: StringFilter<"User"> | string
    telephone?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    actif?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    consultations?: ConsultationListRelationFilter
    rendezvous?: RendezVousListRelationFilter
    ecritures?: EcritureComptableListRelationFilter
    paiements?: PaiementListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    observationsCrees?: ObservationInfirmierListRelationFilter
    chirurgies?: InterventionListRelationFilter
    anesthesies?: InterventionListRelationFilter
    employe?: XOR<EmployeNullableScalarRelationFilter, EmployeWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    telephone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    actif?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    nom?: StringWithAggregatesFilter<"User"> | string
    prenom?: StringWithAggregatesFilter<"User"> | string
    telephone?: StringNullableWithAggregatesFilter<"User"> | string | null
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    actif?: BoolWithAggregatesFilter<"User"> | boolean
    roleId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    nom?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: PermissionListRelationFilter
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    permissions?: PermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nom?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    permissions?: PermissionListRelationFilter
    users?: UserListRelationFilter
  }, "id" | "nom">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    nom?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    nom?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RoleListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    roles?: RoleOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nom?: string
    module_action?: PermissionModuleActionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RoleListRelationFilter
  }, "id" | "nom" | "module_action">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    module?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    nom?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    module?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    module?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type CompteComptableWhereInput = {
    AND?: CompteComptableWhereInput | CompteComptableWhereInput[]
    OR?: CompteComptableWhereInput[]
    NOT?: CompteComptableWhereInput | CompteComptableWhereInput[]
    id?: StringFilter<"CompteComptable"> | string
    numero?: StringFilter<"CompteComptable"> | string
    libelle?: StringFilter<"CompteComptable"> | string
    classe?: IntFilter<"CompteComptable"> | number
    type?: StringFilter<"CompteComptable"> | string
    sens?: StringFilter<"CompteComptable"> | string
    actif?: BoolFilter<"CompteComptable"> | boolean
    createdAt?: DateTimeFilter<"CompteComptable"> | Date | string
    updatedAt?: DateTimeFilter<"CompteComptable"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }

  export type CompteComptableOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    libelle?: SortOrder
    classe?: SortOrder
    type?: SortOrder
    sens?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ecritures?: EcritureComptableOrderByRelationAggregateInput
  }

  export type CompteComptableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numero?: string
    AND?: CompteComptableWhereInput | CompteComptableWhereInput[]
    OR?: CompteComptableWhereInput[]
    NOT?: CompteComptableWhereInput | CompteComptableWhereInput[]
    libelle?: StringFilter<"CompteComptable"> | string
    classe?: IntFilter<"CompteComptable"> | number
    type?: StringFilter<"CompteComptable"> | string
    sens?: StringFilter<"CompteComptable"> | string
    actif?: BoolFilter<"CompteComptable"> | boolean
    createdAt?: DateTimeFilter<"CompteComptable"> | Date | string
    updatedAt?: DateTimeFilter<"CompteComptable"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }, "id" | "numero">

  export type CompteComptableOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    libelle?: SortOrder
    classe?: SortOrder
    type?: SortOrder
    sens?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompteComptableCountOrderByAggregateInput
    _avg?: CompteComptableAvgOrderByAggregateInput
    _max?: CompteComptableMaxOrderByAggregateInput
    _min?: CompteComptableMinOrderByAggregateInput
    _sum?: CompteComptableSumOrderByAggregateInput
  }

  export type CompteComptableScalarWhereWithAggregatesInput = {
    AND?: CompteComptableScalarWhereWithAggregatesInput | CompteComptableScalarWhereWithAggregatesInput[]
    OR?: CompteComptableScalarWhereWithAggregatesInput[]
    NOT?: CompteComptableScalarWhereWithAggregatesInput | CompteComptableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompteComptable"> | string
    numero?: StringWithAggregatesFilter<"CompteComptable"> | string
    libelle?: StringWithAggregatesFilter<"CompteComptable"> | string
    classe?: IntWithAggregatesFilter<"CompteComptable"> | number
    type?: StringWithAggregatesFilter<"CompteComptable"> | string
    sens?: StringWithAggregatesFilter<"CompteComptable"> | string
    actif?: BoolWithAggregatesFilter<"CompteComptable"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CompteComptable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompteComptable"> | Date | string
  }

  export type JournalWhereInput = {
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    id?: StringFilter<"Journal"> | string
    code?: StringFilter<"Journal"> | string
    libelle?: StringFilter<"Journal"> | string
    type?: StringFilter<"Journal"> | string
    actif?: BoolFilter<"Journal"> | boolean
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }

  export type JournalOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    ecritures?: EcritureComptableOrderByRelationAggregateInput
  }

  export type JournalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: JournalWhereInput | JournalWhereInput[]
    OR?: JournalWhereInput[]
    NOT?: JournalWhereInput | JournalWhereInput[]
    libelle?: StringFilter<"Journal"> | string
    type?: StringFilter<"Journal"> | string
    actif?: BoolFilter<"Journal"> | boolean
    createdAt?: DateTimeFilter<"Journal"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }, "id" | "code">

  export type JournalOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    _count?: JournalCountOrderByAggregateInput
    _max?: JournalMaxOrderByAggregateInput
    _min?: JournalMinOrderByAggregateInput
  }

  export type JournalScalarWhereWithAggregatesInput = {
    AND?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    OR?: JournalScalarWhereWithAggregatesInput[]
    NOT?: JournalScalarWhereWithAggregatesInput | JournalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Journal"> | string
    code?: StringWithAggregatesFilter<"Journal"> | string
    libelle?: StringWithAggregatesFilter<"Journal"> | string
    type?: StringWithAggregatesFilter<"Journal"> | string
    actif?: BoolWithAggregatesFilter<"Journal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Journal"> | Date | string
  }

  export type ExerciceComptableWhereInput = {
    AND?: ExerciceComptableWhereInput | ExerciceComptableWhereInput[]
    OR?: ExerciceComptableWhereInput[]
    NOT?: ExerciceComptableWhereInput | ExerciceComptableWhereInput[]
    id?: StringFilter<"ExerciceComptable"> | string
    annee?: IntFilter<"ExerciceComptable"> | number
    dateDebut?: DateTimeFilter<"ExerciceComptable"> | Date | string
    dateFin?: DateTimeFilter<"ExerciceComptable"> | Date | string
    cloture?: BoolFilter<"ExerciceComptable"> | boolean
    createdAt?: DateTimeFilter<"ExerciceComptable"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
    budgets?: BudgetListRelationFilter
  }

  export type ExerciceComptableOrderByWithRelationInput = {
    id?: SortOrder
    annee?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cloture?: SortOrder
    createdAt?: SortOrder
    ecritures?: EcritureComptableOrderByRelationAggregateInput
    budgets?: BudgetOrderByRelationAggregateInput
  }

  export type ExerciceComptableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    annee?: number
    AND?: ExerciceComptableWhereInput | ExerciceComptableWhereInput[]
    OR?: ExerciceComptableWhereInput[]
    NOT?: ExerciceComptableWhereInput | ExerciceComptableWhereInput[]
    dateDebut?: DateTimeFilter<"ExerciceComptable"> | Date | string
    dateFin?: DateTimeFilter<"ExerciceComptable"> | Date | string
    cloture?: BoolFilter<"ExerciceComptable"> | boolean
    createdAt?: DateTimeFilter<"ExerciceComptable"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
    budgets?: BudgetListRelationFilter
  }, "id" | "annee">

  export type ExerciceComptableOrderByWithAggregationInput = {
    id?: SortOrder
    annee?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cloture?: SortOrder
    createdAt?: SortOrder
    _count?: ExerciceComptableCountOrderByAggregateInput
    _avg?: ExerciceComptableAvgOrderByAggregateInput
    _max?: ExerciceComptableMaxOrderByAggregateInput
    _min?: ExerciceComptableMinOrderByAggregateInput
    _sum?: ExerciceComptableSumOrderByAggregateInput
  }

  export type ExerciceComptableScalarWhereWithAggregatesInput = {
    AND?: ExerciceComptableScalarWhereWithAggregatesInput | ExerciceComptableScalarWhereWithAggregatesInput[]
    OR?: ExerciceComptableScalarWhereWithAggregatesInput[]
    NOT?: ExerciceComptableScalarWhereWithAggregatesInput | ExerciceComptableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExerciceComptable"> | string
    annee?: IntWithAggregatesFilter<"ExerciceComptable"> | number
    dateDebut?: DateTimeWithAggregatesFilter<"ExerciceComptable"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"ExerciceComptable"> | Date | string
    cloture?: BoolWithAggregatesFilter<"ExerciceComptable"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ExerciceComptable"> | Date | string
  }

  export type EcritureComptableWhereInput = {
    AND?: EcritureComptableWhereInput | EcritureComptableWhereInput[]
    OR?: EcritureComptableWhereInput[]
    NOT?: EcritureComptableWhereInput | EcritureComptableWhereInput[]
    id?: StringFilter<"EcritureComptable"> | string
    journalId?: StringFilter<"EcritureComptable"> | string
    compteId?: StringFilter<"EcritureComptable"> | string
    exerciceId?: StringFilter<"EcritureComptable"> | string
    dateEcriture?: DateTimeFilter<"EcritureComptable"> | Date | string
    libelle?: StringFilter<"EcritureComptable"> | string
    debit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    pieceRef?: StringNullableFilter<"EcritureComptable"> | string | null
    centreAnalytiqueId?: StringNullableFilter<"EcritureComptable"> | string | null
    valide?: BoolFilter<"EcritureComptable"> | boolean
    createdById?: StringFilter<"EcritureComptable"> | string
    createdAt?: DateTimeFilter<"EcritureComptable"> | Date | string
    updatedAt?: DateTimeFilter<"EcritureComptable"> | Date | string
    journal?: XOR<JournalScalarRelationFilter, JournalWhereInput>
    compte?: XOR<CompteComptableScalarRelationFilter, CompteComptableWhereInput>
    exercice?: XOR<ExerciceComptableScalarRelationFilter, ExerciceComptableWhereInput>
    centreAnalytique?: XOR<CentreAnalytiqueNullableScalarRelationFilter, CentreAnalytiqueWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EcritureComptableOrderByWithRelationInput = {
    id?: SortOrder
    journalId?: SortOrder
    compteId?: SortOrder
    exerciceId?: SortOrder
    dateEcriture?: SortOrder
    libelle?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    pieceRef?: SortOrderInput | SortOrder
    centreAnalytiqueId?: SortOrderInput | SortOrder
    valide?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    journal?: JournalOrderByWithRelationInput
    compte?: CompteComptableOrderByWithRelationInput
    exercice?: ExerciceComptableOrderByWithRelationInput
    centreAnalytique?: CentreAnalytiqueOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type EcritureComptableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EcritureComptableWhereInput | EcritureComptableWhereInput[]
    OR?: EcritureComptableWhereInput[]
    NOT?: EcritureComptableWhereInput | EcritureComptableWhereInput[]
    journalId?: StringFilter<"EcritureComptable"> | string
    compteId?: StringFilter<"EcritureComptable"> | string
    exerciceId?: StringFilter<"EcritureComptable"> | string
    dateEcriture?: DateTimeFilter<"EcritureComptable"> | Date | string
    libelle?: StringFilter<"EcritureComptable"> | string
    debit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    pieceRef?: StringNullableFilter<"EcritureComptable"> | string | null
    centreAnalytiqueId?: StringNullableFilter<"EcritureComptable"> | string | null
    valide?: BoolFilter<"EcritureComptable"> | boolean
    createdById?: StringFilter<"EcritureComptable"> | string
    createdAt?: DateTimeFilter<"EcritureComptable"> | Date | string
    updatedAt?: DateTimeFilter<"EcritureComptable"> | Date | string
    journal?: XOR<JournalScalarRelationFilter, JournalWhereInput>
    compte?: XOR<CompteComptableScalarRelationFilter, CompteComptableWhereInput>
    exercice?: XOR<ExerciceComptableScalarRelationFilter, ExerciceComptableWhereInput>
    centreAnalytique?: XOR<CentreAnalytiqueNullableScalarRelationFilter, CentreAnalytiqueWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EcritureComptableOrderByWithAggregationInput = {
    id?: SortOrder
    journalId?: SortOrder
    compteId?: SortOrder
    exerciceId?: SortOrder
    dateEcriture?: SortOrder
    libelle?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    pieceRef?: SortOrderInput | SortOrder
    centreAnalytiqueId?: SortOrderInput | SortOrder
    valide?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EcritureComptableCountOrderByAggregateInput
    _avg?: EcritureComptableAvgOrderByAggregateInput
    _max?: EcritureComptableMaxOrderByAggregateInput
    _min?: EcritureComptableMinOrderByAggregateInput
    _sum?: EcritureComptableSumOrderByAggregateInput
  }

  export type EcritureComptableScalarWhereWithAggregatesInput = {
    AND?: EcritureComptableScalarWhereWithAggregatesInput | EcritureComptableScalarWhereWithAggregatesInput[]
    OR?: EcritureComptableScalarWhereWithAggregatesInput[]
    NOT?: EcritureComptableScalarWhereWithAggregatesInput | EcritureComptableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EcritureComptable"> | string
    journalId?: StringWithAggregatesFilter<"EcritureComptable"> | string
    compteId?: StringWithAggregatesFilter<"EcritureComptable"> | string
    exerciceId?: StringWithAggregatesFilter<"EcritureComptable"> | string
    dateEcriture?: DateTimeWithAggregatesFilter<"EcritureComptable"> | Date | string
    libelle?: StringWithAggregatesFilter<"EcritureComptable"> | string
    debit?: DecimalWithAggregatesFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalWithAggregatesFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    pieceRef?: StringNullableWithAggregatesFilter<"EcritureComptable"> | string | null
    centreAnalytiqueId?: StringNullableWithAggregatesFilter<"EcritureComptable"> | string | null
    valide?: BoolWithAggregatesFilter<"EcritureComptable"> | boolean
    createdById?: StringWithAggregatesFilter<"EcritureComptable"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EcritureComptable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EcritureComptable"> | Date | string
  }

  export type CentreAnalytiqueWhereInput = {
    AND?: CentreAnalytiqueWhereInput | CentreAnalytiqueWhereInput[]
    OR?: CentreAnalytiqueWhereInput[]
    NOT?: CentreAnalytiqueWhereInput | CentreAnalytiqueWhereInput[]
    id?: StringFilter<"CentreAnalytique"> | string
    code?: StringFilter<"CentreAnalytique"> | string
    libelle?: StringFilter<"CentreAnalytique"> | string
    type?: StringFilter<"CentreAnalytique"> | string
    actif?: BoolFilter<"CentreAnalytique"> | boolean
    createdAt?: DateTimeFilter<"CentreAnalytique"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }

  export type CentreAnalytiqueOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    ecritures?: EcritureComptableOrderByRelationAggregateInput
  }

  export type CentreAnalytiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CentreAnalytiqueWhereInput | CentreAnalytiqueWhereInput[]
    OR?: CentreAnalytiqueWhereInput[]
    NOT?: CentreAnalytiqueWhereInput | CentreAnalytiqueWhereInput[]
    libelle?: StringFilter<"CentreAnalytique"> | string
    type?: StringFilter<"CentreAnalytique"> | string
    actif?: BoolFilter<"CentreAnalytique"> | boolean
    createdAt?: DateTimeFilter<"CentreAnalytique"> | Date | string
    ecritures?: EcritureComptableListRelationFilter
  }, "id" | "code">

  export type CentreAnalytiqueOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    _count?: CentreAnalytiqueCountOrderByAggregateInput
    _max?: CentreAnalytiqueMaxOrderByAggregateInput
    _min?: CentreAnalytiqueMinOrderByAggregateInput
  }

  export type CentreAnalytiqueScalarWhereWithAggregatesInput = {
    AND?: CentreAnalytiqueScalarWhereWithAggregatesInput | CentreAnalytiqueScalarWhereWithAggregatesInput[]
    OR?: CentreAnalytiqueScalarWhereWithAggregatesInput[]
    NOT?: CentreAnalytiqueScalarWhereWithAggregatesInput | CentreAnalytiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CentreAnalytique"> | string
    code?: StringWithAggregatesFilter<"CentreAnalytique"> | string
    libelle?: StringWithAggregatesFilter<"CentreAnalytique"> | string
    type?: StringWithAggregatesFilter<"CentreAnalytique"> | string
    actif?: BoolWithAggregatesFilter<"CentreAnalytique"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CentreAnalytique"> | Date | string
  }

  export type BudgetWhereInput = {
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    id?: StringFilter<"Budget"> | string
    exerciceId?: StringFilter<"Budget"> | string
    compte?: StringFilter<"Budget"> | string
    libelle?: StringFilter<"Budget"> | string
    montant?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Budget"> | string
    mois?: IntNullableFilter<"Budget"> | number | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    exercice?: XOR<ExerciceComptableScalarRelationFilter, ExerciceComptableWhereInput>
  }

  export type BudgetOrderByWithRelationInput = {
    id?: SortOrder
    exerciceId?: SortOrder
    compte?: SortOrder
    libelle?: SortOrder
    montant?: SortOrder
    type?: SortOrder
    mois?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    exercice?: ExerciceComptableOrderByWithRelationInput
  }

  export type BudgetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BudgetWhereInput | BudgetWhereInput[]
    OR?: BudgetWhereInput[]
    NOT?: BudgetWhereInput | BudgetWhereInput[]
    exerciceId?: StringFilter<"Budget"> | string
    compte?: StringFilter<"Budget"> | string
    libelle?: StringFilter<"Budget"> | string
    montant?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Budget"> | string
    mois?: IntNullableFilter<"Budget"> | number | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
    exercice?: XOR<ExerciceComptableScalarRelationFilter, ExerciceComptableWhereInput>
  }, "id">

  export type BudgetOrderByWithAggregationInput = {
    id?: SortOrder
    exerciceId?: SortOrder
    compte?: SortOrder
    libelle?: SortOrder
    montant?: SortOrder
    type?: SortOrder
    mois?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BudgetCountOrderByAggregateInput
    _avg?: BudgetAvgOrderByAggregateInput
    _max?: BudgetMaxOrderByAggregateInput
    _min?: BudgetMinOrderByAggregateInput
    _sum?: BudgetSumOrderByAggregateInput
  }

  export type BudgetScalarWhereWithAggregatesInput = {
    AND?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    OR?: BudgetScalarWhereWithAggregatesInput[]
    NOT?: BudgetScalarWhereWithAggregatesInput | BudgetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Budget"> | string
    exerciceId?: StringWithAggregatesFilter<"Budget"> | string
    compte?: StringWithAggregatesFilter<"Budget"> | string
    libelle?: StringWithAggregatesFilter<"Budget"> | string
    montant?: DecimalWithAggregatesFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"Budget"> | string
    mois?: IntNullableWithAggregatesFilter<"Budget"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Budget"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    numeroPatient?: StringFilter<"Patient"> | string
    nom?: StringFilter<"Patient"> | string
    prenom?: StringFilter<"Patient"> | string
    dateNaissance?: DateTimeFilter<"Patient"> | Date | string
    sexe?: StringFilter<"Patient"> | string
    telephone?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    adresse?: StringNullableFilter<"Patient"> | string | null
    ville?: StringNullableFilter<"Patient"> | string | null
    profession?: StringNullableFilter<"Patient"> | string | null
    situationMatrimoniale?: StringNullableFilter<"Patient"> | string | null
    assureur?: StringNullableFilter<"Patient"> | string | null
    numeroAssure?: StringNullableFilter<"Patient"> | string | null
    tauxCouverture?: DecimalNullableFilter<"Patient"> | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: StringNullableFilter<"Patient"> | string | null
    contactUrgenceTel?: StringNullableFilter<"Patient"> | string | null
    contactUrgenceLien?: StringNullableFilter<"Patient"> | string | null
    photo?: StringNullableFilter<"Patient"> | string | null
    actif?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    antecedents?: AntecedentListRelationFilter
    allergies?: AllergieListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    consultations?: ConsultationListRelationFilter
    rendezvous?: RendezVousListRelationFilter
    factures?: FactureListRelationFilter
    dispensations?: DispensationListRelationFilter
    hospitalisations?: HospitalisationListRelationFilter
    interventions?: InterventionListRelationFilter
    dossiersMaternite?: DossierMaterniteListRelationFilter
    documentsGED?: DocumentGEDListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    numeroPatient?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    situationMatrimoniale?: SortOrderInput | SortOrder
    assureur?: SortOrderInput | SortOrder
    numeroAssure?: SortOrderInput | SortOrder
    tauxCouverture?: SortOrderInput | SortOrder
    contactUrgenceNom?: SortOrderInput | SortOrder
    contactUrgenceTel?: SortOrderInput | SortOrder
    contactUrgenceLien?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    antecedents?: AntecedentOrderByRelationAggregateInput
    allergies?: AllergieOrderByRelationAggregateInput
    vaccinations?: VaccinationOrderByRelationAggregateInput
    consultations?: ConsultationOrderByRelationAggregateInput
    rendezvous?: RendezVousOrderByRelationAggregateInput
    factures?: FactureOrderByRelationAggregateInput
    dispensations?: DispensationOrderByRelationAggregateInput
    hospitalisations?: HospitalisationOrderByRelationAggregateInput
    interventions?: InterventionOrderByRelationAggregateInput
    dossiersMaternite?: DossierMaterniteOrderByRelationAggregateInput
    documentsGED?: DocumentGEDOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroPatient?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    nom?: StringFilter<"Patient"> | string
    prenom?: StringFilter<"Patient"> | string
    dateNaissance?: DateTimeFilter<"Patient"> | Date | string
    sexe?: StringFilter<"Patient"> | string
    telephone?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    adresse?: StringNullableFilter<"Patient"> | string | null
    ville?: StringNullableFilter<"Patient"> | string | null
    profession?: StringNullableFilter<"Patient"> | string | null
    situationMatrimoniale?: StringNullableFilter<"Patient"> | string | null
    assureur?: StringNullableFilter<"Patient"> | string | null
    numeroAssure?: StringNullableFilter<"Patient"> | string | null
    tauxCouverture?: DecimalNullableFilter<"Patient"> | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: StringNullableFilter<"Patient"> | string | null
    contactUrgenceTel?: StringNullableFilter<"Patient"> | string | null
    contactUrgenceLien?: StringNullableFilter<"Patient"> | string | null
    photo?: StringNullableFilter<"Patient"> | string | null
    actif?: BoolFilter<"Patient"> | boolean
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    antecedents?: AntecedentListRelationFilter
    allergies?: AllergieListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    consultations?: ConsultationListRelationFilter
    rendezvous?: RendezVousListRelationFilter
    factures?: FactureListRelationFilter
    dispensations?: DispensationListRelationFilter
    hospitalisations?: HospitalisationListRelationFilter
    interventions?: InterventionListRelationFilter
    dossiersMaternite?: DossierMaterniteListRelationFilter
    documentsGED?: DocumentGEDListRelationFilter
  }, "id" | "numeroPatient">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    numeroPatient?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ville?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    situationMatrimoniale?: SortOrderInput | SortOrder
    assureur?: SortOrderInput | SortOrder
    numeroAssure?: SortOrderInput | SortOrder
    tauxCouverture?: SortOrderInput | SortOrder
    contactUrgenceNom?: SortOrderInput | SortOrder
    contactUrgenceTel?: SortOrderInput | SortOrder
    contactUrgenceLien?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    numeroPatient?: StringWithAggregatesFilter<"Patient"> | string
    nom?: StringWithAggregatesFilter<"Patient"> | string
    prenom?: StringWithAggregatesFilter<"Patient"> | string
    dateNaissance?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    sexe?: StringWithAggregatesFilter<"Patient"> | string
    telephone?: StringWithAggregatesFilter<"Patient"> | string
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    ville?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    profession?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    situationMatrimoniale?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    assureur?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    numeroAssure?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    tauxCouverture?: DecimalNullableWithAggregatesFilter<"Patient"> | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    contactUrgenceTel?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    contactUrgenceLien?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    photo?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    actif?: BoolWithAggregatesFilter<"Patient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AntecedentWhereInput = {
    AND?: AntecedentWhereInput | AntecedentWhereInput[]
    OR?: AntecedentWhereInput[]
    NOT?: AntecedentWhereInput | AntecedentWhereInput[]
    id?: StringFilter<"Antecedent"> | string
    patientId?: StringFilter<"Antecedent"> | string
    type?: StringFilter<"Antecedent"> | string
    description?: StringFilter<"Antecedent"> | string
    date?: DateTimeNullableFilter<"Antecedent"> | Date | string | null
    createdAt?: DateTimeFilter<"Antecedent"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AntecedentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    date?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AntecedentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AntecedentWhereInput | AntecedentWhereInput[]
    OR?: AntecedentWhereInput[]
    NOT?: AntecedentWhereInput | AntecedentWhereInput[]
    patientId?: StringFilter<"Antecedent"> | string
    type?: StringFilter<"Antecedent"> | string
    description?: StringFilter<"Antecedent"> | string
    date?: DateTimeNullableFilter<"Antecedent"> | Date | string | null
    createdAt?: DateTimeFilter<"Antecedent"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AntecedentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    date?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AntecedentCountOrderByAggregateInput
    _max?: AntecedentMaxOrderByAggregateInput
    _min?: AntecedentMinOrderByAggregateInput
  }

  export type AntecedentScalarWhereWithAggregatesInput = {
    AND?: AntecedentScalarWhereWithAggregatesInput | AntecedentScalarWhereWithAggregatesInput[]
    OR?: AntecedentScalarWhereWithAggregatesInput[]
    NOT?: AntecedentScalarWhereWithAggregatesInput | AntecedentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Antecedent"> | string
    patientId?: StringWithAggregatesFilter<"Antecedent"> | string
    type?: StringWithAggregatesFilter<"Antecedent"> | string
    description?: StringWithAggregatesFilter<"Antecedent"> | string
    date?: DateTimeNullableWithAggregatesFilter<"Antecedent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Antecedent"> | Date | string
  }

  export type AllergieWhereInput = {
    AND?: AllergieWhereInput | AllergieWhereInput[]
    OR?: AllergieWhereInput[]
    NOT?: AllergieWhereInput | AllergieWhereInput[]
    id?: StringFilter<"Allergie"> | string
    patientId?: StringFilter<"Allergie"> | string
    type?: StringFilter<"Allergie"> | string
    allergene?: StringFilter<"Allergie"> | string
    severite?: StringFilter<"Allergie"> | string
    reaction?: StringNullableFilter<"Allergie"> | string | null
    createdAt?: DateTimeFilter<"Allergie"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type AllergieOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    allergene?: SortOrder
    severite?: SortOrder
    reaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AllergieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AllergieWhereInput | AllergieWhereInput[]
    OR?: AllergieWhereInput[]
    NOT?: AllergieWhereInput | AllergieWhereInput[]
    patientId?: StringFilter<"Allergie"> | string
    type?: StringFilter<"Allergie"> | string
    allergene?: StringFilter<"Allergie"> | string
    severite?: StringFilter<"Allergie"> | string
    reaction?: StringNullableFilter<"Allergie"> | string | null
    createdAt?: DateTimeFilter<"Allergie"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type AllergieOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    allergene?: SortOrder
    severite?: SortOrder
    reaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AllergieCountOrderByAggregateInput
    _max?: AllergieMaxOrderByAggregateInput
    _min?: AllergieMinOrderByAggregateInput
  }

  export type AllergieScalarWhereWithAggregatesInput = {
    AND?: AllergieScalarWhereWithAggregatesInput | AllergieScalarWhereWithAggregatesInput[]
    OR?: AllergieScalarWhereWithAggregatesInput[]
    NOT?: AllergieScalarWhereWithAggregatesInput | AllergieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Allergie"> | string
    patientId?: StringWithAggregatesFilter<"Allergie"> | string
    type?: StringWithAggregatesFilter<"Allergie"> | string
    allergene?: StringWithAggregatesFilter<"Allergie"> | string
    severite?: StringWithAggregatesFilter<"Allergie"> | string
    reaction?: StringNullableWithAggregatesFilter<"Allergie"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Allergie"> | Date | string
  }

  export type VaccinationWhereInput = {
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    id?: StringFilter<"Vaccination"> | string
    patientId?: StringFilter<"Vaccination"> | string
    vaccin?: StringFilter<"Vaccination"> | string
    dateVaccin?: DateTimeFilter<"Vaccination"> | Date | string
    rappel?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    lot?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type VaccinationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccin?: SortOrder
    dateVaccin?: SortOrder
    rappel?: SortOrderInput | SortOrder
    lot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type VaccinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    patientId?: StringFilter<"Vaccination"> | string
    vaccin?: StringFilter<"Vaccination"> | string
    dateVaccin?: DateTimeFilter<"Vaccination"> | Date | string
    rappel?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    lot?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type VaccinationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccin?: SortOrder
    dateVaccin?: SortOrder
    rappel?: SortOrderInput | SortOrder
    lot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VaccinationCountOrderByAggregateInput
    _max?: VaccinationMaxOrderByAggregateInput
    _min?: VaccinationMinOrderByAggregateInput
  }

  export type VaccinationScalarWhereWithAggregatesInput = {
    AND?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    OR?: VaccinationScalarWhereWithAggregatesInput[]
    NOT?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vaccination"> | string
    patientId?: StringWithAggregatesFilter<"Vaccination"> | string
    vaccin?: StringWithAggregatesFilter<"Vaccination"> | string
    dateVaccin?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
    rappel?: DateTimeNullableWithAggregatesFilter<"Vaccination"> | Date | string | null
    lot?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
  }

  export type RendezVousWhereInput = {
    AND?: RendezVousWhereInput | RendezVousWhereInput[]
    OR?: RendezVousWhereInput[]
    NOT?: RendezVousWhereInput | RendezVousWhereInput[]
    id?: StringFilter<"RendezVous"> | string
    patientId?: StringFilter<"RendezVous"> | string
    medecinId?: StringFilter<"RendezVous"> | string
    dateHeure?: DateTimeFilter<"RendezVous"> | Date | string
    duree?: IntFilter<"RendezVous"> | number
    motif?: StringFilter<"RendezVous"> | string
    statut?: StringFilter<"RendezVous"> | string
    notes?: StringNullableFilter<"RendezVous"> | string | null
    createdAt?: DateTimeFilter<"RendezVous"> | Date | string
    updatedAt?: DateTimeFilter<"RendezVous"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medecin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RendezVousOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateHeure?: SortOrder
    duree?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    medecin?: UserOrderByWithRelationInput
  }

  export type RendezVousWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RendezVousWhereInput | RendezVousWhereInput[]
    OR?: RendezVousWhereInput[]
    NOT?: RendezVousWhereInput | RendezVousWhereInput[]
    patientId?: StringFilter<"RendezVous"> | string
    medecinId?: StringFilter<"RendezVous"> | string
    dateHeure?: DateTimeFilter<"RendezVous"> | Date | string
    duree?: IntFilter<"RendezVous"> | number
    motif?: StringFilter<"RendezVous"> | string
    statut?: StringFilter<"RendezVous"> | string
    notes?: StringNullableFilter<"RendezVous"> | string | null
    createdAt?: DateTimeFilter<"RendezVous"> | Date | string
    updatedAt?: DateTimeFilter<"RendezVous"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medecin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RendezVousOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateHeure?: SortOrder
    duree?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RendezVousCountOrderByAggregateInput
    _avg?: RendezVousAvgOrderByAggregateInput
    _max?: RendezVousMaxOrderByAggregateInput
    _min?: RendezVousMinOrderByAggregateInput
    _sum?: RendezVousSumOrderByAggregateInput
  }

  export type RendezVousScalarWhereWithAggregatesInput = {
    AND?: RendezVousScalarWhereWithAggregatesInput | RendezVousScalarWhereWithAggregatesInput[]
    OR?: RendezVousScalarWhereWithAggregatesInput[]
    NOT?: RendezVousScalarWhereWithAggregatesInput | RendezVousScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RendezVous"> | string
    patientId?: StringWithAggregatesFilter<"RendezVous"> | string
    medecinId?: StringWithAggregatesFilter<"RendezVous"> | string
    dateHeure?: DateTimeWithAggregatesFilter<"RendezVous"> | Date | string
    duree?: IntWithAggregatesFilter<"RendezVous"> | number
    motif?: StringWithAggregatesFilter<"RendezVous"> | string
    statut?: StringWithAggregatesFilter<"RendezVous"> | string
    notes?: StringNullableWithAggregatesFilter<"RendezVous"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RendezVous"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RendezVous"> | Date | string
  }

  export type ConsultationWhereInput = {
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    id?: StringFilter<"Consultation"> | string
    patientId?: StringFilter<"Consultation"> | string
    medecinId?: StringFilter<"Consultation"> | string
    dateConsultation?: DateTimeFilter<"Consultation"> | Date | string
    motifConsultation?: StringFilter<"Consultation"> | string
    anamnese?: StringNullableFilter<"Consultation"> | string | null
    examenClinique?: StringNullableFilter<"Consultation"> | string | null
    diagnostic?: StringNullableFilter<"Consultation"> | string | null
    planTraitement?: StringNullableFilter<"Consultation"> | string | null
    poids?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    taille?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    temperature?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    donneesSpecialite?: JsonNullableFilter<"Consultation">
    factureId?: StringNullableFilter<"Consultation"> | string | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medecin?: XOR<UserScalarRelationFilter, UserWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    actesRealises?: ActeRealiseListRelationFilter
    facture?: XOR<FactureNullableScalarRelationFilter, FactureWhereInput> | null
  }

  export type ConsultationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateConsultation?: SortOrder
    motifConsultation?: SortOrder
    anamnese?: SortOrderInput | SortOrder
    examenClinique?: SortOrderInput | SortOrder
    diagnostic?: SortOrderInput | SortOrder
    planTraitement?: SortOrderInput | SortOrder
    poids?: SortOrderInput | SortOrder
    taille?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    tensionSystolique?: SortOrderInput | SortOrder
    tensionDiastolique?: SortOrderInput | SortOrder
    frequenceCardiaque?: SortOrderInput | SortOrder
    saturationOxygene?: SortOrderInput | SortOrder
    donneesSpecialite?: SortOrderInput | SortOrder
    factureId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    medecin?: UserOrderByWithRelationInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    actesRealises?: ActeRealiseOrderByRelationAggregateInput
    facture?: FactureOrderByWithRelationInput
  }

  export type ConsultationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConsultationWhereInput | ConsultationWhereInput[]
    OR?: ConsultationWhereInput[]
    NOT?: ConsultationWhereInput | ConsultationWhereInput[]
    patientId?: StringFilter<"Consultation"> | string
    medecinId?: StringFilter<"Consultation"> | string
    dateConsultation?: DateTimeFilter<"Consultation"> | Date | string
    motifConsultation?: StringFilter<"Consultation"> | string
    anamnese?: StringNullableFilter<"Consultation"> | string | null
    examenClinique?: StringNullableFilter<"Consultation"> | string | null
    diagnostic?: StringNullableFilter<"Consultation"> | string | null
    planTraitement?: StringNullableFilter<"Consultation"> | string | null
    poids?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    taille?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    temperature?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    donneesSpecialite?: JsonNullableFilter<"Consultation">
    factureId?: StringNullableFilter<"Consultation"> | string | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    medecin?: XOR<UserScalarRelationFilter, UserWhereInput>
    prescriptions?: PrescriptionListRelationFilter
    actesRealises?: ActeRealiseListRelationFilter
    facture?: XOR<FactureNullableScalarRelationFilter, FactureWhereInput> | null
  }, "id">

  export type ConsultationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateConsultation?: SortOrder
    motifConsultation?: SortOrder
    anamnese?: SortOrderInput | SortOrder
    examenClinique?: SortOrderInput | SortOrder
    diagnostic?: SortOrderInput | SortOrder
    planTraitement?: SortOrderInput | SortOrder
    poids?: SortOrderInput | SortOrder
    taille?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    tensionSystolique?: SortOrderInput | SortOrder
    tensionDiastolique?: SortOrderInput | SortOrder
    frequenceCardiaque?: SortOrderInput | SortOrder
    saturationOxygene?: SortOrderInput | SortOrder
    donneesSpecialite?: SortOrderInput | SortOrder
    factureId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConsultationCountOrderByAggregateInput
    _avg?: ConsultationAvgOrderByAggregateInput
    _max?: ConsultationMaxOrderByAggregateInput
    _min?: ConsultationMinOrderByAggregateInput
    _sum?: ConsultationSumOrderByAggregateInput
  }

  export type ConsultationScalarWhereWithAggregatesInput = {
    AND?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    OR?: ConsultationScalarWhereWithAggregatesInput[]
    NOT?: ConsultationScalarWhereWithAggregatesInput | ConsultationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Consultation"> | string
    patientId?: StringWithAggregatesFilter<"Consultation"> | string
    medecinId?: StringWithAggregatesFilter<"Consultation"> | string
    dateConsultation?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    motifConsultation?: StringWithAggregatesFilter<"Consultation"> | string
    anamnese?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    examenClinique?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    diagnostic?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    planTraitement?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    poids?: DecimalNullableWithAggregatesFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    taille?: DecimalNullableWithAggregatesFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    temperature?: DecimalNullableWithAggregatesFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableWithAggregatesFilter<"Consultation"> | number | null
    donneesSpecialite?: JsonNullableWithAggregatesFilter<"Consultation">
    factureId?: StringNullableWithAggregatesFilter<"Consultation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Consultation"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    consultationId?: StringFilter<"Prescription"> | string
    medicament?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    forme?: StringFilter<"Prescription"> | string
    posologie?: StringFilter<"Prescription"> | string
    duree?: StringFilter<"Prescription"> | string
    quantite?: IntFilter<"Prescription"> | number
    instructions?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    medicament?: SortOrder
    dosage?: SortOrder
    forme?: SortOrder
    posologie?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultation?: ConsultationOrderByWithRelationInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    consultationId?: StringFilter<"Prescription"> | string
    medicament?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    forme?: StringFilter<"Prescription"> | string
    posologie?: StringFilter<"Prescription"> | string
    duree?: StringFilter<"Prescription"> | string
    quantite?: IntFilter<"Prescription"> | number
    instructions?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    medicament?: SortOrder
    dosage?: SortOrder
    forme?: SortOrder
    posologie?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
    instructions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    consultationId?: StringWithAggregatesFilter<"Prescription"> | string
    medicament?: StringWithAggregatesFilter<"Prescription"> | string
    dosage?: StringWithAggregatesFilter<"Prescription"> | string
    forme?: StringWithAggregatesFilter<"Prescription"> | string
    posologie?: StringWithAggregatesFilter<"Prescription"> | string
    duree?: StringWithAggregatesFilter<"Prescription"> | string
    quantite?: IntWithAggregatesFilter<"Prescription"> | number
    instructions?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type NomenclatureActeWhereInput = {
    AND?: NomenclatureActeWhereInput | NomenclatureActeWhereInput[]
    OR?: NomenclatureActeWhereInput[]
    NOT?: NomenclatureActeWhereInput | NomenclatureActeWhereInput[]
    id?: StringFilter<"NomenclatureActe"> | string
    code?: StringFilter<"NomenclatureActe"> | string
    libelle?: StringFilter<"NomenclatureActe"> | string
    specialite?: StringFilter<"NomenclatureActe"> | string
    tarif?: DecimalFilter<"NomenclatureActe"> | Decimal | DecimalJsLike | number | string
    duree?: IntNullableFilter<"NomenclatureActe"> | number | null
    actif?: BoolFilter<"NomenclatureActe"> | boolean
    createdAt?: DateTimeFilter<"NomenclatureActe"> | Date | string
    actes?: ActeRealiseListRelationFilter
  }

  export type NomenclatureActeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    specialite?: SortOrder
    tarif?: SortOrder
    duree?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    actes?: ActeRealiseOrderByRelationAggregateInput
  }

  export type NomenclatureActeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: NomenclatureActeWhereInput | NomenclatureActeWhereInput[]
    OR?: NomenclatureActeWhereInput[]
    NOT?: NomenclatureActeWhereInput | NomenclatureActeWhereInput[]
    libelle?: StringFilter<"NomenclatureActe"> | string
    specialite?: StringFilter<"NomenclatureActe"> | string
    tarif?: DecimalFilter<"NomenclatureActe"> | Decimal | DecimalJsLike | number | string
    duree?: IntNullableFilter<"NomenclatureActe"> | number | null
    actif?: BoolFilter<"NomenclatureActe"> | boolean
    createdAt?: DateTimeFilter<"NomenclatureActe"> | Date | string
    actes?: ActeRealiseListRelationFilter
  }, "id" | "code">

  export type NomenclatureActeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    specialite?: SortOrder
    tarif?: SortOrder
    duree?: SortOrderInput | SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    _count?: NomenclatureActeCountOrderByAggregateInput
    _avg?: NomenclatureActeAvgOrderByAggregateInput
    _max?: NomenclatureActeMaxOrderByAggregateInput
    _min?: NomenclatureActeMinOrderByAggregateInput
    _sum?: NomenclatureActeSumOrderByAggregateInput
  }

  export type NomenclatureActeScalarWhereWithAggregatesInput = {
    AND?: NomenclatureActeScalarWhereWithAggregatesInput | NomenclatureActeScalarWhereWithAggregatesInput[]
    OR?: NomenclatureActeScalarWhereWithAggregatesInput[]
    NOT?: NomenclatureActeScalarWhereWithAggregatesInput | NomenclatureActeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NomenclatureActe"> | string
    code?: StringWithAggregatesFilter<"NomenclatureActe"> | string
    libelle?: StringWithAggregatesFilter<"NomenclatureActe"> | string
    specialite?: StringWithAggregatesFilter<"NomenclatureActe"> | string
    tarif?: DecimalWithAggregatesFilter<"NomenclatureActe"> | Decimal | DecimalJsLike | number | string
    duree?: IntNullableWithAggregatesFilter<"NomenclatureActe"> | number | null
    actif?: BoolWithAggregatesFilter<"NomenclatureActe"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NomenclatureActe"> | Date | string
  }

  export type ActeRealiseWhereInput = {
    AND?: ActeRealiseWhereInput | ActeRealiseWhereInput[]
    OR?: ActeRealiseWhereInput[]
    NOT?: ActeRealiseWhereInput | ActeRealiseWhereInput[]
    id?: StringFilter<"ActeRealise"> | string
    consultationId?: StringFilter<"ActeRealise"> | string
    acteId?: StringFilter<"ActeRealise"> | string
    quantite?: IntFilter<"ActeRealise"> | number
    tarif?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ActeRealise"> | string | null
    createdAt?: DateTimeFilter<"ActeRealise"> | Date | string
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
    acte?: XOR<NomenclatureActeScalarRelationFilter, NomenclatureActeWhereInput>
    resultat?: XOR<ResultatExamenNullableScalarRelationFilter, ResultatExamenWhereInput> | null
  }

  export type ActeRealiseOrderByWithRelationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    acteId?: SortOrder
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    consultation?: ConsultationOrderByWithRelationInput
    acte?: NomenclatureActeOrderByWithRelationInput
    resultat?: ResultatExamenOrderByWithRelationInput
  }

  export type ActeRealiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActeRealiseWhereInput | ActeRealiseWhereInput[]
    OR?: ActeRealiseWhereInput[]
    NOT?: ActeRealiseWhereInput | ActeRealiseWhereInput[]
    consultationId?: StringFilter<"ActeRealise"> | string
    acteId?: StringFilter<"ActeRealise"> | string
    quantite?: IntFilter<"ActeRealise"> | number
    tarif?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ActeRealise"> | string | null
    createdAt?: DateTimeFilter<"ActeRealise"> | Date | string
    consultation?: XOR<ConsultationScalarRelationFilter, ConsultationWhereInput>
    acte?: XOR<NomenclatureActeScalarRelationFilter, NomenclatureActeWhereInput>
    resultat?: XOR<ResultatExamenNullableScalarRelationFilter, ResultatExamenWhereInput> | null
  }, "id">

  export type ActeRealiseOrderByWithAggregationInput = {
    id?: SortOrder
    consultationId?: SortOrder
    acteId?: SortOrder
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActeRealiseCountOrderByAggregateInput
    _avg?: ActeRealiseAvgOrderByAggregateInput
    _max?: ActeRealiseMaxOrderByAggregateInput
    _min?: ActeRealiseMinOrderByAggregateInput
    _sum?: ActeRealiseSumOrderByAggregateInput
  }

  export type ActeRealiseScalarWhereWithAggregatesInput = {
    AND?: ActeRealiseScalarWhereWithAggregatesInput | ActeRealiseScalarWhereWithAggregatesInput[]
    OR?: ActeRealiseScalarWhereWithAggregatesInput[]
    NOT?: ActeRealiseScalarWhereWithAggregatesInput | ActeRealiseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActeRealise"> | string
    consultationId?: StringWithAggregatesFilter<"ActeRealise"> | string
    acteId?: StringWithAggregatesFilter<"ActeRealise"> | string
    quantite?: IntWithAggregatesFilter<"ActeRealise"> | number
    tarif?: DecimalWithAggregatesFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalWithAggregatesFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"ActeRealise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActeRealise"> | Date | string
  }

  export type ResultatExamenWhereInput = {
    AND?: ResultatExamenWhereInput | ResultatExamenWhereInput[]
    OR?: ResultatExamenWhereInput[]
    NOT?: ResultatExamenWhereInput | ResultatExamenWhereInput[]
    id?: StringFilter<"ResultatExamen"> | string
    acteRealiseId?: StringFilter<"ResultatExamen"> | string
    valeurs?: JsonNullableFilter<"ResultatExamen">
    conclusion?: StringNullableFilter<"ResultatExamen"> | string | null
    compteRendu?: StringNullableFilter<"ResultatExamen"> | string | null
    images?: StringNullableListFilter<"ResultatExamen">
    dateExamen?: DateTimeFilter<"ResultatExamen"> | Date | string
    validePar?: StringNullableFilter<"ResultatExamen"> | string | null
    dateValidation?: DateTimeNullableFilter<"ResultatExamen"> | Date | string | null
    createdAt?: DateTimeFilter<"ResultatExamen"> | Date | string
    updatedAt?: DateTimeFilter<"ResultatExamen"> | Date | string
    acteRealise?: XOR<ActeRealiseScalarRelationFilter, ActeRealiseWhereInput>
  }

  export type ResultatExamenOrderByWithRelationInput = {
    id?: SortOrder
    acteRealiseId?: SortOrder
    valeurs?: SortOrderInput | SortOrder
    conclusion?: SortOrderInput | SortOrder
    compteRendu?: SortOrderInput | SortOrder
    images?: SortOrder
    dateExamen?: SortOrder
    validePar?: SortOrderInput | SortOrder
    dateValidation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    acteRealise?: ActeRealiseOrderByWithRelationInput
  }

  export type ResultatExamenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    acteRealiseId?: string
    AND?: ResultatExamenWhereInput | ResultatExamenWhereInput[]
    OR?: ResultatExamenWhereInput[]
    NOT?: ResultatExamenWhereInput | ResultatExamenWhereInput[]
    valeurs?: JsonNullableFilter<"ResultatExamen">
    conclusion?: StringNullableFilter<"ResultatExamen"> | string | null
    compteRendu?: StringNullableFilter<"ResultatExamen"> | string | null
    images?: StringNullableListFilter<"ResultatExamen">
    dateExamen?: DateTimeFilter<"ResultatExamen"> | Date | string
    validePar?: StringNullableFilter<"ResultatExamen"> | string | null
    dateValidation?: DateTimeNullableFilter<"ResultatExamen"> | Date | string | null
    createdAt?: DateTimeFilter<"ResultatExamen"> | Date | string
    updatedAt?: DateTimeFilter<"ResultatExamen"> | Date | string
    acteRealise?: XOR<ActeRealiseScalarRelationFilter, ActeRealiseWhereInput>
  }, "id" | "acteRealiseId">

  export type ResultatExamenOrderByWithAggregationInput = {
    id?: SortOrder
    acteRealiseId?: SortOrder
    valeurs?: SortOrderInput | SortOrder
    conclusion?: SortOrderInput | SortOrder
    compteRendu?: SortOrderInput | SortOrder
    images?: SortOrder
    dateExamen?: SortOrder
    validePar?: SortOrderInput | SortOrder
    dateValidation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultatExamenCountOrderByAggregateInput
    _max?: ResultatExamenMaxOrderByAggregateInput
    _min?: ResultatExamenMinOrderByAggregateInput
  }

  export type ResultatExamenScalarWhereWithAggregatesInput = {
    AND?: ResultatExamenScalarWhereWithAggregatesInput | ResultatExamenScalarWhereWithAggregatesInput[]
    OR?: ResultatExamenScalarWhereWithAggregatesInput[]
    NOT?: ResultatExamenScalarWhereWithAggregatesInput | ResultatExamenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResultatExamen"> | string
    acteRealiseId?: StringWithAggregatesFilter<"ResultatExamen"> | string
    valeurs?: JsonNullableWithAggregatesFilter<"ResultatExamen">
    conclusion?: StringNullableWithAggregatesFilter<"ResultatExamen"> | string | null
    compteRendu?: StringNullableWithAggregatesFilter<"ResultatExamen"> | string | null
    images?: StringNullableListFilter<"ResultatExamen">
    dateExamen?: DateTimeWithAggregatesFilter<"ResultatExamen"> | Date | string
    validePar?: StringNullableWithAggregatesFilter<"ResultatExamen"> | string | null
    dateValidation?: DateTimeNullableWithAggregatesFilter<"ResultatExamen"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ResultatExamen"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResultatExamen"> | Date | string
  }

  export type MedicamentWhereInput = {
    AND?: MedicamentWhereInput | MedicamentWhereInput[]
    OR?: MedicamentWhereInput[]
    NOT?: MedicamentWhereInput | MedicamentWhereInput[]
    id?: StringFilter<"Medicament"> | string
    codeANIS?: StringNullableFilter<"Medicament"> | string | null
    dci?: StringFilter<"Medicament"> | string
    nomCommercial?: StringFilter<"Medicament"> | string
    forme?: StringFilter<"Medicament"> | string
    dosage?: StringFilter<"Medicament"> | string
    fabricant?: StringNullableFilter<"Medicament"> | string | null
    prixAchat?: DecimalFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFilter<"Medicament"> | number
    actif?: BoolFilter<"Medicament"> | boolean
    createdAt?: DateTimeFilter<"Medicament"> | Date | string
    updatedAt?: DateTimeFilter<"Medicament"> | Date | string
    stocks?: StockListRelationFilter
    mouvements?: MouvementStockListRelationFilter
    dispensations?: DispensationListRelationFilter
    commandes?: LigneCommandePharmacieListRelationFilter
  }

  export type MedicamentOrderByWithRelationInput = {
    id?: SortOrder
    codeANIS?: SortOrderInput | SortOrder
    dci?: SortOrder
    nomCommercial?: SortOrder
    forme?: SortOrder
    dosage?: SortOrder
    fabricant?: SortOrderInput | SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    stocks?: StockOrderByRelationAggregateInput
    mouvements?: MouvementStockOrderByRelationAggregateInput
    dispensations?: DispensationOrderByRelationAggregateInput
    commandes?: LigneCommandePharmacieOrderByRelationAggregateInput
  }

  export type MedicamentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codeANIS?: string
    AND?: MedicamentWhereInput | MedicamentWhereInput[]
    OR?: MedicamentWhereInput[]
    NOT?: MedicamentWhereInput | MedicamentWhereInput[]
    dci?: StringFilter<"Medicament"> | string
    nomCommercial?: StringFilter<"Medicament"> | string
    forme?: StringFilter<"Medicament"> | string
    dosage?: StringFilter<"Medicament"> | string
    fabricant?: StringNullableFilter<"Medicament"> | string | null
    prixAchat?: DecimalFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFilter<"Medicament"> | number
    actif?: BoolFilter<"Medicament"> | boolean
    createdAt?: DateTimeFilter<"Medicament"> | Date | string
    updatedAt?: DateTimeFilter<"Medicament"> | Date | string
    stocks?: StockListRelationFilter
    mouvements?: MouvementStockListRelationFilter
    dispensations?: DispensationListRelationFilter
    commandes?: LigneCommandePharmacieListRelationFilter
  }, "id" | "codeANIS">

  export type MedicamentOrderByWithAggregationInput = {
    id?: SortOrder
    codeANIS?: SortOrderInput | SortOrder
    dci?: SortOrder
    nomCommercial?: SortOrder
    forme?: SortOrder
    dosage?: SortOrder
    fabricant?: SortOrderInput | SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicamentCountOrderByAggregateInput
    _avg?: MedicamentAvgOrderByAggregateInput
    _max?: MedicamentMaxOrderByAggregateInput
    _min?: MedicamentMinOrderByAggregateInput
    _sum?: MedicamentSumOrderByAggregateInput
  }

  export type MedicamentScalarWhereWithAggregatesInput = {
    AND?: MedicamentScalarWhereWithAggregatesInput | MedicamentScalarWhereWithAggregatesInput[]
    OR?: MedicamentScalarWhereWithAggregatesInput[]
    NOT?: MedicamentScalarWhereWithAggregatesInput | MedicamentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medicament"> | string
    codeANIS?: StringNullableWithAggregatesFilter<"Medicament"> | string | null
    dci?: StringWithAggregatesFilter<"Medicament"> | string
    nomCommercial?: StringWithAggregatesFilter<"Medicament"> | string
    forme?: StringWithAggregatesFilter<"Medicament"> | string
    dosage?: StringWithAggregatesFilter<"Medicament"> | string
    fabricant?: StringNullableWithAggregatesFilter<"Medicament"> | string | null
    prixAchat?: DecimalWithAggregatesFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalWithAggregatesFilter<"Medicament"> | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntWithAggregatesFilter<"Medicament"> | number
    actif?: BoolWithAggregatesFilter<"Medicament"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Medicament"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medicament"> | Date | string
  }

  export type FournisseurWhereInput = {
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    id?: StringFilter<"Fournisseur"> | string
    nom?: StringFilter<"Fournisseur"> | string
    code?: StringNullableFilter<"Fournisseur"> | string | null
    contact?: StringNullableFilter<"Fournisseur"> | string | null
    email?: StringNullableFilter<"Fournisseur"> | string | null
    telephone?: StringNullableFilter<"Fournisseur"> | string | null
    adresse?: StringNullableFilter<"Fournisseur"> | string | null
    ninea?: StringNullableFilter<"Fournisseur"> | string | null
    rccm?: StringNullableFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    commandes?: CommandePharmacieListRelationFilter
  }

  export type FournisseurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ninea?: SortOrderInput | SortOrder
    rccm?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commandes?: CommandePharmacieOrderByRelationAggregateInput
  }

  export type FournisseurWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nom?: string
    code?: string
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    contact?: StringNullableFilter<"Fournisseur"> | string | null
    email?: StringNullableFilter<"Fournisseur"> | string | null
    telephone?: StringNullableFilter<"Fournisseur"> | string | null
    adresse?: StringNullableFilter<"Fournisseur"> | string | null
    ninea?: StringNullableFilter<"Fournisseur"> | string | null
    rccm?: StringNullableFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    commandes?: CommandePharmacieListRelationFilter
  }, "id" | "nom" | "code">

  export type FournisseurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telephone?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    ninea?: SortOrderInput | SortOrder
    rccm?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FournisseurCountOrderByAggregateInput
    _max?: FournisseurMaxOrderByAggregateInput
    _min?: FournisseurMinOrderByAggregateInput
  }

  export type FournisseurScalarWhereWithAggregatesInput = {
    AND?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    OR?: FournisseurScalarWhereWithAggregatesInput[]
    NOT?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fournisseur"> | string
    nom?: StringWithAggregatesFilter<"Fournisseur"> | string
    code?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    email?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    telephone?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    ninea?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    rccm?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
  }

  export type CommandePharmacieWhereInput = {
    AND?: CommandePharmacieWhereInput | CommandePharmacieWhereInput[]
    OR?: CommandePharmacieWhereInput[]
    NOT?: CommandePharmacieWhereInput | CommandePharmacieWhereInput[]
    id?: StringFilter<"CommandePharmacie"> | string
    numeroCommande?: StringFilter<"CommandePharmacie"> | string
    fournisseurId?: StringFilter<"CommandePharmacie"> | string
    dateCommande?: DateTimeFilter<"CommandePharmacie"> | Date | string
    dateLivraison?: DateTimeNullableFilter<"CommandePharmacie"> | Date | string | null
    montantTotal?: DecimalFilter<"CommandePharmacie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"CommandePharmacie"> | string
    createdAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
    updatedAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    lignes?: LigneCommandePharmacieListRelationFilter
  }

  export type CommandePharmacieOrderByWithRelationInput = {
    id?: SortOrder
    numeroCommande?: SortOrder
    fournisseurId?: SortOrder
    dateCommande?: SortOrder
    dateLivraison?: SortOrderInput | SortOrder
    montantTotal?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fournisseur?: FournisseurOrderByWithRelationInput
    lignes?: LigneCommandePharmacieOrderByRelationAggregateInput
  }

  export type CommandePharmacieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroCommande?: string
    AND?: CommandePharmacieWhereInput | CommandePharmacieWhereInput[]
    OR?: CommandePharmacieWhereInput[]
    NOT?: CommandePharmacieWhereInput | CommandePharmacieWhereInput[]
    fournisseurId?: StringFilter<"CommandePharmacie"> | string
    dateCommande?: DateTimeFilter<"CommandePharmacie"> | Date | string
    dateLivraison?: DateTimeNullableFilter<"CommandePharmacie"> | Date | string | null
    montantTotal?: DecimalFilter<"CommandePharmacie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"CommandePharmacie"> | string
    createdAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
    updatedAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    lignes?: LigneCommandePharmacieListRelationFilter
  }, "id" | "numeroCommande">

  export type CommandePharmacieOrderByWithAggregationInput = {
    id?: SortOrder
    numeroCommande?: SortOrder
    fournisseurId?: SortOrder
    dateCommande?: SortOrder
    dateLivraison?: SortOrderInput | SortOrder
    montantTotal?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandePharmacieCountOrderByAggregateInput
    _avg?: CommandePharmacieAvgOrderByAggregateInput
    _max?: CommandePharmacieMaxOrderByAggregateInput
    _min?: CommandePharmacieMinOrderByAggregateInput
    _sum?: CommandePharmacieSumOrderByAggregateInput
  }

  export type CommandePharmacieScalarWhereWithAggregatesInput = {
    AND?: CommandePharmacieScalarWhereWithAggregatesInput | CommandePharmacieScalarWhereWithAggregatesInput[]
    OR?: CommandePharmacieScalarWhereWithAggregatesInput[]
    NOT?: CommandePharmacieScalarWhereWithAggregatesInput | CommandePharmacieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommandePharmacie"> | string
    numeroCommande?: StringWithAggregatesFilter<"CommandePharmacie"> | string
    fournisseurId?: StringWithAggregatesFilter<"CommandePharmacie"> | string
    dateCommande?: DateTimeWithAggregatesFilter<"CommandePharmacie"> | Date | string
    dateLivraison?: DateTimeNullableWithAggregatesFilter<"CommandePharmacie"> | Date | string | null
    montantTotal?: DecimalWithAggregatesFilter<"CommandePharmacie"> | Decimal | DecimalJsLike | number | string
    statut?: StringWithAggregatesFilter<"CommandePharmacie"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommandePharmacie"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommandePharmacie"> | Date | string
  }

  export type LigneCommandePharmacieWhereInput = {
    AND?: LigneCommandePharmacieWhereInput | LigneCommandePharmacieWhereInput[]
    OR?: LigneCommandePharmacieWhereInput[]
    NOT?: LigneCommandePharmacieWhereInput | LigneCommandePharmacieWhereInput[]
    id?: StringFilter<"LigneCommandePharmacie"> | string
    commandeId?: StringFilter<"LigneCommandePharmacie"> | string
    medicamentId?: StringFilter<"LigneCommandePharmacie"> | string
    quantiteCommandee?: IntFilter<"LigneCommandePharmacie"> | number
    quantiteRecue?: IntFilter<"LigneCommandePharmacie"> | number
    prixUnitaire?: DecimalFilter<"LigneCommandePharmacie"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneCommandePharmacie"> | Date | string
    commande?: XOR<CommandePharmacieScalarRelationFilter, CommandePharmacieWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }

  export type LigneCommandePharmacieOrderByWithRelationInput = {
    id?: SortOrder
    commandeId?: SortOrder
    medicamentId?: SortOrder
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    createdAt?: SortOrder
    commande?: CommandePharmacieOrderByWithRelationInput
    medicament?: MedicamentOrderByWithRelationInput
  }

  export type LigneCommandePharmacieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LigneCommandePharmacieWhereInput | LigneCommandePharmacieWhereInput[]
    OR?: LigneCommandePharmacieWhereInput[]
    NOT?: LigneCommandePharmacieWhereInput | LigneCommandePharmacieWhereInput[]
    commandeId?: StringFilter<"LigneCommandePharmacie"> | string
    medicamentId?: StringFilter<"LigneCommandePharmacie"> | string
    quantiteCommandee?: IntFilter<"LigneCommandePharmacie"> | number
    quantiteRecue?: IntFilter<"LigneCommandePharmacie"> | number
    prixUnitaire?: DecimalFilter<"LigneCommandePharmacie"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneCommandePharmacie"> | Date | string
    commande?: XOR<CommandePharmacieScalarRelationFilter, CommandePharmacieWhereInput>
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }, "id">

  export type LigneCommandePharmacieOrderByWithAggregationInput = {
    id?: SortOrder
    commandeId?: SortOrder
    medicamentId?: SortOrder
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    createdAt?: SortOrder
    _count?: LigneCommandePharmacieCountOrderByAggregateInput
    _avg?: LigneCommandePharmacieAvgOrderByAggregateInput
    _max?: LigneCommandePharmacieMaxOrderByAggregateInput
    _min?: LigneCommandePharmacieMinOrderByAggregateInput
    _sum?: LigneCommandePharmacieSumOrderByAggregateInput
  }

  export type LigneCommandePharmacieScalarWhereWithAggregatesInput = {
    AND?: LigneCommandePharmacieScalarWhereWithAggregatesInput | LigneCommandePharmacieScalarWhereWithAggregatesInput[]
    OR?: LigneCommandePharmacieScalarWhereWithAggregatesInput[]
    NOT?: LigneCommandePharmacieScalarWhereWithAggregatesInput | LigneCommandePharmacieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneCommandePharmacie"> | string
    commandeId?: StringWithAggregatesFilter<"LigneCommandePharmacie"> | string
    medicamentId?: StringWithAggregatesFilter<"LigneCommandePharmacie"> | string
    quantiteCommandee?: IntWithAggregatesFilter<"LigneCommandePharmacie"> | number
    quantiteRecue?: IntWithAggregatesFilter<"LigneCommandePharmacie"> | number
    prixUnitaire?: DecimalWithAggregatesFilter<"LigneCommandePharmacie"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"LigneCommandePharmacie"> | Date | string
  }

  export type StockWhereInput = {
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    id?: StringFilter<"Stock"> | string
    medicamentId?: StringFilter<"Stock"> | string
    lot?: StringFilter<"Stock"> | string
    datePeremption?: DateTimeFilter<"Stock"> | Date | string
    quantite?: IntFilter<"Stock"> | number
    emplacement?: StringNullableFilter<"Stock"> | string | null
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }

  export type StockOrderByWithRelationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    lot?: SortOrder
    datePeremption?: SortOrder
    quantite?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicament?: MedicamentOrderByWithRelationInput
  }

  export type StockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockWhereInput | StockWhereInput[]
    OR?: StockWhereInput[]
    NOT?: StockWhereInput | StockWhereInput[]
    medicamentId?: StringFilter<"Stock"> | string
    lot?: StringFilter<"Stock"> | string
    datePeremption?: DateTimeFilter<"Stock"> | Date | string
    quantite?: IntFilter<"Stock"> | number
    emplacement?: StringNullableFilter<"Stock"> | string | null
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }, "id">

  export type StockOrderByWithAggregationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    lot?: SortOrder
    datePeremption?: SortOrder
    quantite?: SortOrder
    emplacement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockCountOrderByAggregateInput
    _avg?: StockAvgOrderByAggregateInput
    _max?: StockMaxOrderByAggregateInput
    _min?: StockMinOrderByAggregateInput
    _sum?: StockSumOrderByAggregateInput
  }

  export type StockScalarWhereWithAggregatesInput = {
    AND?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    OR?: StockScalarWhereWithAggregatesInput[]
    NOT?: StockScalarWhereWithAggregatesInput | StockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stock"> | string
    medicamentId?: StringWithAggregatesFilter<"Stock"> | string
    lot?: StringWithAggregatesFilter<"Stock"> | string
    datePeremption?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    quantite?: IntWithAggregatesFilter<"Stock"> | number
    emplacement?: StringNullableWithAggregatesFilter<"Stock"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stock"> | Date | string
  }

  export type MouvementStockWhereInput = {
    AND?: MouvementStockWhereInput | MouvementStockWhereInput[]
    OR?: MouvementStockWhereInput[]
    NOT?: MouvementStockWhereInput | MouvementStockWhereInput[]
    id?: StringFilter<"MouvementStock"> | string
    medicamentId?: StringFilter<"MouvementStock"> | string
    type?: StringFilter<"MouvementStock"> | string
    quantite?: IntFilter<"MouvementStock"> | number
    motif?: StringFilter<"MouvementStock"> | string
    reference?: StringNullableFilter<"MouvementStock"> | string | null
    utilisateur?: StringFilter<"MouvementStock"> | string
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }

  export type MouvementStockOrderByWithRelationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    motif?: SortOrder
    reference?: SortOrderInput | SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
    medicament?: MedicamentOrderByWithRelationInput
  }

  export type MouvementStockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MouvementStockWhereInput | MouvementStockWhereInput[]
    OR?: MouvementStockWhereInput[]
    NOT?: MouvementStockWhereInput | MouvementStockWhereInput[]
    medicamentId?: StringFilter<"MouvementStock"> | string
    type?: StringFilter<"MouvementStock"> | string
    quantite?: IntFilter<"MouvementStock"> | number
    motif?: StringFilter<"MouvementStock"> | string
    reference?: StringNullableFilter<"MouvementStock"> | string | null
    utilisateur?: StringFilter<"MouvementStock"> | string
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
  }, "id">

  export type MouvementStockOrderByWithAggregationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    motif?: SortOrder
    reference?: SortOrderInput | SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
    _count?: MouvementStockCountOrderByAggregateInput
    _avg?: MouvementStockAvgOrderByAggregateInput
    _max?: MouvementStockMaxOrderByAggregateInput
    _min?: MouvementStockMinOrderByAggregateInput
    _sum?: MouvementStockSumOrderByAggregateInput
  }

  export type MouvementStockScalarWhereWithAggregatesInput = {
    AND?: MouvementStockScalarWhereWithAggregatesInput | MouvementStockScalarWhereWithAggregatesInput[]
    OR?: MouvementStockScalarWhereWithAggregatesInput[]
    NOT?: MouvementStockScalarWhereWithAggregatesInput | MouvementStockScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MouvementStock"> | string
    medicamentId?: StringWithAggregatesFilter<"MouvementStock"> | string
    type?: StringWithAggregatesFilter<"MouvementStock"> | string
    quantite?: IntWithAggregatesFilter<"MouvementStock"> | number
    motif?: StringWithAggregatesFilter<"MouvementStock"> | string
    reference?: StringNullableWithAggregatesFilter<"MouvementStock"> | string | null
    utilisateur?: StringWithAggregatesFilter<"MouvementStock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MouvementStock"> | Date | string
  }

  export type DispensationWhereInput = {
    AND?: DispensationWhereInput | DispensationWhereInput[]
    OR?: DispensationWhereInput[]
    NOT?: DispensationWhereInput | DispensationWhereInput[]
    id?: StringFilter<"Dispensation"> | string
    medicamentId?: StringFilter<"Dispensation"> | string
    patientId?: StringFilter<"Dispensation"> | string
    quantite?: IntFilter<"Dispensation"> | number
    prescription?: StringNullableFilter<"Dispensation"> | string | null
    pharmacien?: StringFilter<"Dispensation"> | string
    createdAt?: DateTimeFilter<"Dispensation"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type DispensationOrderByWithRelationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    patientId?: SortOrder
    quantite?: SortOrder
    prescription?: SortOrderInput | SortOrder
    pharmacien?: SortOrder
    createdAt?: SortOrder
    medicament?: MedicamentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type DispensationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DispensationWhereInput | DispensationWhereInput[]
    OR?: DispensationWhereInput[]
    NOT?: DispensationWhereInput | DispensationWhereInput[]
    medicamentId?: StringFilter<"Dispensation"> | string
    patientId?: StringFilter<"Dispensation"> | string
    quantite?: IntFilter<"Dispensation"> | number
    prescription?: StringNullableFilter<"Dispensation"> | string | null
    pharmacien?: StringFilter<"Dispensation"> | string
    createdAt?: DateTimeFilter<"Dispensation"> | Date | string
    medicament?: XOR<MedicamentScalarRelationFilter, MedicamentWhereInput>
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type DispensationOrderByWithAggregationInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    patientId?: SortOrder
    quantite?: SortOrder
    prescription?: SortOrderInput | SortOrder
    pharmacien?: SortOrder
    createdAt?: SortOrder
    _count?: DispensationCountOrderByAggregateInput
    _avg?: DispensationAvgOrderByAggregateInput
    _max?: DispensationMaxOrderByAggregateInput
    _min?: DispensationMinOrderByAggregateInput
    _sum?: DispensationSumOrderByAggregateInput
  }

  export type DispensationScalarWhereWithAggregatesInput = {
    AND?: DispensationScalarWhereWithAggregatesInput | DispensationScalarWhereWithAggregatesInput[]
    OR?: DispensationScalarWhereWithAggregatesInput[]
    NOT?: DispensationScalarWhereWithAggregatesInput | DispensationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dispensation"> | string
    medicamentId?: StringWithAggregatesFilter<"Dispensation"> | string
    patientId?: StringWithAggregatesFilter<"Dispensation"> | string
    quantite?: IntWithAggregatesFilter<"Dispensation"> | number
    prescription?: StringNullableWithAggregatesFilter<"Dispensation"> | string | null
    pharmacien?: StringWithAggregatesFilter<"Dispensation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Dispensation"> | Date | string
  }

  export type FactureWhereInput = {
    AND?: FactureWhereInput | FactureWhereInput[]
    OR?: FactureWhereInput[]
    NOT?: FactureWhereInput | FactureWhereInput[]
    id?: StringFilter<"Facture"> | string
    numeroFacture?: StringFilter<"Facture"> | string
    patientId?: StringFilter<"Facture"> | string
    dateFacture?: DateTimeFilter<"Facture"> | Date | string
    dateEcheance?: DateTimeFilter<"Facture"> | Date | string
    montantHT?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"Facture"> | string
    ecritureComptableId?: StringNullableFilter<"Facture"> | string | null
    createdAt?: DateTimeFilter<"Facture"> | Date | string
    updatedAt?: DateTimeFilter<"Facture"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lignes?: LigneFactureListRelationFilter
    paiements?: PaiementListRelationFilter
    consultations?: ConsultationListRelationFilter
  }

  export type FactureOrderByWithRelationInput = {
    id?: SortOrder
    numeroFacture?: SortOrder
    patientId?: SortOrder
    dateFacture?: SortOrder
    dateEcheance?: SortOrder
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
    statut?: SortOrder
    ecritureComptableId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    lignes?: LigneFactureOrderByRelationAggregateInput
    paiements?: PaiementOrderByRelationAggregateInput
    consultations?: ConsultationOrderByRelationAggregateInput
  }

  export type FactureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroFacture?: string
    AND?: FactureWhereInput | FactureWhereInput[]
    OR?: FactureWhereInput[]
    NOT?: FactureWhereInput | FactureWhereInput[]
    patientId?: StringFilter<"Facture"> | string
    dateFacture?: DateTimeFilter<"Facture"> | Date | string
    dateEcheance?: DateTimeFilter<"Facture"> | Date | string
    montantHT?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"Facture"> | string
    ecritureComptableId?: StringNullableFilter<"Facture"> | string | null
    createdAt?: DateTimeFilter<"Facture"> | Date | string
    updatedAt?: DateTimeFilter<"Facture"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lignes?: LigneFactureListRelationFilter
    paiements?: PaiementListRelationFilter
    consultations?: ConsultationListRelationFilter
  }, "id" | "numeroFacture">

  export type FactureOrderByWithAggregationInput = {
    id?: SortOrder
    numeroFacture?: SortOrder
    patientId?: SortOrder
    dateFacture?: SortOrder
    dateEcheance?: SortOrder
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
    statut?: SortOrder
    ecritureComptableId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FactureCountOrderByAggregateInput
    _avg?: FactureAvgOrderByAggregateInput
    _max?: FactureMaxOrderByAggregateInput
    _min?: FactureMinOrderByAggregateInput
    _sum?: FactureSumOrderByAggregateInput
  }

  export type FactureScalarWhereWithAggregatesInput = {
    AND?: FactureScalarWhereWithAggregatesInput | FactureScalarWhereWithAggregatesInput[]
    OR?: FactureScalarWhereWithAggregatesInput[]
    NOT?: FactureScalarWhereWithAggregatesInput | FactureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Facture"> | string
    numeroFacture?: StringWithAggregatesFilter<"Facture"> | string
    patientId?: StringWithAggregatesFilter<"Facture"> | string
    dateFacture?: DateTimeWithAggregatesFilter<"Facture"> | Date | string
    dateEcheance?: DateTimeWithAggregatesFilter<"Facture"> | Date | string
    montantHT?: DecimalWithAggregatesFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalWithAggregatesFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalWithAggregatesFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalWithAggregatesFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalWithAggregatesFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    statut?: StringWithAggregatesFilter<"Facture"> | string
    ecritureComptableId?: StringNullableWithAggregatesFilter<"Facture"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Facture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Facture"> | Date | string
  }

  export type LigneFactureWhereInput = {
    AND?: LigneFactureWhereInput | LigneFactureWhereInput[]
    OR?: LigneFactureWhereInput[]
    NOT?: LigneFactureWhereInput | LigneFactureWhereInput[]
    id?: StringFilter<"LigneFacture"> | string
    factureId?: StringFilter<"LigneFacture"> | string
    designation?: StringFilter<"LigneFacture"> | string
    quantite?: IntFilter<"LigneFacture"> | number
    prixUnitaire?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneFacture"> | Date | string
    facture?: XOR<FactureScalarRelationFilter, FactureWhereInput>
  }

  export type LigneFactureOrderByWithRelationInput = {
    id?: SortOrder
    factureId?: SortOrder
    designation?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
    createdAt?: SortOrder
    facture?: FactureOrderByWithRelationInput
  }

  export type LigneFactureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LigneFactureWhereInput | LigneFactureWhereInput[]
    OR?: LigneFactureWhereInput[]
    NOT?: LigneFactureWhereInput | LigneFactureWhereInput[]
    factureId?: StringFilter<"LigneFacture"> | string
    designation?: StringFilter<"LigneFacture"> | string
    quantite?: IntFilter<"LigneFacture"> | number
    prixUnitaire?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneFacture"> | Date | string
    facture?: XOR<FactureScalarRelationFilter, FactureWhereInput>
  }, "id">

  export type LigneFactureOrderByWithAggregationInput = {
    id?: SortOrder
    factureId?: SortOrder
    designation?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
    createdAt?: SortOrder
    _count?: LigneFactureCountOrderByAggregateInput
    _avg?: LigneFactureAvgOrderByAggregateInput
    _max?: LigneFactureMaxOrderByAggregateInput
    _min?: LigneFactureMinOrderByAggregateInput
    _sum?: LigneFactureSumOrderByAggregateInput
  }

  export type LigneFactureScalarWhereWithAggregatesInput = {
    AND?: LigneFactureScalarWhereWithAggregatesInput | LigneFactureScalarWhereWithAggregatesInput[]
    OR?: LigneFactureScalarWhereWithAggregatesInput[]
    NOT?: LigneFactureScalarWhereWithAggregatesInput | LigneFactureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneFacture"> | string
    factureId?: StringWithAggregatesFilter<"LigneFacture"> | string
    designation?: StringWithAggregatesFilter<"LigneFacture"> | string
    quantite?: IntWithAggregatesFilter<"LigneFacture"> | number
    prixUnitaire?: DecimalWithAggregatesFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalWithAggregatesFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"LigneFacture"> | Date | string
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: StringFilter<"Paiement"> | string
    factureId?: StringFilter<"Paiement"> | string
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    montant?: DecimalFilter<"Paiement"> | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFilter<"Paiement"> | string
    reference?: StringNullableFilter<"Paiement"> | string | null
    notes?: StringNullableFilter<"Paiement"> | string | null
    createdById?: StringFilter<"Paiement"> | string
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    facture?: XOR<FactureScalarRelationFilter, FactureWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    factureId?: SortOrder
    datePaiement?: SortOrder
    montant?: SortOrder
    modePaiement?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    facture?: FactureOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    factureId?: StringFilter<"Paiement"> | string
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    montant?: DecimalFilter<"Paiement"> | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFilter<"Paiement"> | string
    reference?: StringNullableFilter<"Paiement"> | string | null
    notes?: StringNullableFilter<"Paiement"> | string | null
    createdById?: StringFilter<"Paiement"> | string
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    facture?: XOR<FactureScalarRelationFilter, FactureWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    factureId?: SortOrder
    datePaiement?: SortOrder
    montant?: SortOrder
    modePaiement?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Paiement"> | string
    factureId?: StringWithAggregatesFilter<"Paiement"> | string
    datePaiement?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    montant?: DecimalWithAggregatesFilter<"Paiement"> | Decimal | DecimalJsLike | number | string
    modePaiement?: StringWithAggregatesFilter<"Paiement"> | string
    reference?: StringNullableWithAggregatesFilter<"Paiement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Paiement"> | string | null
    createdById?: StringWithAggregatesFilter<"Paiement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
  }

  export type LitWhereInput = {
    AND?: LitWhereInput | LitWhereInput[]
    OR?: LitWhereInput[]
    NOT?: LitWhereInput | LitWhereInput[]
    id?: StringFilter<"Lit"> | string
    numero?: StringFilter<"Lit"> | string
    chambre?: StringFilter<"Lit"> | string
    service?: StringFilter<"Lit"> | string
    categorie?: StringFilter<"Lit"> | string
    prixJournalier?: DecimalFilter<"Lit"> | Decimal | DecimalJsLike | number | string
    occupe?: BoolFilter<"Lit"> | boolean
    createdAt?: DateTimeFilter<"Lit"> | Date | string
    hospitalisations?: HospitalisationListRelationFilter
  }

  export type LitOrderByWithRelationInput = {
    id?: SortOrder
    numero?: SortOrder
    chambre?: SortOrder
    service?: SortOrder
    categorie?: SortOrder
    prixJournalier?: SortOrder
    occupe?: SortOrder
    createdAt?: SortOrder
    hospitalisations?: HospitalisationOrderByRelationAggregateInput
  }

  export type LitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numero?: string
    AND?: LitWhereInput | LitWhereInput[]
    OR?: LitWhereInput[]
    NOT?: LitWhereInput | LitWhereInput[]
    chambre?: StringFilter<"Lit"> | string
    service?: StringFilter<"Lit"> | string
    categorie?: StringFilter<"Lit"> | string
    prixJournalier?: DecimalFilter<"Lit"> | Decimal | DecimalJsLike | number | string
    occupe?: BoolFilter<"Lit"> | boolean
    createdAt?: DateTimeFilter<"Lit"> | Date | string
    hospitalisations?: HospitalisationListRelationFilter
  }, "id" | "numero">

  export type LitOrderByWithAggregationInput = {
    id?: SortOrder
    numero?: SortOrder
    chambre?: SortOrder
    service?: SortOrder
    categorie?: SortOrder
    prixJournalier?: SortOrder
    occupe?: SortOrder
    createdAt?: SortOrder
    _count?: LitCountOrderByAggregateInput
    _avg?: LitAvgOrderByAggregateInput
    _max?: LitMaxOrderByAggregateInput
    _min?: LitMinOrderByAggregateInput
    _sum?: LitSumOrderByAggregateInput
  }

  export type LitScalarWhereWithAggregatesInput = {
    AND?: LitScalarWhereWithAggregatesInput | LitScalarWhereWithAggregatesInput[]
    OR?: LitScalarWhereWithAggregatesInput[]
    NOT?: LitScalarWhereWithAggregatesInput | LitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lit"> | string
    numero?: StringWithAggregatesFilter<"Lit"> | string
    chambre?: StringWithAggregatesFilter<"Lit"> | string
    service?: StringWithAggregatesFilter<"Lit"> | string
    categorie?: StringWithAggregatesFilter<"Lit"> | string
    prixJournalier?: DecimalWithAggregatesFilter<"Lit"> | Decimal | DecimalJsLike | number | string
    occupe?: BoolWithAggregatesFilter<"Lit"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lit"> | Date | string
  }

  export type HospitalisationWhereInput = {
    AND?: HospitalisationWhereInput | HospitalisationWhereInput[]
    OR?: HospitalisationWhereInput[]
    NOT?: HospitalisationWhereInput | HospitalisationWhereInput[]
    id?: StringFilter<"Hospitalisation"> | string
    patientId?: StringFilter<"Hospitalisation"> | string
    litId?: StringFilter<"Hospitalisation"> | string
    dateEntree?: DateTimeFilter<"Hospitalisation"> | Date | string
    dateSortie?: DateTimeNullableFilter<"Hospitalisation"> | Date | string | null
    motif?: StringFilter<"Hospitalisation"> | string
    diagnosticEntree?: StringNullableFilter<"Hospitalisation"> | string | null
    diagnosticSortie?: StringNullableFilter<"Hospitalisation"> | string | null
    statut?: StringFilter<"Hospitalisation"> | string
    createdAt?: DateTimeFilter<"Hospitalisation"> | Date | string
    updatedAt?: DateTimeFilter<"Hospitalisation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lit?: XOR<LitScalarRelationFilter, LitWhereInput>
    observations?: ObservationInfirmierListRelationFilter
  }

  export type HospitalisationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    litId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrderInput | SortOrder
    motif?: SortOrder
    diagnosticEntree?: SortOrderInput | SortOrder
    diagnosticSortie?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    lit?: LitOrderByWithRelationInput
    observations?: ObservationInfirmierOrderByRelationAggregateInput
  }

  export type HospitalisationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HospitalisationWhereInput | HospitalisationWhereInput[]
    OR?: HospitalisationWhereInput[]
    NOT?: HospitalisationWhereInput | HospitalisationWhereInput[]
    patientId?: StringFilter<"Hospitalisation"> | string
    litId?: StringFilter<"Hospitalisation"> | string
    dateEntree?: DateTimeFilter<"Hospitalisation"> | Date | string
    dateSortie?: DateTimeNullableFilter<"Hospitalisation"> | Date | string | null
    motif?: StringFilter<"Hospitalisation"> | string
    diagnosticEntree?: StringNullableFilter<"Hospitalisation"> | string | null
    diagnosticSortie?: StringNullableFilter<"Hospitalisation"> | string | null
    statut?: StringFilter<"Hospitalisation"> | string
    createdAt?: DateTimeFilter<"Hospitalisation"> | Date | string
    updatedAt?: DateTimeFilter<"Hospitalisation"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    lit?: XOR<LitScalarRelationFilter, LitWhereInput>
    observations?: ObservationInfirmierListRelationFilter
  }, "id">

  export type HospitalisationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    litId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrderInput | SortOrder
    motif?: SortOrder
    diagnosticEntree?: SortOrderInput | SortOrder
    diagnosticSortie?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HospitalisationCountOrderByAggregateInput
    _max?: HospitalisationMaxOrderByAggregateInput
    _min?: HospitalisationMinOrderByAggregateInput
  }

  export type HospitalisationScalarWhereWithAggregatesInput = {
    AND?: HospitalisationScalarWhereWithAggregatesInput | HospitalisationScalarWhereWithAggregatesInput[]
    OR?: HospitalisationScalarWhereWithAggregatesInput[]
    NOT?: HospitalisationScalarWhereWithAggregatesInput | HospitalisationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hospitalisation"> | string
    patientId?: StringWithAggregatesFilter<"Hospitalisation"> | string
    litId?: StringWithAggregatesFilter<"Hospitalisation"> | string
    dateEntree?: DateTimeWithAggregatesFilter<"Hospitalisation"> | Date | string
    dateSortie?: DateTimeNullableWithAggregatesFilter<"Hospitalisation"> | Date | string | null
    motif?: StringWithAggregatesFilter<"Hospitalisation"> | string
    diagnosticEntree?: StringNullableWithAggregatesFilter<"Hospitalisation"> | string | null
    diagnosticSortie?: StringNullableWithAggregatesFilter<"Hospitalisation"> | string | null
    statut?: StringWithAggregatesFilter<"Hospitalisation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Hospitalisation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hospitalisation"> | Date | string
  }

  export type ObservationInfirmierWhereInput = {
    AND?: ObservationInfirmierWhereInput | ObservationInfirmierWhereInput[]
    OR?: ObservationInfirmierWhereInput[]
    NOT?: ObservationInfirmierWhereInput | ObservationInfirmierWhereInput[]
    id?: StringFilter<"ObservationInfirmier"> | string
    hospitalisationId?: StringFilter<"ObservationInfirmier"> | string
    infirmierId?: StringFilter<"ObservationInfirmier"> | string
    pressionArterielle?: StringNullableFilter<"ObservationInfirmier"> | string | null
    temperature?: DecimalNullableFilter<"ObservationInfirmier"> | Decimal | DecimalJsLike | number | string | null
    note?: StringFilter<"ObservationInfirmier"> | string
    dateHeure?: DateTimeFilter<"ObservationInfirmier"> | Date | string
    hospitalisation?: XOR<HospitalisationScalarRelationFilter, HospitalisationWhereInput>
    infirmier?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ObservationInfirmierOrderByWithRelationInput = {
    id?: SortOrder
    hospitalisationId?: SortOrder
    infirmierId?: SortOrder
    pressionArterielle?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    note?: SortOrder
    dateHeure?: SortOrder
    hospitalisation?: HospitalisationOrderByWithRelationInput
    infirmier?: UserOrderByWithRelationInput
  }

  export type ObservationInfirmierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObservationInfirmierWhereInput | ObservationInfirmierWhereInput[]
    OR?: ObservationInfirmierWhereInput[]
    NOT?: ObservationInfirmierWhereInput | ObservationInfirmierWhereInput[]
    hospitalisationId?: StringFilter<"ObservationInfirmier"> | string
    infirmierId?: StringFilter<"ObservationInfirmier"> | string
    pressionArterielle?: StringNullableFilter<"ObservationInfirmier"> | string | null
    temperature?: DecimalNullableFilter<"ObservationInfirmier"> | Decimal | DecimalJsLike | number | string | null
    note?: StringFilter<"ObservationInfirmier"> | string
    dateHeure?: DateTimeFilter<"ObservationInfirmier"> | Date | string
    hospitalisation?: XOR<HospitalisationScalarRelationFilter, HospitalisationWhereInput>
    infirmier?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ObservationInfirmierOrderByWithAggregationInput = {
    id?: SortOrder
    hospitalisationId?: SortOrder
    infirmierId?: SortOrder
    pressionArterielle?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    note?: SortOrder
    dateHeure?: SortOrder
    _count?: ObservationInfirmierCountOrderByAggregateInput
    _avg?: ObservationInfirmierAvgOrderByAggregateInput
    _max?: ObservationInfirmierMaxOrderByAggregateInput
    _min?: ObservationInfirmierMinOrderByAggregateInput
    _sum?: ObservationInfirmierSumOrderByAggregateInput
  }

  export type ObservationInfirmierScalarWhereWithAggregatesInput = {
    AND?: ObservationInfirmierScalarWhereWithAggregatesInput | ObservationInfirmierScalarWhereWithAggregatesInput[]
    OR?: ObservationInfirmierScalarWhereWithAggregatesInput[]
    NOT?: ObservationInfirmierScalarWhereWithAggregatesInput | ObservationInfirmierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObservationInfirmier"> | string
    hospitalisationId?: StringWithAggregatesFilter<"ObservationInfirmier"> | string
    infirmierId?: StringWithAggregatesFilter<"ObservationInfirmier"> | string
    pressionArterielle?: StringNullableWithAggregatesFilter<"ObservationInfirmier"> | string | null
    temperature?: DecimalNullableWithAggregatesFilter<"ObservationInfirmier"> | Decimal | DecimalJsLike | number | string | null
    note?: StringWithAggregatesFilter<"ObservationInfirmier"> | string
    dateHeure?: DateTimeWithAggregatesFilter<"ObservationInfirmier"> | Date | string
  }

  export type InterventionWhereInput = {
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    id?: StringFilter<"Intervention"> | string
    patientId?: StringFilter<"Intervention"> | string
    chirurgienId?: StringFilter<"Intervention"> | string
    anesthesisteId?: StringNullableFilter<"Intervention"> | string | null
    typeIntervention?: StringFilter<"Intervention"> | string
    dateHeure?: DateTimeFilter<"Intervention"> | Date | string
    salle?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    protocoleOp?: StringNullableFilter<"Intervention"> | string | null
    typeAnesthesie?: StringNullableFilter<"Intervention"> | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    chirurgien?: XOR<UserScalarRelationFilter, UserWhereInput>
    anesthesiste?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InterventionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    chirurgienId?: SortOrder
    anesthesisteId?: SortOrderInput | SortOrder
    typeIntervention?: SortOrder
    dateHeure?: SortOrder
    salle?: SortOrder
    statut?: SortOrder
    protocoleOp?: SortOrderInput | SortOrder
    typeAnesthesie?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    chirurgien?: UserOrderByWithRelationInput
    anesthesiste?: UserOrderByWithRelationInput
  }

  export type InterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    patientId?: StringFilter<"Intervention"> | string
    chirurgienId?: StringFilter<"Intervention"> | string
    anesthesisteId?: StringNullableFilter<"Intervention"> | string | null
    typeIntervention?: StringFilter<"Intervention"> | string
    dateHeure?: DateTimeFilter<"Intervention"> | Date | string
    salle?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    protocoleOp?: StringNullableFilter<"Intervention"> | string | null
    typeAnesthesie?: StringNullableFilter<"Intervention"> | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    chirurgien?: XOR<UserScalarRelationFilter, UserWhereInput>
    anesthesiste?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InterventionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    chirurgienId?: SortOrder
    anesthesisteId?: SortOrderInput | SortOrder
    typeIntervention?: SortOrder
    dateHeure?: SortOrder
    salle?: SortOrder
    statut?: SortOrder
    protocoleOp?: SortOrderInput | SortOrder
    typeAnesthesie?: SortOrderInput | SortOrder
    duree?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InterventionCountOrderByAggregateInput
    _avg?: InterventionAvgOrderByAggregateInput
    _max?: InterventionMaxOrderByAggregateInput
    _min?: InterventionMinOrderByAggregateInput
    _sum?: InterventionSumOrderByAggregateInput
  }

  export type InterventionScalarWhereWithAggregatesInput = {
    AND?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    OR?: InterventionScalarWhereWithAggregatesInput[]
    NOT?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Intervention"> | string
    patientId?: StringWithAggregatesFilter<"Intervention"> | string
    chirurgienId?: StringWithAggregatesFilter<"Intervention"> | string
    anesthesisteId?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    typeIntervention?: StringWithAggregatesFilter<"Intervention"> | string
    dateHeure?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
    salle?: StringWithAggregatesFilter<"Intervention"> | string
    statut?: StringWithAggregatesFilter<"Intervention"> | string
    protocoleOp?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    typeAnesthesie?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    duree?: IntNullableWithAggregatesFilter<"Intervention"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Intervention"> | Date | string
  }

  export type DossierMaterniteWhereInput = {
    AND?: DossierMaterniteWhereInput | DossierMaterniteWhereInput[]
    OR?: DossierMaterniteWhereInput[]
    NOT?: DossierMaterniteWhereInput | DossierMaterniteWhereInput[]
    id?: StringFilter<"DossierMaternite"> | string
    patientId?: StringFilter<"DossierMaternite"> | string
    dateDebutGrossesse?: DateTimeFilter<"DossierMaternite"> | Date | string
    parite?: IntFilter<"DossierMaternite"> | number
    gestite?: IntFilter<"DossierMaternite"> | number
    groupageRhesus?: StringFilter<"DossierMaternite"> | string
    examensPrenataux?: JsonNullableFilter<"DossierMaternite">
    accouchement?: JsonNullableFilter<"DossierMaternite">
    createdAt?: DateTimeFilter<"DossierMaternite"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nouveauNes?: NouveauNeListRelationFilter
  }

  export type DossierMaterniteOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    dateDebutGrossesse?: SortOrder
    parite?: SortOrder
    gestite?: SortOrder
    groupageRhesus?: SortOrder
    examensPrenataux?: SortOrderInput | SortOrder
    accouchement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    nouveauNes?: NouveauNeOrderByRelationAggregateInput
  }

  export type DossierMaterniteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DossierMaterniteWhereInput | DossierMaterniteWhereInput[]
    OR?: DossierMaterniteWhereInput[]
    NOT?: DossierMaterniteWhereInput | DossierMaterniteWhereInput[]
    patientId?: StringFilter<"DossierMaternite"> | string
    dateDebutGrossesse?: DateTimeFilter<"DossierMaternite"> | Date | string
    parite?: IntFilter<"DossierMaternite"> | number
    gestite?: IntFilter<"DossierMaternite"> | number
    groupageRhesus?: StringFilter<"DossierMaternite"> | string
    examensPrenataux?: JsonNullableFilter<"DossierMaternite">
    accouchement?: JsonNullableFilter<"DossierMaternite">
    createdAt?: DateTimeFilter<"DossierMaternite"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    nouveauNes?: NouveauNeListRelationFilter
  }, "id">

  export type DossierMaterniteOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    dateDebutGrossesse?: SortOrder
    parite?: SortOrder
    gestite?: SortOrder
    groupageRhesus?: SortOrder
    examensPrenataux?: SortOrderInput | SortOrder
    accouchement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DossierMaterniteCountOrderByAggregateInput
    _avg?: DossierMaterniteAvgOrderByAggregateInput
    _max?: DossierMaterniteMaxOrderByAggregateInput
    _min?: DossierMaterniteMinOrderByAggregateInput
    _sum?: DossierMaterniteSumOrderByAggregateInput
  }

  export type DossierMaterniteScalarWhereWithAggregatesInput = {
    AND?: DossierMaterniteScalarWhereWithAggregatesInput | DossierMaterniteScalarWhereWithAggregatesInput[]
    OR?: DossierMaterniteScalarWhereWithAggregatesInput[]
    NOT?: DossierMaterniteScalarWhereWithAggregatesInput | DossierMaterniteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DossierMaternite"> | string
    patientId?: StringWithAggregatesFilter<"DossierMaternite"> | string
    dateDebutGrossesse?: DateTimeWithAggregatesFilter<"DossierMaternite"> | Date | string
    parite?: IntWithAggregatesFilter<"DossierMaternite"> | number
    gestite?: IntWithAggregatesFilter<"DossierMaternite"> | number
    groupageRhesus?: StringWithAggregatesFilter<"DossierMaternite"> | string
    examensPrenataux?: JsonNullableWithAggregatesFilter<"DossierMaternite">
    accouchement?: JsonNullableWithAggregatesFilter<"DossierMaternite">
    createdAt?: DateTimeWithAggregatesFilter<"DossierMaternite"> | Date | string
  }

  export type NouveauNeWhereInput = {
    AND?: NouveauNeWhereInput | NouveauNeWhereInput[]
    OR?: NouveauNeWhereInput[]
    NOT?: NouveauNeWhereInput | NouveauNeWhereInput[]
    id?: StringFilter<"NouveauNe"> | string
    dossierMaterniteId?: StringFilter<"NouveauNe"> | string
    nom?: StringFilter<"NouveauNe"> | string
    prenom?: StringFilter<"NouveauNe"> | string
    dateHeureNaissance?: DateTimeFilter<"NouveauNe"> | Date | string
    sexe?: StringFilter<"NouveauNe"> | string
    poids?: DecimalFilter<"NouveauNe"> | Decimal | DecimalJsLike | number | string
    scoreApgar?: IntNullableFilter<"NouveauNe"> | number | null
    createdAt?: DateTimeFilter<"NouveauNe"> | Date | string
    dossierMaternite?: XOR<DossierMaterniteScalarRelationFilter, DossierMaterniteWhereInput>
  }

  export type NouveauNeOrderByWithRelationInput = {
    id?: SortOrder
    dossierMaterniteId?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateHeureNaissance?: SortOrder
    sexe?: SortOrder
    poids?: SortOrder
    scoreApgar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    dossierMaternite?: DossierMaterniteOrderByWithRelationInput
  }

  export type NouveauNeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NouveauNeWhereInput | NouveauNeWhereInput[]
    OR?: NouveauNeWhereInput[]
    NOT?: NouveauNeWhereInput | NouveauNeWhereInput[]
    dossierMaterniteId?: StringFilter<"NouveauNe"> | string
    nom?: StringFilter<"NouveauNe"> | string
    prenom?: StringFilter<"NouveauNe"> | string
    dateHeureNaissance?: DateTimeFilter<"NouveauNe"> | Date | string
    sexe?: StringFilter<"NouveauNe"> | string
    poids?: DecimalFilter<"NouveauNe"> | Decimal | DecimalJsLike | number | string
    scoreApgar?: IntNullableFilter<"NouveauNe"> | number | null
    createdAt?: DateTimeFilter<"NouveauNe"> | Date | string
    dossierMaternite?: XOR<DossierMaterniteScalarRelationFilter, DossierMaterniteWhereInput>
  }, "id">

  export type NouveauNeOrderByWithAggregationInput = {
    id?: SortOrder
    dossierMaterniteId?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateHeureNaissance?: SortOrder
    sexe?: SortOrder
    poids?: SortOrder
    scoreApgar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NouveauNeCountOrderByAggregateInput
    _avg?: NouveauNeAvgOrderByAggregateInput
    _max?: NouveauNeMaxOrderByAggregateInput
    _min?: NouveauNeMinOrderByAggregateInput
    _sum?: NouveauNeSumOrderByAggregateInput
  }

  export type NouveauNeScalarWhereWithAggregatesInput = {
    AND?: NouveauNeScalarWhereWithAggregatesInput | NouveauNeScalarWhereWithAggregatesInput[]
    OR?: NouveauNeScalarWhereWithAggregatesInput[]
    NOT?: NouveauNeScalarWhereWithAggregatesInput | NouveauNeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NouveauNe"> | string
    dossierMaterniteId?: StringWithAggregatesFilter<"NouveauNe"> | string
    nom?: StringWithAggregatesFilter<"NouveauNe"> | string
    prenom?: StringWithAggregatesFilter<"NouveauNe"> | string
    dateHeureNaissance?: DateTimeWithAggregatesFilter<"NouveauNe"> | Date | string
    sexe?: StringWithAggregatesFilter<"NouveauNe"> | string
    poids?: DecimalWithAggregatesFilter<"NouveauNe"> | Decimal | DecimalJsLike | number | string
    scoreApgar?: IntNullableWithAggregatesFilter<"NouveauNe"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"NouveauNe"> | Date | string
  }

  export type ArticleLogistiqueWhereInput = {
    AND?: ArticleLogistiqueWhereInput | ArticleLogistiqueWhereInput[]
    OR?: ArticleLogistiqueWhereInput[]
    NOT?: ArticleLogistiqueWhereInput | ArticleLogistiqueWhereInput[]
    id?: StringFilter<"ArticleLogistique"> | string
    designation?: StringFilter<"ArticleLogistique"> | string
    categorie?: StringFilter<"ArticleLogistique"> | string
    famille?: StringNullableFilter<"ArticleLogistique"> | string | null
    uniteMesure?: StringFilter<"ArticleLogistique"> | string
    stockAlerte?: IntFilter<"ArticleLogistique"> | number
    stockActuel?: IntFilter<"ArticleLogistique"> | number
    createdAt?: DateTimeFilter<"ArticleLogistique"> | Date | string
    mouvements?: MouvementLogistiqueListRelationFilter
  }

  export type ArticleLogistiqueOrderByWithRelationInput = {
    id?: SortOrder
    designation?: SortOrder
    categorie?: SortOrder
    famille?: SortOrderInput | SortOrder
    uniteMesure?: SortOrder
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
    createdAt?: SortOrder
    mouvements?: MouvementLogistiqueOrderByRelationAggregateInput
  }

  export type ArticleLogistiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArticleLogistiqueWhereInput | ArticleLogistiqueWhereInput[]
    OR?: ArticleLogistiqueWhereInput[]
    NOT?: ArticleLogistiqueWhereInput | ArticleLogistiqueWhereInput[]
    designation?: StringFilter<"ArticleLogistique"> | string
    categorie?: StringFilter<"ArticleLogistique"> | string
    famille?: StringNullableFilter<"ArticleLogistique"> | string | null
    uniteMesure?: StringFilter<"ArticleLogistique"> | string
    stockAlerte?: IntFilter<"ArticleLogistique"> | number
    stockActuel?: IntFilter<"ArticleLogistique"> | number
    createdAt?: DateTimeFilter<"ArticleLogistique"> | Date | string
    mouvements?: MouvementLogistiqueListRelationFilter
  }, "id">

  export type ArticleLogistiqueOrderByWithAggregationInput = {
    id?: SortOrder
    designation?: SortOrder
    categorie?: SortOrder
    famille?: SortOrderInput | SortOrder
    uniteMesure?: SortOrder
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
    createdAt?: SortOrder
    _count?: ArticleLogistiqueCountOrderByAggregateInput
    _avg?: ArticleLogistiqueAvgOrderByAggregateInput
    _max?: ArticleLogistiqueMaxOrderByAggregateInput
    _min?: ArticleLogistiqueMinOrderByAggregateInput
    _sum?: ArticleLogistiqueSumOrderByAggregateInput
  }

  export type ArticleLogistiqueScalarWhereWithAggregatesInput = {
    AND?: ArticleLogistiqueScalarWhereWithAggregatesInput | ArticleLogistiqueScalarWhereWithAggregatesInput[]
    OR?: ArticleLogistiqueScalarWhereWithAggregatesInput[]
    NOT?: ArticleLogistiqueScalarWhereWithAggregatesInput | ArticleLogistiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArticleLogistique"> | string
    designation?: StringWithAggregatesFilter<"ArticleLogistique"> | string
    categorie?: StringWithAggregatesFilter<"ArticleLogistique"> | string
    famille?: StringNullableWithAggregatesFilter<"ArticleLogistique"> | string | null
    uniteMesure?: StringWithAggregatesFilter<"ArticleLogistique"> | string
    stockAlerte?: IntWithAggregatesFilter<"ArticleLogistique"> | number
    stockActuel?: IntWithAggregatesFilter<"ArticleLogistique"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ArticleLogistique"> | Date | string
  }

  export type MouvementLogistiqueWhereInput = {
    AND?: MouvementLogistiqueWhereInput | MouvementLogistiqueWhereInput[]
    OR?: MouvementLogistiqueWhereInput[]
    NOT?: MouvementLogistiqueWhereInput | MouvementLogistiqueWhereInput[]
    id?: StringFilter<"MouvementLogistique"> | string
    articleId?: StringFilter<"MouvementLogistique"> | string
    type?: StringFilter<"MouvementLogistique"> | string
    quantite?: IntFilter<"MouvementLogistique"> | number
    serviceDestinataire?: StringNullableFilter<"MouvementLogistique"> | string | null
    motif?: StringNullableFilter<"MouvementLogistique"> | string | null
    utilisateur?: StringFilter<"MouvementLogistique"> | string
    createdAt?: DateTimeFilter<"MouvementLogistique"> | Date | string
    article?: XOR<ArticleLogistiqueScalarRelationFilter, ArticleLogistiqueWhereInput>
  }

  export type MouvementLogistiqueOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    serviceDestinataire?: SortOrderInput | SortOrder
    motif?: SortOrderInput | SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
    article?: ArticleLogistiqueOrderByWithRelationInput
  }

  export type MouvementLogistiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MouvementLogistiqueWhereInput | MouvementLogistiqueWhereInput[]
    OR?: MouvementLogistiqueWhereInput[]
    NOT?: MouvementLogistiqueWhereInput | MouvementLogistiqueWhereInput[]
    articleId?: StringFilter<"MouvementLogistique"> | string
    type?: StringFilter<"MouvementLogistique"> | string
    quantite?: IntFilter<"MouvementLogistique"> | number
    serviceDestinataire?: StringNullableFilter<"MouvementLogistique"> | string | null
    motif?: StringNullableFilter<"MouvementLogistique"> | string | null
    utilisateur?: StringFilter<"MouvementLogistique"> | string
    createdAt?: DateTimeFilter<"MouvementLogistique"> | Date | string
    article?: XOR<ArticleLogistiqueScalarRelationFilter, ArticleLogistiqueWhereInput>
  }, "id">

  export type MouvementLogistiqueOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    serviceDestinataire?: SortOrderInput | SortOrder
    motif?: SortOrderInput | SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
    _count?: MouvementLogistiqueCountOrderByAggregateInput
    _avg?: MouvementLogistiqueAvgOrderByAggregateInput
    _max?: MouvementLogistiqueMaxOrderByAggregateInput
    _min?: MouvementLogistiqueMinOrderByAggregateInput
    _sum?: MouvementLogistiqueSumOrderByAggregateInput
  }

  export type MouvementLogistiqueScalarWhereWithAggregatesInput = {
    AND?: MouvementLogistiqueScalarWhereWithAggregatesInput | MouvementLogistiqueScalarWhereWithAggregatesInput[]
    OR?: MouvementLogistiqueScalarWhereWithAggregatesInput[]
    NOT?: MouvementLogistiqueScalarWhereWithAggregatesInput | MouvementLogistiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MouvementLogistique"> | string
    articleId?: StringWithAggregatesFilter<"MouvementLogistique"> | string
    type?: StringWithAggregatesFilter<"MouvementLogistique"> | string
    quantite?: IntWithAggregatesFilter<"MouvementLogistique"> | number
    serviceDestinataire?: StringNullableWithAggregatesFilter<"MouvementLogistique"> | string | null
    motif?: StringNullableWithAggregatesFilter<"MouvementLogistique"> | string | null
    utilisateur?: StringWithAggregatesFilter<"MouvementLogistique"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MouvementLogistique"> | Date | string
  }

  export type DocumentGEDWhereInput = {
    AND?: DocumentGEDWhereInput | DocumentGEDWhereInput[]
    OR?: DocumentGEDWhereInput[]
    NOT?: DocumentGEDWhereInput | DocumentGEDWhereInput[]
    id?: StringFilter<"DocumentGED"> | string
    patientId?: StringNullableFilter<"DocumentGED"> | string | null
    titre?: StringFilter<"DocumentGED"> | string
    type?: StringFilter<"DocumentGED"> | string
    url?: StringFilter<"DocumentGED"> | string
    module?: StringFilter<"DocumentGED"> | string
    metadata?: JsonNullableFilter<"DocumentGED">
    createdAt?: DateTimeFilter<"DocumentGED"> | Date | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }

  export type DocumentGEDOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    titre?: SortOrder
    type?: SortOrder
    url?: SortOrder
    module?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type DocumentGEDWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentGEDWhereInput | DocumentGEDWhereInput[]
    OR?: DocumentGEDWhereInput[]
    NOT?: DocumentGEDWhereInput | DocumentGEDWhereInput[]
    patientId?: StringNullableFilter<"DocumentGED"> | string | null
    titre?: StringFilter<"DocumentGED"> | string
    type?: StringFilter<"DocumentGED"> | string
    url?: StringFilter<"DocumentGED"> | string
    module?: StringFilter<"DocumentGED"> | string
    metadata?: JsonNullableFilter<"DocumentGED">
    createdAt?: DateTimeFilter<"DocumentGED"> | Date | string
    patient?: XOR<PatientNullableScalarRelationFilter, PatientWhereInput> | null
  }, "id">

  export type DocumentGEDOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrderInput | SortOrder
    titre?: SortOrder
    type?: SortOrder
    url?: SortOrder
    module?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentGEDCountOrderByAggregateInput
    _max?: DocumentGEDMaxOrderByAggregateInput
    _min?: DocumentGEDMinOrderByAggregateInput
  }

  export type DocumentGEDScalarWhereWithAggregatesInput = {
    AND?: DocumentGEDScalarWhereWithAggregatesInput | DocumentGEDScalarWhereWithAggregatesInput[]
    OR?: DocumentGEDScalarWhereWithAggregatesInput[]
    NOT?: DocumentGEDScalarWhereWithAggregatesInput | DocumentGEDScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentGED"> | string
    patientId?: StringNullableWithAggregatesFilter<"DocumentGED"> | string | null
    titre?: StringWithAggregatesFilter<"DocumentGED"> | string
    type?: StringWithAggregatesFilter<"DocumentGED"> | string
    url?: StringWithAggregatesFilter<"DocumentGED"> | string
    module?: StringWithAggregatesFilter<"DocumentGED"> | string
    metadata?: JsonNullableWithAggregatesFilter<"DocumentGED">
    createdAt?: DateTimeWithAggregatesFilter<"DocumentGED"> | Date | string
  }

  export type EmployeWhereInput = {
    AND?: EmployeWhereInput | EmployeWhereInput[]
    OR?: EmployeWhereInput[]
    NOT?: EmployeWhereInput | EmployeWhereInput[]
    id?: StringFilter<"Employe"> | string
    userId?: StringNullableFilter<"Employe"> | string | null
    matricule?: StringFilter<"Employe"> | string
    nom?: StringFilter<"Employe"> | string
    prenom?: StringFilter<"Employe"> | string
    dateNaissance?: DateTimeFilter<"Employe"> | Date | string
    sexe?: StringFilter<"Employe"> | string
    telephone?: StringFilter<"Employe"> | string
    email?: StringNullableFilter<"Employe"> | string | null
    adresse?: StringNullableFilter<"Employe"> | string | null
    categorie?: StringFilter<"Employe"> | string
    fonction?: StringFilter<"Employe"> | string
    specialite?: StringNullableFilter<"Employe"> | string | null
    dateEmbauche?: DateTimeFilter<"Employe"> | Date | string
    typeContrat?: StringFilter<"Employe"> | string
    salaireBrut?: DecimalFilter<"Employe"> | Decimal | DecimalJsLike | number | string
    actif?: BoolFilter<"Employe"> | boolean
    createdAt?: DateTimeFilter<"Employe"> | Date | string
    updatedAt?: DateTimeFilter<"Employe"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    conges?: CongeListRelationFilter
    plannings?: PlanningListRelationFilter
    bulletins?: BulletinPaieListRelationFilter
  }

  export type EmployeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    categorie?: SortOrder
    fonction?: SortOrder
    specialite?: SortOrderInput | SortOrder
    dateEmbauche?: SortOrder
    typeContrat?: SortOrder
    salaireBrut?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    conges?: CongeOrderByRelationAggregateInput
    plannings?: PlanningOrderByRelationAggregateInput
    bulletins?: BulletinPaieOrderByRelationAggregateInput
  }

  export type EmployeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    matricule?: string
    AND?: EmployeWhereInput | EmployeWhereInput[]
    OR?: EmployeWhereInput[]
    NOT?: EmployeWhereInput | EmployeWhereInput[]
    nom?: StringFilter<"Employe"> | string
    prenom?: StringFilter<"Employe"> | string
    dateNaissance?: DateTimeFilter<"Employe"> | Date | string
    sexe?: StringFilter<"Employe"> | string
    telephone?: StringFilter<"Employe"> | string
    email?: StringNullableFilter<"Employe"> | string | null
    adresse?: StringNullableFilter<"Employe"> | string | null
    categorie?: StringFilter<"Employe"> | string
    fonction?: StringFilter<"Employe"> | string
    specialite?: StringNullableFilter<"Employe"> | string | null
    dateEmbauche?: DateTimeFilter<"Employe"> | Date | string
    typeContrat?: StringFilter<"Employe"> | string
    salaireBrut?: DecimalFilter<"Employe"> | Decimal | DecimalJsLike | number | string
    actif?: BoolFilter<"Employe"> | boolean
    createdAt?: DateTimeFilter<"Employe"> | Date | string
    updatedAt?: DateTimeFilter<"Employe"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    conges?: CongeListRelationFilter
    plannings?: PlanningListRelationFilter
    bulletins?: BulletinPaieListRelationFilter
  }, "id" | "userId" | "matricule">

  export type EmployeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrderInput | SortOrder
    adresse?: SortOrderInput | SortOrder
    categorie?: SortOrder
    fonction?: SortOrder
    specialite?: SortOrderInput | SortOrder
    dateEmbauche?: SortOrder
    typeContrat?: SortOrder
    salaireBrut?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeCountOrderByAggregateInput
    _avg?: EmployeAvgOrderByAggregateInput
    _max?: EmployeMaxOrderByAggregateInput
    _min?: EmployeMinOrderByAggregateInput
    _sum?: EmployeSumOrderByAggregateInput
  }

  export type EmployeScalarWhereWithAggregatesInput = {
    AND?: EmployeScalarWhereWithAggregatesInput | EmployeScalarWhereWithAggregatesInput[]
    OR?: EmployeScalarWhereWithAggregatesInput[]
    NOT?: EmployeScalarWhereWithAggregatesInput | EmployeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employe"> | string
    userId?: StringNullableWithAggregatesFilter<"Employe"> | string | null
    matricule?: StringWithAggregatesFilter<"Employe"> | string
    nom?: StringWithAggregatesFilter<"Employe"> | string
    prenom?: StringWithAggregatesFilter<"Employe"> | string
    dateNaissance?: DateTimeWithAggregatesFilter<"Employe"> | Date | string
    sexe?: StringWithAggregatesFilter<"Employe"> | string
    telephone?: StringWithAggregatesFilter<"Employe"> | string
    email?: StringNullableWithAggregatesFilter<"Employe"> | string | null
    adresse?: StringNullableWithAggregatesFilter<"Employe"> | string | null
    categorie?: StringWithAggregatesFilter<"Employe"> | string
    fonction?: StringWithAggregatesFilter<"Employe"> | string
    specialite?: StringNullableWithAggregatesFilter<"Employe"> | string | null
    dateEmbauche?: DateTimeWithAggregatesFilter<"Employe"> | Date | string
    typeContrat?: StringWithAggregatesFilter<"Employe"> | string
    salaireBrut?: DecimalWithAggregatesFilter<"Employe"> | Decimal | DecimalJsLike | number | string
    actif?: BoolWithAggregatesFilter<"Employe"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Employe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employe"> | Date | string
  }

  export type CongeWhereInput = {
    AND?: CongeWhereInput | CongeWhereInput[]
    OR?: CongeWhereInput[]
    NOT?: CongeWhereInput | CongeWhereInput[]
    id?: StringFilter<"Conge"> | string
    employeId?: StringFilter<"Conge"> | string
    type?: StringFilter<"Conge"> | string
    dateDebut?: DateTimeFilter<"Conge"> | Date | string
    dateFin?: DateTimeFilter<"Conge"> | Date | string
    nbJours?: IntFilter<"Conge"> | number
    motif?: StringNullableFilter<"Conge"> | string | null
    statut?: StringFilter<"Conge"> | string
    createdAt?: DateTimeFilter<"Conge"> | Date | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
  }

  export type CongeOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nbJours?: SortOrder
    motif?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    employe?: EmployeOrderByWithRelationInput
  }

  export type CongeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CongeWhereInput | CongeWhereInput[]
    OR?: CongeWhereInput[]
    NOT?: CongeWhereInput | CongeWhereInput[]
    employeId?: StringFilter<"Conge"> | string
    type?: StringFilter<"Conge"> | string
    dateDebut?: DateTimeFilter<"Conge"> | Date | string
    dateFin?: DateTimeFilter<"Conge"> | Date | string
    nbJours?: IntFilter<"Conge"> | number
    motif?: StringNullableFilter<"Conge"> | string | null
    statut?: StringFilter<"Conge"> | string
    createdAt?: DateTimeFilter<"Conge"> | Date | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
  }, "id">

  export type CongeOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nbJours?: SortOrder
    motif?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    _count?: CongeCountOrderByAggregateInput
    _avg?: CongeAvgOrderByAggregateInput
    _max?: CongeMaxOrderByAggregateInput
    _min?: CongeMinOrderByAggregateInput
    _sum?: CongeSumOrderByAggregateInput
  }

  export type CongeScalarWhereWithAggregatesInput = {
    AND?: CongeScalarWhereWithAggregatesInput | CongeScalarWhereWithAggregatesInput[]
    OR?: CongeScalarWhereWithAggregatesInput[]
    NOT?: CongeScalarWhereWithAggregatesInput | CongeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conge"> | string
    employeId?: StringWithAggregatesFilter<"Conge"> | string
    type?: StringWithAggregatesFilter<"Conge"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"Conge"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Conge"> | Date | string
    nbJours?: IntWithAggregatesFilter<"Conge"> | number
    motif?: StringNullableWithAggregatesFilter<"Conge"> | string | null
    statut?: StringWithAggregatesFilter<"Conge"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Conge"> | Date | string
  }

  export type BulletinPaieWhereInput = {
    AND?: BulletinPaieWhereInput | BulletinPaieWhereInput[]
    OR?: BulletinPaieWhereInput[]
    NOT?: BulletinPaieWhereInput | BulletinPaieWhereInput[]
    id?: StringFilter<"BulletinPaie"> | string
    employeId?: StringFilter<"BulletinPaie"> | string
    periode?: StringFilter<"BulletinPaie"> | string
    dateEmission?: DateTimeFilter<"BulletinPaie"> | Date | string
    salaireBase?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"BulletinPaie"> | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
    lignes?: LigneBulletinListRelationFilter
  }

  export type BulletinPaieOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    periode?: SortOrder
    dateEmission?: SortOrder
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
    statut?: SortOrder
    employe?: EmployeOrderByWithRelationInput
    lignes?: LigneBulletinOrderByRelationAggregateInput
  }

  export type BulletinPaieWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BulletinPaieWhereInput | BulletinPaieWhereInput[]
    OR?: BulletinPaieWhereInput[]
    NOT?: BulletinPaieWhereInput | BulletinPaieWhereInput[]
    employeId?: StringFilter<"BulletinPaie"> | string
    periode?: StringFilter<"BulletinPaie"> | string
    dateEmission?: DateTimeFilter<"BulletinPaie"> | Date | string
    salaireBase?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"BulletinPaie"> | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
    lignes?: LigneBulletinListRelationFilter
  }, "id">

  export type BulletinPaieOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    periode?: SortOrder
    dateEmission?: SortOrder
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
    statut?: SortOrder
    _count?: BulletinPaieCountOrderByAggregateInput
    _avg?: BulletinPaieAvgOrderByAggregateInput
    _max?: BulletinPaieMaxOrderByAggregateInput
    _min?: BulletinPaieMinOrderByAggregateInput
    _sum?: BulletinPaieSumOrderByAggregateInput
  }

  export type BulletinPaieScalarWhereWithAggregatesInput = {
    AND?: BulletinPaieScalarWhereWithAggregatesInput | BulletinPaieScalarWhereWithAggregatesInput[]
    OR?: BulletinPaieScalarWhereWithAggregatesInput[]
    NOT?: BulletinPaieScalarWhereWithAggregatesInput | BulletinPaieScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BulletinPaie"> | string
    employeId?: StringWithAggregatesFilter<"BulletinPaie"> | string
    periode?: StringWithAggregatesFilter<"BulletinPaie"> | string
    dateEmission?: DateTimeWithAggregatesFilter<"BulletinPaie"> | Date | string
    salaireBase?: DecimalWithAggregatesFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalWithAggregatesFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalWithAggregatesFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalWithAggregatesFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    statut?: StringWithAggregatesFilter<"BulletinPaie"> | string
  }

  export type LigneBulletinWhereInput = {
    AND?: LigneBulletinWhereInput | LigneBulletinWhereInput[]
    OR?: LigneBulletinWhereInput[]
    NOT?: LigneBulletinWhereInput | LigneBulletinWhereInput[]
    id?: StringFilter<"LigneBulletin"> | string
    bulletinId?: StringFilter<"LigneBulletin"> | string
    libelle?: StringFilter<"LigneBulletin"> | string
    type?: StringFilter<"LigneBulletin"> | string
    base?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    taux?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string
    bulletin?: XOR<BulletinPaieScalarRelationFilter, BulletinPaieWhereInput>
  }

  export type LigneBulletinOrderByWithRelationInput = {
    id?: SortOrder
    bulletinId?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    base?: SortOrderInput | SortOrder
    taux?: SortOrderInput | SortOrder
    montant?: SortOrder
    bulletin?: BulletinPaieOrderByWithRelationInput
  }

  export type LigneBulletinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LigneBulletinWhereInput | LigneBulletinWhereInput[]
    OR?: LigneBulletinWhereInput[]
    NOT?: LigneBulletinWhereInput | LigneBulletinWhereInput[]
    bulletinId?: StringFilter<"LigneBulletin"> | string
    libelle?: StringFilter<"LigneBulletin"> | string
    type?: StringFilter<"LigneBulletin"> | string
    base?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    taux?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string
    bulletin?: XOR<BulletinPaieScalarRelationFilter, BulletinPaieWhereInput>
  }, "id">

  export type LigneBulletinOrderByWithAggregationInput = {
    id?: SortOrder
    bulletinId?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    base?: SortOrderInput | SortOrder
    taux?: SortOrderInput | SortOrder
    montant?: SortOrder
    _count?: LigneBulletinCountOrderByAggregateInput
    _avg?: LigneBulletinAvgOrderByAggregateInput
    _max?: LigneBulletinMaxOrderByAggregateInput
    _min?: LigneBulletinMinOrderByAggregateInput
    _sum?: LigneBulletinSumOrderByAggregateInput
  }

  export type LigneBulletinScalarWhereWithAggregatesInput = {
    AND?: LigneBulletinScalarWhereWithAggregatesInput | LigneBulletinScalarWhereWithAggregatesInput[]
    OR?: LigneBulletinScalarWhereWithAggregatesInput[]
    NOT?: LigneBulletinScalarWhereWithAggregatesInput | LigneBulletinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LigneBulletin"> | string
    bulletinId?: StringWithAggregatesFilter<"LigneBulletin"> | string
    libelle?: StringWithAggregatesFilter<"LigneBulletin"> | string
    type?: StringWithAggregatesFilter<"LigneBulletin"> | string
    base?: DecimalNullableWithAggregatesFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    taux?: DecimalNullableWithAggregatesFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalWithAggregatesFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string
  }

  export type PlanningWhereInput = {
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    id?: StringFilter<"Planning"> | string
    employeId?: StringFilter<"Planning"> | string
    date?: DateTimeFilter<"Planning"> | Date | string
    heureDebut?: StringFilter<"Planning"> | string
    heureFin?: StringFilter<"Planning"> | string
    type?: StringFilter<"Planning"> | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
  }

  export type PlanningOrderByWithRelationInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    employe?: EmployeOrderByWithRelationInput
  }

  export type PlanningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanningWhereInput | PlanningWhereInput[]
    OR?: PlanningWhereInput[]
    NOT?: PlanningWhereInput | PlanningWhereInput[]
    employeId?: StringFilter<"Planning"> | string
    date?: DateTimeFilter<"Planning"> | Date | string
    heureDebut?: StringFilter<"Planning"> | string
    heureFin?: StringFilter<"Planning"> | string
    type?: StringFilter<"Planning"> | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
    employe?: XOR<EmployeScalarRelationFilter, EmployeWhereInput>
  }, "id">

  export type PlanningOrderByWithAggregationInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PlanningCountOrderByAggregateInput
    _max?: PlanningMaxOrderByAggregateInput
    _min?: PlanningMinOrderByAggregateInput
  }

  export type PlanningScalarWhereWithAggregatesInput = {
    AND?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    OR?: PlanningScalarWhereWithAggregatesInput[]
    NOT?: PlanningScalarWhereWithAggregatesInput | PlanningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Planning"> | string
    employeId?: StringWithAggregatesFilter<"Planning"> | string
    date?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
    heureDebut?: StringWithAggregatesFilter<"Planning"> | string
    heureFin?: StringWithAggregatesFilter<"Planning"> | string
    type?: StringWithAggregatesFilter<"Planning"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Planning"> | Date | string
  }

  export type EquipementWhereInput = {
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    id?: StringFilter<"Equipement"> | string
    code?: StringFilter<"Equipement"> | string
    nom?: StringFilter<"Equipement"> | string
    type?: StringFilter<"Equipement"> | string
    marque?: StringNullableFilter<"Equipement"> | string | null
    modele?: StringNullableFilter<"Equipement"> | string | null
    serie?: StringNullableFilter<"Equipement"> | string | null
    dateAchat?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    dateDerniereMaintenace?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    dateProchaineMaintenance?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    statut?: StringFilter<"Equipement"> | string
    localisation?: StringNullableFilter<"Equipement"> | string | null
    createdAt?: DateTimeFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeFilter<"Equipement"> | Date | string
    tickets?: TicketMaintenanceListRelationFilter
  }

  export type EquipementOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    marque?: SortOrderInput | SortOrder
    modele?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    dateAchat?: SortOrderInput | SortOrder
    dateDerniereMaintenace?: SortOrderInput | SortOrder
    dateProchaineMaintenance?: SortOrderInput | SortOrder
    statut?: SortOrder
    localisation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tickets?: TicketMaintenanceOrderByRelationAggregateInput
  }

  export type EquipementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    serie?: string
    AND?: EquipementWhereInput | EquipementWhereInput[]
    OR?: EquipementWhereInput[]
    NOT?: EquipementWhereInput | EquipementWhereInput[]
    nom?: StringFilter<"Equipement"> | string
    type?: StringFilter<"Equipement"> | string
    marque?: StringNullableFilter<"Equipement"> | string | null
    modele?: StringNullableFilter<"Equipement"> | string | null
    dateAchat?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    dateDerniereMaintenace?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    dateProchaineMaintenance?: DateTimeNullableFilter<"Equipement"> | Date | string | null
    statut?: StringFilter<"Equipement"> | string
    localisation?: StringNullableFilter<"Equipement"> | string | null
    createdAt?: DateTimeFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeFilter<"Equipement"> | Date | string
    tickets?: TicketMaintenanceListRelationFilter
  }, "id" | "code" | "serie">

  export type EquipementOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    marque?: SortOrderInput | SortOrder
    modele?: SortOrderInput | SortOrder
    serie?: SortOrderInput | SortOrder
    dateAchat?: SortOrderInput | SortOrder
    dateDerniereMaintenace?: SortOrderInput | SortOrder
    dateProchaineMaintenance?: SortOrderInput | SortOrder
    statut?: SortOrder
    localisation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipementCountOrderByAggregateInput
    _max?: EquipementMaxOrderByAggregateInput
    _min?: EquipementMinOrderByAggregateInput
  }

  export type EquipementScalarWhereWithAggregatesInput = {
    AND?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    OR?: EquipementScalarWhereWithAggregatesInput[]
    NOT?: EquipementScalarWhereWithAggregatesInput | EquipementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipement"> | string
    code?: StringWithAggregatesFilter<"Equipement"> | string
    nom?: StringWithAggregatesFilter<"Equipement"> | string
    type?: StringWithAggregatesFilter<"Equipement"> | string
    marque?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    modele?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    serie?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    dateAchat?: DateTimeNullableWithAggregatesFilter<"Equipement"> | Date | string | null
    dateDerniereMaintenace?: DateTimeNullableWithAggregatesFilter<"Equipement"> | Date | string | null
    dateProchaineMaintenance?: DateTimeNullableWithAggregatesFilter<"Equipement"> | Date | string | null
    statut?: StringWithAggregatesFilter<"Equipement"> | string
    localisation?: StringNullableWithAggregatesFilter<"Equipement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Equipement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipement"> | Date | string
  }

  export type TicketMaintenanceWhereInput = {
    AND?: TicketMaintenanceWhereInput | TicketMaintenanceWhereInput[]
    OR?: TicketMaintenanceWhereInput[]
    NOT?: TicketMaintenanceWhereInput | TicketMaintenanceWhereInput[]
    id?: StringFilter<"TicketMaintenance"> | string
    equipementId?: StringFilter<"TicketMaintenance"> | string
    type?: StringFilter<"TicketMaintenance"> | string
    priorite?: StringFilter<"TicketMaintenance"> | string
    objet?: StringFilter<"TicketMaintenance"> | string
    description?: StringFilter<"TicketMaintenance"> | string
    statut?: StringFilter<"TicketMaintenance"> | string
    intervenant?: StringNullableFilter<"TicketMaintenance"> | string | null
    dateResolution?: DateTimeNullableFilter<"TicketMaintenance"> | Date | string | null
    coutEstime?: DecimalNullableFilter<"TicketMaintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
    updatedAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
    equipement?: XOR<EquipementScalarRelationFilter, EquipementWhereInput>
  }

  export type TicketMaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    objet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    intervenant?: SortOrderInput | SortOrder
    dateResolution?: SortOrderInput | SortOrder
    coutEstime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipement?: EquipementOrderByWithRelationInput
  }

  export type TicketMaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketMaintenanceWhereInput | TicketMaintenanceWhereInput[]
    OR?: TicketMaintenanceWhereInput[]
    NOT?: TicketMaintenanceWhereInput | TicketMaintenanceWhereInput[]
    equipementId?: StringFilter<"TicketMaintenance"> | string
    type?: StringFilter<"TicketMaintenance"> | string
    priorite?: StringFilter<"TicketMaintenance"> | string
    objet?: StringFilter<"TicketMaintenance"> | string
    description?: StringFilter<"TicketMaintenance"> | string
    statut?: StringFilter<"TicketMaintenance"> | string
    intervenant?: StringNullableFilter<"TicketMaintenance"> | string | null
    dateResolution?: DateTimeNullableFilter<"TicketMaintenance"> | Date | string | null
    coutEstime?: DecimalNullableFilter<"TicketMaintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
    updatedAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
    equipement?: XOR<EquipementScalarRelationFilter, EquipementWhereInput>
  }, "id">

  export type TicketMaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    objet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    intervenant?: SortOrderInput | SortOrder
    dateResolution?: SortOrderInput | SortOrder
    coutEstime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketMaintenanceCountOrderByAggregateInput
    _avg?: TicketMaintenanceAvgOrderByAggregateInput
    _max?: TicketMaintenanceMaxOrderByAggregateInput
    _min?: TicketMaintenanceMinOrderByAggregateInput
    _sum?: TicketMaintenanceSumOrderByAggregateInput
  }

  export type TicketMaintenanceScalarWhereWithAggregatesInput = {
    AND?: TicketMaintenanceScalarWhereWithAggregatesInput | TicketMaintenanceScalarWhereWithAggregatesInput[]
    OR?: TicketMaintenanceScalarWhereWithAggregatesInput[]
    NOT?: TicketMaintenanceScalarWhereWithAggregatesInput | TicketMaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    equipementId?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    type?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    priorite?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    objet?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    description?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    statut?: StringWithAggregatesFilter<"TicketMaintenance"> | string
    intervenant?: StringNullableWithAggregatesFilter<"TicketMaintenance"> | string | null
    dateResolution?: DateTimeNullableWithAggregatesFilter<"TicketMaintenance"> | Date | string | null
    coutEstime?: DecimalNullableWithAggregatesFilter<"TicketMaintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TicketMaintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketMaintenance"> | Date | string
  }

  export type EvenementIndesirableWhereInput = {
    AND?: EvenementIndesirableWhereInput | EvenementIndesirableWhereInput[]
    OR?: EvenementIndesirableWhereInput[]
    NOT?: EvenementIndesirableWhereInput | EvenementIndesirableWhereInput[]
    id?: StringFilter<"EvenementIndesirable"> | string
    dateEvenement?: DateTimeFilter<"EvenementIndesirable"> | Date | string
    service?: StringNullableFilter<"EvenementIndesirable"> | string | null
    type?: StringFilter<"EvenementIndesirable"> | string
    gravite?: StringFilter<"EvenementIndesirable"> | string
    description?: StringFilter<"EvenementIndesirable"> | string
    mesuresPrises?: StringNullableFilter<"EvenementIndesirable"> | string | null
    statut?: StringFilter<"EvenementIndesirable"> | string
    declaréPar?: StringNullableFilter<"EvenementIndesirable"> | string | null
    patientId?: StringNullableFilter<"EvenementIndesirable"> | string | null
    createdAt?: DateTimeFilter<"EvenementIndesirable"> | Date | string
  }

  export type EvenementIndesirableOrderByWithRelationInput = {
    id?: SortOrder
    dateEvenement?: SortOrder
    service?: SortOrderInput | SortOrder
    type?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    mesuresPrises?: SortOrderInput | SortOrder
    statut?: SortOrder
    declaréPar?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type EvenementIndesirableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvenementIndesirableWhereInput | EvenementIndesirableWhereInput[]
    OR?: EvenementIndesirableWhereInput[]
    NOT?: EvenementIndesirableWhereInput | EvenementIndesirableWhereInput[]
    dateEvenement?: DateTimeFilter<"EvenementIndesirable"> | Date | string
    service?: StringNullableFilter<"EvenementIndesirable"> | string | null
    type?: StringFilter<"EvenementIndesirable"> | string
    gravite?: StringFilter<"EvenementIndesirable"> | string
    description?: StringFilter<"EvenementIndesirable"> | string
    mesuresPrises?: StringNullableFilter<"EvenementIndesirable"> | string | null
    statut?: StringFilter<"EvenementIndesirable"> | string
    declaréPar?: StringNullableFilter<"EvenementIndesirable"> | string | null
    patientId?: StringNullableFilter<"EvenementIndesirable"> | string | null
    createdAt?: DateTimeFilter<"EvenementIndesirable"> | Date | string
  }, "id">

  export type EvenementIndesirableOrderByWithAggregationInput = {
    id?: SortOrder
    dateEvenement?: SortOrder
    service?: SortOrderInput | SortOrder
    type?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    mesuresPrises?: SortOrderInput | SortOrder
    statut?: SortOrder
    declaréPar?: SortOrderInput | SortOrder
    patientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EvenementIndesirableCountOrderByAggregateInput
    _max?: EvenementIndesirableMaxOrderByAggregateInput
    _min?: EvenementIndesirableMinOrderByAggregateInput
  }

  export type EvenementIndesirableScalarWhereWithAggregatesInput = {
    AND?: EvenementIndesirableScalarWhereWithAggregatesInput | EvenementIndesirableScalarWhereWithAggregatesInput[]
    OR?: EvenementIndesirableScalarWhereWithAggregatesInput[]
    NOT?: EvenementIndesirableScalarWhereWithAggregatesInput | EvenementIndesirableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvenementIndesirable"> | string
    dateEvenement?: DateTimeWithAggregatesFilter<"EvenementIndesirable"> | Date | string
    service?: StringNullableWithAggregatesFilter<"EvenementIndesirable"> | string | null
    type?: StringWithAggregatesFilter<"EvenementIndesirable"> | string
    gravite?: StringWithAggregatesFilter<"EvenementIndesirable"> | string
    description?: StringWithAggregatesFilter<"EvenementIndesirable"> | string
    mesuresPrises?: StringNullableWithAggregatesFilter<"EvenementIndesirable"> | string | null
    statut?: StringWithAggregatesFilter<"EvenementIndesirable"> | string
    declaréPar?: StringNullableWithAggregatesFilter<"EvenementIndesirable"> | string | null
    patientId?: StringNullableWithAggregatesFilter<"EvenementIndesirable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EvenementIndesirable"> | Date | string
  }

  export type AuditQualiteWhereInput = {
    AND?: AuditQualiteWhereInput | AuditQualiteWhereInput[]
    OR?: AuditQualiteWhereInput[]
    NOT?: AuditQualiteWhereInput | AuditQualiteWhereInput[]
    id?: StringFilter<"AuditQualite"> | string
    dateAudit?: DateTimeFilter<"AuditQualite"> | Date | string
    service?: StringFilter<"AuditQualite"> | string
    auditeur?: StringFilter<"AuditQualite"> | string
    type?: StringFilter<"AuditQualite"> | string
    score?: IntFilter<"AuditQualite"> | number
    observations?: StringNullableFilter<"AuditQualite"> | string | null
    createdAt?: DateTimeFilter<"AuditQualite"> | Date | string
  }

  export type AuditQualiteOrderByWithRelationInput = {
    id?: SortOrder
    dateAudit?: SortOrder
    service?: SortOrder
    auditeur?: SortOrder
    type?: SortOrder
    score?: SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditQualiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditQualiteWhereInput | AuditQualiteWhereInput[]
    OR?: AuditQualiteWhereInput[]
    NOT?: AuditQualiteWhereInput | AuditQualiteWhereInput[]
    dateAudit?: DateTimeFilter<"AuditQualite"> | Date | string
    service?: StringFilter<"AuditQualite"> | string
    auditeur?: StringFilter<"AuditQualite"> | string
    type?: StringFilter<"AuditQualite"> | string
    score?: IntFilter<"AuditQualite"> | number
    observations?: StringNullableFilter<"AuditQualite"> | string | null
    createdAt?: DateTimeFilter<"AuditQualite"> | Date | string
  }, "id">

  export type AuditQualiteOrderByWithAggregationInput = {
    id?: SortOrder
    dateAudit?: SortOrder
    service?: SortOrder
    auditeur?: SortOrder
    type?: SortOrder
    score?: SortOrder
    observations?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditQualiteCountOrderByAggregateInput
    _avg?: AuditQualiteAvgOrderByAggregateInput
    _max?: AuditQualiteMaxOrderByAggregateInput
    _min?: AuditQualiteMinOrderByAggregateInput
    _sum?: AuditQualiteSumOrderByAggregateInput
  }

  export type AuditQualiteScalarWhereWithAggregatesInput = {
    AND?: AuditQualiteScalarWhereWithAggregatesInput | AuditQualiteScalarWhereWithAggregatesInput[]
    OR?: AuditQualiteScalarWhereWithAggregatesInput[]
    NOT?: AuditQualiteScalarWhereWithAggregatesInput | AuditQualiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditQualite"> | string
    dateAudit?: DateTimeWithAggregatesFilter<"AuditQualite"> | Date | string
    service?: StringWithAggregatesFilter<"AuditQualite"> | string
    auditeur?: StringWithAggregatesFilter<"AuditQualite"> | string
    type?: StringWithAggregatesFilter<"AuditQualite"> | string
    score?: IntWithAggregatesFilter<"AuditQualite"> | number
    observations?: StringNullableWithAggregatesFilter<"AuditQualite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditQualite"> | Date | string
  }

  export type ConfigurationWhereInput = {
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    id?: StringFilter<"Configuration"> | string
    cle?: StringFilter<"Configuration"> | string
    valeur?: StringFilter<"Configuration"> | string
    type?: StringFilter<"Configuration"> | string
    module?: StringFilter<"Configuration"> | string
    description?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
  }

  export type ConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    type?: SortOrder
    module?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cle?: string
    AND?: ConfigurationWhereInput | ConfigurationWhereInput[]
    OR?: ConfigurationWhereInput[]
    NOT?: ConfigurationWhereInput | ConfigurationWhereInput[]
    valeur?: StringFilter<"Configuration"> | string
    type?: StringFilter<"Configuration"> | string
    module?: StringFilter<"Configuration"> | string
    description?: StringNullableFilter<"Configuration"> | string | null
    createdAt?: DateTimeFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeFilter<"Configuration"> | Date | string
  }, "id" | "cle">

  export type ConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    type?: SortOrder
    module?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfigurationCountOrderByAggregateInput
    _max?: ConfigurationMaxOrderByAggregateInput
    _min?: ConfigurationMinOrderByAggregateInput
  }

  export type ConfigurationScalarWhereWithAggregatesInput = {
    AND?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    OR?: ConfigurationScalarWhereWithAggregatesInput[]
    NOT?: ConfigurationScalarWhereWithAggregatesInput | ConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuration"> | string
    cle?: StringWithAggregatesFilter<"Configuration"> | string
    valeur?: StringWithAggregatesFilter<"Configuration"> | string
    type?: StringWithAggregatesFilter<"Configuration"> | string
    module?: StringWithAggregatesFilter<"Configuration"> | string
    description?: StringNullableWithAggregatesFilter<"Configuration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Configuration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    permissions?: PermissionCreateNestedManyWithoutRolesInput
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUpdateManyWithoutRolesNestedInput
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    nom: string
    description?: string | null
    module: string
    action: string
    createdAt?: Date | string
    roles?: RoleCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    nom: string
    description?: string | null
    module: string
    action: string
    createdAt?: Date | string
    roles?: RoleUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RoleUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RoleUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    nom: string
    description?: string | null
    module: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteComptableCreateInput = {
    id?: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ecritures?: EcritureComptableCreateNestedManyWithoutCompteInput
  }

  export type CompteComptableUncheckedCreateInput = {
    id?: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCompteInput
  }

  export type CompteComptableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUpdateManyWithoutCompteNestedInput
  }

  export type CompteComptableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCompteNestedInput
  }

  export type CompteComptableCreateManyInput = {
    id?: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompteComptableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteComptableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalCreateInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableCreateNestedManyWithoutJournalInput
  }

  export type JournalUncheckedCreateInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutJournalInput
  }

  export type JournalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUpdateManyWithoutJournalNestedInput
  }

  export type JournalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutJournalNestedInput
  }

  export type JournalCreateManyInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type JournalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciceComptableCreateInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableCreateNestedManyWithoutExerciceInput
    budgets?: BudgetCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableUncheckedCreateInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutExerciceInput
    budgets?: BudgetUncheckedCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUpdateManyWithoutExerciceNestedInput
    budgets?: BudgetUpdateManyWithoutExerciceNestedInput
  }

  export type ExerciceComptableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutExerciceNestedInput
    budgets?: BudgetUncheckedUpdateManyWithoutExerciceNestedInput
  }

  export type ExerciceComptableCreateManyInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
  }

  export type ExerciceComptableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciceComptableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal: JournalCreateNestedOneWithoutEcrituresInput
    compte: CompteComptableCreateNestedOneWithoutEcrituresInput
    exercice: ExerciceComptableCreateNestedOneWithoutEcrituresInput
    centreAnalytique?: CentreAnalytiqueCreateNestedOneWithoutEcrituresInput
    createdBy: UserCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneRequiredWithoutEcrituresNestedInput
    compte?: CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput
    exercice?: ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput
    centreAnalytique?: CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateManyInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CentreAnalytiqueCreateInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableCreateNestedManyWithoutCentreAnalytiqueInput
  }

  export type CentreAnalytiqueUncheckedCreateInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCentreAnalytiqueInput
  }

  export type CentreAnalytiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUpdateManyWithoutCentreAnalytiqueNestedInput
  }

  export type CentreAnalytiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCentreAnalytiqueNestedInput
  }

  export type CentreAnalytiqueCreateManyInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type CentreAnalytiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CentreAnalytiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateInput = {
    id?: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
    exercice: ExerciceComptableCreateNestedOneWithoutBudgetsInput
  }

  export type BudgetUncheckedCreateInput = {
    id?: string
    exerciceId: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
  }

  export type BudgetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exercice?: ExerciceComptableUpdateOneRequiredWithoutBudgetsNestedInput
  }

  export type BudgetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetCreateManyInput = {
    id?: string
    exerciceId: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
  }

  export type BudgetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentCreateInput = {
    id?: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutAntecedentsInput
  }

  export type AntecedentUncheckedCreateInput = {
    id?: string
    patientId: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
  }

  export type AntecedentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAntecedentsNestedInput
  }

  export type AntecedentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentCreateManyInput = {
    id?: string
    patientId: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
  }

  export type AntecedentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieCreateInput = {
    id?: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutAllergiesInput
  }

  export type AllergieUncheckedCreateInput = {
    id?: string
    patientId: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
  }

  export type AllergieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAllergiesNestedInput
  }

  export type AllergieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieCreateManyInput = {
    id?: string
    patientId: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
  }

  export type AllergieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateInput = {
    id?: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateInput = {
    id?: string
    patientId: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateManyInput = {
    id?: string
    patientId: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousCreateInput = {
    id?: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRendezvousInput
    medecin: UserCreateNestedOneWithoutRendezvousInput
  }

  export type RendezVousUncheckedCreateInput = {
    id?: string
    patientId: string
    medecinId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRendezvousNestedInput
    medecin?: UserUpdateOneRequiredWithoutRendezvousNestedInput
  }

  export type RendezVousUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousCreateManyInput = {
    id?: string
    patientId: string
    medecinId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    medecin: UserCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseCreateNestedManyWithoutConsultationInput
    facture?: FactureCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationUncheckedCreateInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    medecin?: UserUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUpdateManyWithoutConsultationNestedInput
    facture?: FactureUpdateOneWithoutConsultationsNestedInput
  }

  export type ConsultationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationCreateManyInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConsultationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    id?: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
    consultation: ConsultationCreateNestedOneWithoutPrescriptionsInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    consultationId: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    consultationId: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NomenclatureActeCreateInput = {
    id?: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal | DecimalJsLike | number | string
    duree?: number | null
    actif?: boolean
    createdAt?: Date | string
    actes?: ActeRealiseCreateNestedManyWithoutActeInput
  }

  export type NomenclatureActeUncheckedCreateInput = {
    id?: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal | DecimalJsLike | number | string
    duree?: number | null
    actif?: boolean
    createdAt?: Date | string
    actes?: ActeRealiseUncheckedCreateNestedManyWithoutActeInput
  }

  export type NomenclatureActeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actes?: ActeRealiseUpdateManyWithoutActeNestedInput
  }

  export type NomenclatureActeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actes?: ActeRealiseUncheckedUpdateManyWithoutActeNestedInput
  }

  export type NomenclatureActeCreateManyInput = {
    id?: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal | DecimalJsLike | number | string
    duree?: number | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type NomenclatureActeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NomenclatureActeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActeRealiseCreateInput = {
    id?: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    consultation: ConsultationCreateNestedOneWithoutActesRealisesInput
    acte: NomenclatureActeCreateNestedOneWithoutActesInput
    resultat?: ResultatExamenCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseUncheckedCreateInput = {
    id?: string
    consultationId: string
    acteId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    resultat?: ResultatExamenUncheckedCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneRequiredWithoutActesRealisesNestedInput
    acte?: NomenclatureActeUpdateOneRequiredWithoutActesNestedInput
    resultat?: ResultatExamenUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    acteId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultat?: ResultatExamenUncheckedUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseCreateManyInput = {
    id?: string
    consultationId: string
    acteId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ActeRealiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActeRealiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    acteId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatExamenCreateInput = {
    id?: string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: string | null
    compteRendu?: string | null
    images?: ResultatExamenCreateimagesInput | string[]
    dateExamen?: Date | string
    validePar?: string | null
    dateValidation?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    acteRealise: ActeRealiseCreateNestedOneWithoutResultatInput
  }

  export type ResultatExamenUncheckedCreateInput = {
    id?: string
    acteRealiseId: string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: string | null
    compteRendu?: string | null
    images?: ResultatExamenCreateimagesInput | string[]
    dateExamen?: Date | string
    validePar?: string | null
    dateValidation?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatExamenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acteRealise?: ActeRealiseUpdateOneRequiredWithoutResultatNestedInput
  }

  export type ResultatExamenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acteRealiseId?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatExamenCreateManyInput = {
    id?: string
    acteRealiseId: string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: string | null
    compteRendu?: string | null
    images?: ResultatExamenCreateimagesInput | string[]
    dateExamen?: Date | string
    validePar?: string | null
    dateValidation?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatExamenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatExamenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acteRealiseId?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentCreateInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockUncheckedCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUncheckedUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUncheckedUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentCreateManyInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicamentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurCreateInput = {
    id?: string
    nom: string
    code?: string | null
    contact?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    ninea?: string | null
    rccm?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandes?: CommandePharmacieCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateInput = {
    id?: string
    nom: string
    code?: string | null
    contact?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    ninea?: string | null
    rccm?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandes?: CommandePharmacieUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandes?: CommandePharmacieUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandes?: CommandePharmacieUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurCreateManyInput = {
    id?: string
    nom: string
    code?: string | null
    contact?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    ninea?: string | null
    rccm?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FournisseurUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandePharmacieCreateInput = {
    id?: string
    numeroCommande: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur: FournisseurCreateNestedOneWithoutCommandesInput
    lignes?: LigneCommandePharmacieCreateNestedManyWithoutCommandeInput
  }

  export type CommandePharmacieUncheckedCreateInput = {
    id?: string
    numeroCommande: string
    fournisseurId: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandePharmacieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneRequiredWithoutCommandesNestedInput
    lignes?: LigneCommandePharmacieUpdateManyWithoutCommandeNestedInput
  }

  export type CommandePharmacieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    fournisseurId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandePharmacieUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandePharmacieCreateManyInput = {
    id?: string
    numeroCommande: string
    fournisseurId: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandePharmacieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandePharmacieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    fournisseurId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieCreateInput = {
    id?: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    commande: CommandePharmacieCreateNestedOneWithoutLignesInput
    medicament: MedicamentCreateNestedOneWithoutCommandesInput
  }

  export type LigneCommandePharmacieUncheckedCreateInput = {
    id?: string
    commandeId: string
    medicamentId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commande?: CommandePharmacieUpdateOneRequiredWithoutLignesNestedInput
    medicament?: MedicamentUpdateOneRequiredWithoutCommandesNestedInput
  }

  export type LigneCommandePharmacieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandeId?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieCreateManyInput = {
    id?: string
    commandeId: string
    medicamentId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandeId?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateInput = {
    id?: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicament: MedicamentCreateNestedOneWithoutStocksInput
  }

  export type StockUncheckedCreateInput = {
    id?: string
    medicamentId: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicament?: MedicamentUpdateOneRequiredWithoutStocksNestedInput
  }

  export type StockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateManyInput = {
    id?: string
    medicamentId: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockCreateInput = {
    id?: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
    medicament: MedicamentCreateNestedOneWithoutMouvementsInput
  }

  export type MouvementStockUncheckedCreateInput = {
    id?: string
    medicamentId: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementStockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicament?: MedicamentUpdateOneRequiredWithoutMouvementsNestedInput
  }

  export type MouvementStockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockCreateManyInput = {
    id?: string
    medicamentId: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementStockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationCreateInput = {
    id?: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
    medicament: MedicamentCreateNestedOneWithoutDispensationsInput
    patient: PatientCreateNestedOneWithoutDispensationsInput
  }

  export type DispensationUncheckedCreateInput = {
    id?: string
    medicamentId: string
    patientId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type DispensationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicament?: MedicamentUpdateOneRequiredWithoutDispensationsNestedInput
    patient?: PatientUpdateOneRequiredWithoutDispensationsNestedInput
  }

  export type DispensationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationCreateManyInput = {
    id?: string
    medicamentId: string
    patientId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type DispensationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactureCreateInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFacturesInput
    lignes?: LigneFactureCreateNestedManyWithoutFactureInput
    paiements?: PaiementCreateNestedManyWithoutFactureInput
    consultations?: ConsultationCreateNestedManyWithoutFactureInput
  }

  export type FactureUncheckedCreateInput = {
    id?: string
    numeroFacture: string
    patientId: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneFactureUncheckedCreateNestedManyWithoutFactureInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutFactureInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFacturesNestedInput
    lignes?: LigneFactureUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneFactureUncheckedUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureCreateManyInput = {
    id?: string
    numeroFacture: string
    patientId: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FactureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureCreateInput = {
    id?: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    facture: FactureCreateNestedOneWithoutLignesInput
  }

  export type LigneFactureUncheckedCreateInput = {
    id?: string
    factureId: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneFactureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facture?: FactureUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneFactureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureCreateManyInput = {
    id?: string
    factureId: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneFactureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateInput = {
    id?: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    facture: FactureCreateNestedOneWithoutPaiementsInput
    createdBy: UserCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: string
    factureId: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PaiementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facture?: FactureUpdateOneRequiredWithoutPaiementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyInput = {
    id?: string
    factureId: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PaiementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LitCreateInput = {
    id?: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal | DecimalJsLike | number | string
    occupe?: boolean
    createdAt?: Date | string
    hospitalisations?: HospitalisationCreateNestedManyWithoutLitInput
  }

  export type LitUncheckedCreateInput = {
    id?: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal | DecimalJsLike | number | string
    occupe?: boolean
    createdAt?: Date | string
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutLitInput
  }

  export type LitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalisations?: HospitalisationUpdateManyWithoutLitNestedInput
  }

  export type LitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutLitNestedInput
  }

  export type LitCreateManyInput = {
    id?: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal | DecimalJsLike | number | string
    occupe?: boolean
    createdAt?: Date | string
  }

  export type LitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalisationCreateInput = {
    id?: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutHospitalisationsInput
    lit: LitCreateNestedOneWithoutHospitalisationsInput
    observations?: ObservationInfirmierCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationUncheckedCreateInput = {
    id?: string
    patientId: string
    litId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationInfirmierUncheckedCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutHospitalisationsNestedInput
    lit?: LitUpdateOneRequiredWithoutHospitalisationsNestedInput
    observations?: ObservationInfirmierUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    litId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationCreateManyInput = {
    id?: string
    patientId: string
    litId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalisationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalisationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    litId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierCreateInput = {
    id?: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
    hospitalisation: HospitalisationCreateNestedOneWithoutObservationsInput
    infirmier: UserCreateNestedOneWithoutObservationsCreesInput
  }

  export type ObservationInfirmierUncheckedCreateInput = {
    id?: string
    hospitalisationId: string
    infirmierId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type ObservationInfirmierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalisation?: HospitalisationUpdateOneRequiredWithoutObservationsNestedInput
    infirmier?: UserUpdateOneRequiredWithoutObservationsCreesNestedInput
  }

  export type ObservationInfirmierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalisationId?: StringFieldUpdateOperationsInput | string
    infirmierId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierCreateManyInput = {
    id?: string
    hospitalisationId: string
    infirmierId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type ObservationInfirmierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalisationId?: StringFieldUpdateOperationsInput | string
    infirmierId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateInput = {
    id?: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInterventionsInput
    chirurgien: UserCreateNestedOneWithoutChirurgiesInput
    anesthesiste?: UserCreateNestedOneWithoutAnesthesiesInput
  }

  export type InterventionUncheckedCreateInput = {
    id?: string
    patientId: string
    chirurgienId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInterventionsNestedInput
    chirurgien?: UserUpdateOneRequiredWithoutChirurgiesNestedInput
    anesthesiste?: UserUpdateOneWithoutAnesthesiesNestedInput
  }

  export type InterventionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionCreateManyInput = {
    id?: string
    patientId: string
    chirurgienId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DossierMaterniteCreateInput = {
    id?: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutDossiersMaterniteInput
    nouveauNes?: NouveauNeCreateNestedManyWithoutDossierMaterniteInput
  }

  export type DossierMaterniteUncheckedCreateInput = {
    id?: string
    patientId: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    nouveauNes?: NouveauNeUncheckedCreateNestedManyWithoutDossierMaterniteInput
  }

  export type DossierMaterniteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDossiersMaterniteNestedInput
    nouveauNes?: NouveauNeUpdateManyWithoutDossierMaterniteNestedInput
  }

  export type DossierMaterniteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nouveauNes?: NouveauNeUncheckedUpdateManyWithoutDossierMaterniteNestedInput
  }

  export type DossierMaterniteCreateManyInput = {
    id?: string
    patientId: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DossierMaterniteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DossierMaterniteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeCreateInput = {
    id?: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
    dossierMaternite: DossierMaterniteCreateNestedOneWithoutNouveauNesInput
  }

  export type NouveauNeUncheckedCreateInput = {
    id?: string
    dossierMaterniteId: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
  }

  export type NouveauNeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dossierMaternite?: DossierMaterniteUpdateOneRequiredWithoutNouveauNesNestedInput
  }

  export type NouveauNeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossierMaterniteId?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeCreateManyInput = {
    id?: string
    dossierMaterniteId: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
  }

  export type NouveauNeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dossierMaterniteId?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleLogistiqueCreateInput = {
    id?: string
    designation: string
    categorie: string
    famille?: string | null
    uniteMesure: string
    stockAlerte?: number
    stockActuel?: number
    createdAt?: Date | string
    mouvements?: MouvementLogistiqueCreateNestedManyWithoutArticleInput
  }

  export type ArticleLogistiqueUncheckedCreateInput = {
    id?: string
    designation: string
    categorie: string
    famille?: string | null
    uniteMesure: string
    stockAlerte?: number
    stockActuel?: number
    createdAt?: Date | string
    mouvements?: MouvementLogistiqueUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleLogistiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementLogistiqueUpdateManyWithoutArticleNestedInput
  }

  export type ArticleLogistiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementLogistiqueUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleLogistiqueCreateManyInput = {
    id?: string
    designation: string
    categorie: string
    famille?: string | null
    uniteMesure: string
    stockAlerte?: number
    stockActuel?: number
    createdAt?: Date | string
  }

  export type ArticleLogistiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleLogistiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueCreateInput = {
    id?: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
    article: ArticleLogistiqueCreateNestedOneWithoutMouvementsInput
  }

  export type MouvementLogistiqueUncheckedCreateInput = {
    id?: string
    articleId: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementLogistiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: ArticleLogistiqueUpdateOneRequiredWithoutMouvementsNestedInput
  }

  export type MouvementLogistiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueCreateManyInput = {
    id?: string
    articleId: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementLogistiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    articleId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDCreateInput = {
    id?: string
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    patient?: PatientCreateNestedOneWithoutDocumentsGEDInput
  }

  export type DocumentGEDUncheckedCreateInput = {
    id?: string
    patientId?: string | null
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentGEDUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutDocumentsGEDNestedInput
  }

  export type DocumentGEDUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDCreateManyInput = {
    id?: string
    patientId?: string | null
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentGEDUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeCreateInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeInput
    conges?: CongeCreateNestedManyWithoutEmployeInput
    plannings?: PlanningCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUncheckedCreateInput = {
    id?: string
    userId?: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conges?: CongeUncheckedCreateNestedManyWithoutEmployeInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeNestedInput
    conges?: CongeUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conges?: CongeUncheckedUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeCreateManyInput = {
    id?: string
    userId?: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeCreateInput = {
    id?: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
    employe: EmployeCreateNestedOneWithoutCongesInput
  }

  export type CongeUncheckedCreateInput = {
    id?: string
    employeId: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
  }

  export type CongeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeUpdateOneRequiredWithoutCongesNestedInput
  }

  export type CongeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeCreateManyInput = {
    id?: string
    employeId: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
  }

  export type CongeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulletinPaieCreateInput = {
    id?: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
    employe: EmployeCreateNestedOneWithoutBulletinsInput
    lignes?: LigneBulletinCreateNestedManyWithoutBulletinInput
  }

  export type BulletinPaieUncheckedCreateInput = {
    id?: string
    employeId: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
    lignes?: LigneBulletinUncheckedCreateNestedManyWithoutBulletinInput
  }

  export type BulletinPaieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    employe?: EmployeUpdateOneRequiredWithoutBulletinsNestedInput
    lignes?: LigneBulletinUpdateManyWithoutBulletinNestedInput
  }

  export type BulletinPaieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    lignes?: LigneBulletinUncheckedUpdateManyWithoutBulletinNestedInput
  }

  export type BulletinPaieCreateManyInput = {
    id?: string
    employeId: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
  }

  export type BulletinPaieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
  }

  export type BulletinPaieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
  }

  export type LigneBulletinCreateInput = {
    id?: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
    bulletin: BulletinPaieCreateNestedOneWithoutLignesInput
  }

  export type LigneBulletinUncheckedCreateInput = {
    id?: string
    bulletinId: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bulletin?: BulletinPaieUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneBulletinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bulletinId?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinCreateManyInput = {
    id?: string
    bulletinId: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bulletinId?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PlanningCreateInput = {
    id?: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
    employe: EmployeCreateNestedOneWithoutPlanningsInput
  }

  export type PlanningUncheckedCreateInput = {
    id?: string
    employeId: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
  }

  export type PlanningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employe?: EmployeUpdateOneRequiredWithoutPlanningsNestedInput
  }

  export type PlanningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningCreateManyInput = {
    id?: string
    employeId: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
  }

  export type PlanningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementCreateInput = {
    id?: string
    code: string
    nom: string
    type: string
    marque?: string | null
    modele?: string | null
    serie?: string | null
    dateAchat?: Date | string | null
    dateDerniereMaintenace?: Date | string | null
    dateProchaineMaintenance?: Date | string | null
    statut?: string
    localisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketMaintenanceCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUncheckedCreateInput = {
    id?: string
    code: string
    nom: string
    type: string
    marque?: string | null
    modele?: string | null
    serie?: string | null
    dateAchat?: Date | string | null
    dateDerniereMaintenace?: Date | string | null
    dateProchaineMaintenance?: Date | string | null
    statut?: string
    localisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketMaintenanceUncheckedCreateNestedManyWithoutEquipementInput
  }

  export type EquipementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketMaintenanceUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketMaintenanceUncheckedUpdateManyWithoutEquipementNestedInput
  }

  export type EquipementCreateManyInput = {
    id?: string
    code: string
    nom: string
    type: string
    marque?: string | null
    modele?: string | null
    serie?: string | null
    dateAchat?: Date | string | null
    dateDerniereMaintenace?: Date | string | null
    dateProchaineMaintenance?: Date | string | null
    statut?: string
    localisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMaintenanceCreateInput = {
    id?: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipement: EquipementCreateNestedOneWithoutTicketsInput
  }

  export type TicketMaintenanceUncheckedCreateInput = {
    id?: string
    equipementId: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipement?: EquipementUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketMaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipementId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMaintenanceCreateManyInput = {
    id?: string
    equipementId: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipementId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementIndesirableCreateInput = {
    id?: string
    dateEvenement?: Date | string
    service?: string | null
    type: string
    gravite: string
    description: string
    mesuresPrises?: string | null
    statut?: string
    declaréPar?: string | null
    patientId?: string | null
    createdAt?: Date | string
  }

  export type EvenementIndesirableUncheckedCreateInput = {
    id?: string
    dateEvenement?: Date | string
    service?: string | null
    type: string
    gravite: string
    description: string
    mesuresPrises?: string | null
    statut?: string
    declaréPar?: string | null
    patientId?: string | null
    createdAt?: Date | string
  }

  export type EvenementIndesirableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEvenement?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gravite?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mesuresPrises?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    declaréPar?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementIndesirableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEvenement?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gravite?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mesuresPrises?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    declaréPar?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementIndesirableCreateManyInput = {
    id?: string
    dateEvenement?: Date | string
    service?: string | null
    type: string
    gravite: string
    description: string
    mesuresPrises?: string | null
    statut?: string
    declaréPar?: string | null
    patientId?: string | null
    createdAt?: Date | string
  }

  export type EvenementIndesirableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEvenement?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gravite?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mesuresPrises?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    declaréPar?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvenementIndesirableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEvenement?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    gravite?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mesuresPrises?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    declaréPar?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditQualiteCreateInput = {
    id?: string
    dateAudit?: Date | string
    service: string
    auditeur: string
    type: string
    score: number
    observations?: string | null
    createdAt?: Date | string
  }

  export type AuditQualiteUncheckedCreateInput = {
    id?: string
    dateAudit?: Date | string
    service: string
    auditeur: string
    type: string
    score: number
    observations?: string | null
    createdAt?: Date | string
  }

  export type AuditQualiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAudit?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: StringFieldUpdateOperationsInput | string
    auditeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditQualiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAudit?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: StringFieldUpdateOperationsInput | string
    auditeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditQualiteCreateManyInput = {
    id?: string
    dateAudit?: Date | string
    service: string
    auditeur: string
    type: string
    score: number
    observations?: string | null
    createdAt?: Date | string
  }

  export type AuditQualiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAudit?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: StringFieldUpdateOperationsInput | string
    auditeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditQualiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateAudit?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: StringFieldUpdateOperationsInput | string
    auditeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateInput = {
    id?: string
    cle: string
    valeur: string
    type: string
    module: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUncheckedCreateInput = {
    id?: string
    cle: string
    valeur: string
    type: string
    module: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationCreateManyInput = {
    id?: string
    cle: string
    valeur: string
    type: string
    module: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cle?: StringFieldUpdateOperationsInput | string
    valeur?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type ConsultationListRelationFilter = {
    every?: ConsultationWhereInput
    some?: ConsultationWhereInput
    none?: ConsultationWhereInput
  }

  export type RendezVousListRelationFilter = {
    every?: RendezVousWhereInput
    some?: RendezVousWhereInput
    none?: RendezVousWhereInput
  }

  export type EcritureComptableListRelationFilter = {
    every?: EcritureComptableWhereInput
    some?: EcritureComptableWhereInput
    none?: EcritureComptableWhereInput
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ObservationInfirmierListRelationFilter = {
    every?: ObservationInfirmierWhereInput
    some?: ObservationInfirmierWhereInput
    none?: ObservationInfirmierWhereInput
  }

  export type InterventionListRelationFilter = {
    every?: InterventionWhereInput
    some?: InterventionWhereInput
    none?: InterventionWhereInput
  }

  export type EmployeNullableScalarRelationFilter = {
    is?: EmployeWhereInput | null
    isNot?: EmployeWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConsultationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RendezVousOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EcritureComptableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationInfirmierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    telephone?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    telephone?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    telephone?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionModuleActionCompoundUniqueInput = {
    module: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    module?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    module?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CompteComptableCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    libelle?: SortOrder
    classe?: SortOrder
    type?: SortOrder
    sens?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompteComptableAvgOrderByAggregateInput = {
    classe?: SortOrder
  }

  export type CompteComptableMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    libelle?: SortOrder
    classe?: SortOrder
    type?: SortOrder
    sens?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompteComptableMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    libelle?: SortOrder
    classe?: SortOrder
    type?: SortOrder
    sens?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompteComptableSumOrderByAggregateInput = {
    classe?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type JournalCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetListRelationFilter = {
    every?: BudgetWhereInput
    some?: BudgetWhereInput
    none?: BudgetWhereInput
  }

  export type BudgetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciceComptableCountOrderByAggregateInput = {
    id?: SortOrder
    annee?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cloture?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciceComptableAvgOrderByAggregateInput = {
    annee?: SortOrder
  }

  export type ExerciceComptableMaxOrderByAggregateInput = {
    id?: SortOrder
    annee?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cloture?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciceComptableMinOrderByAggregateInput = {
    id?: SortOrder
    annee?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    cloture?: SortOrder
    createdAt?: SortOrder
  }

  export type ExerciceComptableSumOrderByAggregateInput = {
    annee?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type JournalScalarRelationFilter = {
    is?: JournalWhereInput
    isNot?: JournalWhereInput
  }

  export type CompteComptableScalarRelationFilter = {
    is?: CompteComptableWhereInput
    isNot?: CompteComptableWhereInput
  }

  export type ExerciceComptableScalarRelationFilter = {
    is?: ExerciceComptableWhereInput
    isNot?: ExerciceComptableWhereInput
  }

  export type CentreAnalytiqueNullableScalarRelationFilter = {
    is?: CentreAnalytiqueWhereInput | null
    isNot?: CentreAnalytiqueWhereInput | null
  }

  export type EcritureComptableCountOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    compteId?: SortOrder
    exerciceId?: SortOrder
    dateEcriture?: SortOrder
    libelle?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    pieceRef?: SortOrder
    centreAnalytiqueId?: SortOrder
    valide?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EcritureComptableAvgOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type EcritureComptableMaxOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    compteId?: SortOrder
    exerciceId?: SortOrder
    dateEcriture?: SortOrder
    libelle?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    pieceRef?: SortOrder
    centreAnalytiqueId?: SortOrder
    valide?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EcritureComptableMinOrderByAggregateInput = {
    id?: SortOrder
    journalId?: SortOrder
    compteId?: SortOrder
    exerciceId?: SortOrder
    dateEcriture?: SortOrder
    libelle?: SortOrder
    debit?: SortOrder
    credit?: SortOrder
    pieceRef?: SortOrder
    centreAnalytiqueId?: SortOrder
    valide?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EcritureComptableSumOrderByAggregateInput = {
    debit?: SortOrder
    credit?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CentreAnalytiqueCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type CentreAnalytiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type CentreAnalytiqueMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BudgetCountOrderByAggregateInput = {
    id?: SortOrder
    exerciceId?: SortOrder
    compte?: SortOrder
    libelle?: SortOrder
    montant?: SortOrder
    type?: SortOrder
    mois?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetAvgOrderByAggregateInput = {
    montant?: SortOrder
    mois?: SortOrder
  }

  export type BudgetMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciceId?: SortOrder
    compte?: SortOrder
    libelle?: SortOrder
    montant?: SortOrder
    type?: SortOrder
    mois?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetMinOrderByAggregateInput = {
    id?: SortOrder
    exerciceId?: SortOrder
    compte?: SortOrder
    libelle?: SortOrder
    montant?: SortOrder
    type?: SortOrder
    mois?: SortOrder
    createdAt?: SortOrder
  }

  export type BudgetSumOrderByAggregateInput = {
    montant?: SortOrder
    mois?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AntecedentListRelationFilter = {
    every?: AntecedentWhereInput
    some?: AntecedentWhereInput
    none?: AntecedentWhereInput
  }

  export type AllergieListRelationFilter = {
    every?: AllergieWhereInput
    some?: AllergieWhereInput
    none?: AllergieWhereInput
  }

  export type VaccinationListRelationFilter = {
    every?: VaccinationWhereInput
    some?: VaccinationWhereInput
    none?: VaccinationWhereInput
  }

  export type FactureListRelationFilter = {
    every?: FactureWhereInput
    some?: FactureWhereInput
    none?: FactureWhereInput
  }

  export type DispensationListRelationFilter = {
    every?: DispensationWhereInput
    some?: DispensationWhereInput
    none?: DispensationWhereInput
  }

  export type HospitalisationListRelationFilter = {
    every?: HospitalisationWhereInput
    some?: HospitalisationWhereInput
    none?: HospitalisationWhereInput
  }

  export type DossierMaterniteListRelationFilter = {
    every?: DossierMaterniteWhereInput
    some?: DossierMaterniteWhereInput
    none?: DossierMaterniteWhereInput
  }

  export type DocumentGEDListRelationFilter = {
    every?: DocumentGEDWhereInput
    some?: DocumentGEDWhereInput
    none?: DocumentGEDWhereInput
  }

  export type AntecedentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AllergieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VaccinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DispensationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HospitalisationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DossierMaterniteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentGEDOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    numeroPatient?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    profession?: SortOrder
    situationMatrimoniale?: SortOrder
    assureur?: SortOrder
    numeroAssure?: SortOrder
    tauxCouverture?: SortOrder
    contactUrgenceNom?: SortOrder
    contactUrgenceTel?: SortOrder
    contactUrgenceLien?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    tauxCouverture?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroPatient?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    profession?: SortOrder
    situationMatrimoniale?: SortOrder
    assureur?: SortOrder
    numeroAssure?: SortOrder
    tauxCouverture?: SortOrder
    contactUrgenceNom?: SortOrder
    contactUrgenceTel?: SortOrder
    contactUrgenceLien?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    numeroPatient?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    ville?: SortOrder
    profession?: SortOrder
    situationMatrimoniale?: SortOrder
    assureur?: SortOrder
    numeroAssure?: SortOrder
    tauxCouverture?: SortOrder
    contactUrgenceNom?: SortOrder
    contactUrgenceTel?: SortOrder
    contactUrgenceLien?: SortOrder
    photo?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    tauxCouverture?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AntecedentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type AntecedentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type AntecedentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AllergieCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    allergene?: SortOrder
    severite?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
  }

  export type AllergieMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    allergene?: SortOrder
    severite?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
  }

  export type AllergieMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    type?: SortOrder
    allergene?: SortOrder
    severite?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccin?: SortOrder
    dateVaccin?: SortOrder
    rappel?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccin?: SortOrder
    dateVaccin?: SortOrder
    rappel?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
  }

  export type VaccinationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    vaccin?: SortOrder
    dateVaccin?: SortOrder
    rappel?: SortOrder
    lot?: SortOrder
    createdAt?: SortOrder
  }

  export type RendezVousCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateHeure?: SortOrder
    duree?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RendezVousAvgOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type RendezVousMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateHeure?: SortOrder
    duree?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RendezVousMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateHeure?: SortOrder
    duree?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RendezVousSumOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type ActeRealiseListRelationFilter = {
    every?: ActeRealiseWhereInput
    some?: ActeRealiseWhereInput
    none?: ActeRealiseWhereInput
  }

  export type FactureNullableScalarRelationFilter = {
    is?: FactureWhereInput | null
    isNot?: FactureWhereInput | null
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActeRealiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConsultationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateConsultation?: SortOrder
    motifConsultation?: SortOrder
    anamnese?: SortOrder
    examenClinique?: SortOrder
    diagnostic?: SortOrder
    planTraitement?: SortOrder
    poids?: SortOrder
    taille?: SortOrder
    temperature?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    frequenceCardiaque?: SortOrder
    saturationOxygene?: SortOrder
    donneesSpecialite?: SortOrder
    factureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationAvgOrderByAggregateInput = {
    poids?: SortOrder
    taille?: SortOrder
    temperature?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    frequenceCardiaque?: SortOrder
    saturationOxygene?: SortOrder
  }

  export type ConsultationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateConsultation?: SortOrder
    motifConsultation?: SortOrder
    anamnese?: SortOrder
    examenClinique?: SortOrder
    diagnostic?: SortOrder
    planTraitement?: SortOrder
    poids?: SortOrder
    taille?: SortOrder
    temperature?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    frequenceCardiaque?: SortOrder
    saturationOxygene?: SortOrder
    factureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    medecinId?: SortOrder
    dateConsultation?: SortOrder
    motifConsultation?: SortOrder
    anamnese?: SortOrder
    examenClinique?: SortOrder
    diagnostic?: SortOrder
    planTraitement?: SortOrder
    poids?: SortOrder
    taille?: SortOrder
    temperature?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    frequenceCardiaque?: SortOrder
    saturationOxygene?: SortOrder
    factureId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConsultationSumOrderByAggregateInput = {
    poids?: SortOrder
    taille?: SortOrder
    temperature?: SortOrder
    tensionSystolique?: SortOrder
    tensionDiastolique?: SortOrder
    frequenceCardiaque?: SortOrder
    saturationOxygene?: SortOrder
  }

  export type ConsultationScalarRelationFilter = {
    is?: ConsultationWhereInput
    isNot?: ConsultationWhereInput
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    medicament?: SortOrder
    dosage?: SortOrder
    forme?: SortOrder
    posologie?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    medicament?: SortOrder
    dosage?: SortOrder
    forme?: SortOrder
    posologie?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    medicament?: SortOrder
    dosage?: SortOrder
    forme?: SortOrder
    posologie?: SortOrder
    duree?: SortOrder
    quantite?: SortOrder
    instructions?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type NomenclatureActeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    specialite?: SortOrder
    tarif?: SortOrder
    duree?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type NomenclatureActeAvgOrderByAggregateInput = {
    tarif?: SortOrder
    duree?: SortOrder
  }

  export type NomenclatureActeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    specialite?: SortOrder
    tarif?: SortOrder
    duree?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type NomenclatureActeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    libelle?: SortOrder
    specialite?: SortOrder
    tarif?: SortOrder
    duree?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
  }

  export type NomenclatureActeSumOrderByAggregateInput = {
    tarif?: SortOrder
    duree?: SortOrder
  }

  export type NomenclatureActeScalarRelationFilter = {
    is?: NomenclatureActeWhereInput
    isNot?: NomenclatureActeWhereInput
  }

  export type ResultatExamenNullableScalarRelationFilter = {
    is?: ResultatExamenWhereInput | null
    isNot?: ResultatExamenWhereInput | null
  }

  export type ActeRealiseCountOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    acteId?: SortOrder
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ActeRealiseAvgOrderByAggregateInput = {
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
  }

  export type ActeRealiseMaxOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    acteId?: SortOrder
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ActeRealiseMinOrderByAggregateInput = {
    id?: SortOrder
    consultationId?: SortOrder
    acteId?: SortOrder
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ActeRealiseSumOrderByAggregateInput = {
    quantite?: SortOrder
    tarif?: SortOrder
    montant?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ActeRealiseScalarRelationFilter = {
    is?: ActeRealiseWhereInput
    isNot?: ActeRealiseWhereInput
  }

  export type ResultatExamenCountOrderByAggregateInput = {
    id?: SortOrder
    acteRealiseId?: SortOrder
    valeurs?: SortOrder
    conclusion?: SortOrder
    compteRendu?: SortOrder
    images?: SortOrder
    dateExamen?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultatExamenMaxOrderByAggregateInput = {
    id?: SortOrder
    acteRealiseId?: SortOrder
    conclusion?: SortOrder
    compteRendu?: SortOrder
    dateExamen?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultatExamenMinOrderByAggregateInput = {
    id?: SortOrder
    acteRealiseId?: SortOrder
    conclusion?: SortOrder
    compteRendu?: SortOrder
    dateExamen?: SortOrder
    validePar?: SortOrder
    dateValidation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockListRelationFilter = {
    every?: StockWhereInput
    some?: StockWhereInput
    none?: StockWhereInput
  }

  export type MouvementStockListRelationFilter = {
    every?: MouvementStockWhereInput
    some?: MouvementStockWhereInput
    none?: MouvementStockWhereInput
  }

  export type LigneCommandePharmacieListRelationFilter = {
    every?: LigneCommandePharmacieWhereInput
    some?: LigneCommandePharmacieWhereInput
    none?: LigneCommandePharmacieWhereInput
  }

  export type StockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MouvementStockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LigneCommandePharmacieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicamentCountOrderByAggregateInput = {
    id?: SortOrder
    codeANIS?: SortOrder
    dci?: SortOrder
    nomCommercial?: SortOrder
    forme?: SortOrder
    dosage?: SortOrder
    fabricant?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentAvgOrderByAggregateInput = {
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
  }

  export type MedicamentMaxOrderByAggregateInput = {
    id?: SortOrder
    codeANIS?: SortOrder
    dci?: SortOrder
    nomCommercial?: SortOrder
    forme?: SortOrder
    dosage?: SortOrder
    fabricant?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentMinOrderByAggregateInput = {
    id?: SortOrder
    codeANIS?: SortOrder
    dci?: SortOrder
    nomCommercial?: SortOrder
    forme?: SortOrder
    dosage?: SortOrder
    fabricant?: SortOrder
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicamentSumOrderByAggregateInput = {
    prixAchat?: SortOrder
    prixVente?: SortOrder
    stockMinimum?: SortOrder
  }

  export type CommandePharmacieListRelationFilter = {
    every?: CommandePharmacieWhereInput
    some?: CommandePharmacieWhereInput
    none?: CommandePharmacieWhereInput
  }

  export type CommandePharmacieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FournisseurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    ninea?: SortOrder
    rccm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    ninea?: SortOrder
    rccm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    contact?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    adresse?: SortOrder
    ninea?: SortOrder
    rccm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurScalarRelationFilter = {
    is?: FournisseurWhereInput
    isNot?: FournisseurWhereInput
  }

  export type CommandePharmacieCountOrderByAggregateInput = {
    id?: SortOrder
    numeroCommande?: SortOrder
    fournisseurId?: SortOrder
    dateCommande?: SortOrder
    dateLivraison?: SortOrder
    montantTotal?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandePharmacieAvgOrderByAggregateInput = {
    montantTotal?: SortOrder
  }

  export type CommandePharmacieMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroCommande?: SortOrder
    fournisseurId?: SortOrder
    dateCommande?: SortOrder
    dateLivraison?: SortOrder
    montantTotal?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandePharmacieMinOrderByAggregateInput = {
    id?: SortOrder
    numeroCommande?: SortOrder
    fournisseurId?: SortOrder
    dateCommande?: SortOrder
    dateLivraison?: SortOrder
    montantTotal?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandePharmacieSumOrderByAggregateInput = {
    montantTotal?: SortOrder
  }

  export type CommandePharmacieScalarRelationFilter = {
    is?: CommandePharmacieWhereInput
    isNot?: CommandePharmacieWhereInput
  }

  export type MedicamentScalarRelationFilter = {
    is?: MedicamentWhereInput
    isNot?: MedicamentWhereInput
  }

  export type LigneCommandePharmacieCountOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    medicamentId?: SortOrder
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneCommandePharmacieAvgOrderByAggregateInput = {
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
  }

  export type LigneCommandePharmacieMaxOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    medicamentId?: SortOrder
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneCommandePharmacieMinOrderByAggregateInput = {
    id?: SortOrder
    commandeId?: SortOrder
    medicamentId?: SortOrder
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneCommandePharmacieSumOrderByAggregateInput = {
    quantiteCommandee?: SortOrder
    quantiteRecue?: SortOrder
    prixUnitaire?: SortOrder
  }

  export type StockCountOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    lot?: SortOrder
    datePeremption?: SortOrder
    quantite?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type StockMaxOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    lot?: SortOrder
    datePeremption?: SortOrder
    quantite?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockMinOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    lot?: SortOrder
    datePeremption?: SortOrder
    quantite?: SortOrder
    emplacement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MouvementStockCountOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    motif?: SortOrder
    reference?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MouvementStockMaxOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    motif?: SortOrder
    reference?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockMinOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    motif?: SortOrder
    reference?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementStockSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type DispensationCountOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    patientId?: SortOrder
    quantite?: SortOrder
    prescription?: SortOrder
    pharmacien?: SortOrder
    createdAt?: SortOrder
  }

  export type DispensationAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type DispensationMaxOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    patientId?: SortOrder
    quantite?: SortOrder
    prescription?: SortOrder
    pharmacien?: SortOrder
    createdAt?: SortOrder
  }

  export type DispensationMinOrderByAggregateInput = {
    id?: SortOrder
    medicamentId?: SortOrder
    patientId?: SortOrder
    quantite?: SortOrder
    prescription?: SortOrder
    pharmacien?: SortOrder
    createdAt?: SortOrder
  }

  export type DispensationSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type LigneFactureListRelationFilter = {
    every?: LigneFactureWhereInput
    some?: LigneFactureWhereInput
    none?: LigneFactureWhereInput
  }

  export type LigneFactureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FactureCountOrderByAggregateInput = {
    id?: SortOrder
    numeroFacture?: SortOrder
    patientId?: SortOrder
    dateFacture?: SortOrder
    dateEcheance?: SortOrder
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
    statut?: SortOrder
    ecritureComptableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FactureAvgOrderByAggregateInput = {
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
  }

  export type FactureMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroFacture?: SortOrder
    patientId?: SortOrder
    dateFacture?: SortOrder
    dateEcheance?: SortOrder
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
    statut?: SortOrder
    ecritureComptableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FactureMinOrderByAggregateInput = {
    id?: SortOrder
    numeroFacture?: SortOrder
    patientId?: SortOrder
    dateFacture?: SortOrder
    dateEcheance?: SortOrder
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
    statut?: SortOrder
    ecritureComptableId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FactureSumOrderByAggregateInput = {
    montantHT?: SortOrder
    montantTVA?: SortOrder
    montantTTC?: SortOrder
    partAssurance?: SortOrder
    partPatient?: SortOrder
  }

  export type FactureScalarRelationFilter = {
    is?: FactureWhereInput
    isNot?: FactureWhereInput
  }

  export type LigneFactureCountOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    designation?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneFactureAvgOrderByAggregateInput = {
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
  }

  export type LigneFactureMaxOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    designation?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneFactureMinOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    designation?: SortOrder
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
    createdAt?: SortOrder
  }

  export type LigneFactureSumOrderByAggregateInput = {
    quantite?: SortOrder
    prixUnitaire?: SortOrder
    montant?: SortOrder
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    datePaiement?: SortOrder
    montant?: SortOrder
    modePaiement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    datePaiement?: SortOrder
    montant?: SortOrder
    modePaiement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    factureId?: SortOrder
    datePaiement?: SortOrder
    montant?: SortOrder
    modePaiement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    montant?: SortOrder
  }

  export type LitCountOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    chambre?: SortOrder
    service?: SortOrder
    categorie?: SortOrder
    prixJournalier?: SortOrder
    occupe?: SortOrder
    createdAt?: SortOrder
  }

  export type LitAvgOrderByAggregateInput = {
    prixJournalier?: SortOrder
  }

  export type LitMaxOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    chambre?: SortOrder
    service?: SortOrder
    categorie?: SortOrder
    prixJournalier?: SortOrder
    occupe?: SortOrder
    createdAt?: SortOrder
  }

  export type LitMinOrderByAggregateInput = {
    id?: SortOrder
    numero?: SortOrder
    chambre?: SortOrder
    service?: SortOrder
    categorie?: SortOrder
    prixJournalier?: SortOrder
    occupe?: SortOrder
    createdAt?: SortOrder
  }

  export type LitSumOrderByAggregateInput = {
    prixJournalier?: SortOrder
  }

  export type LitScalarRelationFilter = {
    is?: LitWhereInput
    isNot?: LitWhereInput
  }

  export type HospitalisationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    litId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    diagnosticEntree?: SortOrder
    diagnosticSortie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalisationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    litId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    diagnosticEntree?: SortOrder
    diagnosticSortie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalisationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    litId?: SortOrder
    dateEntree?: SortOrder
    dateSortie?: SortOrder
    motif?: SortOrder
    diagnosticEntree?: SortOrder
    diagnosticSortie?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HospitalisationScalarRelationFilter = {
    is?: HospitalisationWhereInput
    isNot?: HospitalisationWhereInput
  }

  export type ObservationInfirmierCountOrderByAggregateInput = {
    id?: SortOrder
    hospitalisationId?: SortOrder
    infirmierId?: SortOrder
    pressionArterielle?: SortOrder
    temperature?: SortOrder
    note?: SortOrder
    dateHeure?: SortOrder
  }

  export type ObservationInfirmierAvgOrderByAggregateInput = {
    temperature?: SortOrder
  }

  export type ObservationInfirmierMaxOrderByAggregateInput = {
    id?: SortOrder
    hospitalisationId?: SortOrder
    infirmierId?: SortOrder
    pressionArterielle?: SortOrder
    temperature?: SortOrder
    note?: SortOrder
    dateHeure?: SortOrder
  }

  export type ObservationInfirmierMinOrderByAggregateInput = {
    id?: SortOrder
    hospitalisationId?: SortOrder
    infirmierId?: SortOrder
    pressionArterielle?: SortOrder
    temperature?: SortOrder
    note?: SortOrder
    dateHeure?: SortOrder
  }

  export type ObservationInfirmierSumOrderByAggregateInput = {
    temperature?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InterventionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    chirurgienId?: SortOrder
    anesthesisteId?: SortOrder
    typeIntervention?: SortOrder
    dateHeure?: SortOrder
    salle?: SortOrder
    statut?: SortOrder
    protocoleOp?: SortOrder
    typeAnesthesie?: SortOrder
    duree?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionAvgOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type InterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    chirurgienId?: SortOrder
    anesthesisteId?: SortOrder
    typeIntervention?: SortOrder
    dateHeure?: SortOrder
    salle?: SortOrder
    statut?: SortOrder
    protocoleOp?: SortOrder
    typeAnesthesie?: SortOrder
    duree?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    chirurgienId?: SortOrder
    anesthesisteId?: SortOrder
    typeIntervention?: SortOrder
    dateHeure?: SortOrder
    salle?: SortOrder
    statut?: SortOrder
    protocoleOp?: SortOrder
    typeAnesthesie?: SortOrder
    duree?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionSumOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type NouveauNeListRelationFilter = {
    every?: NouveauNeWhereInput
    some?: NouveauNeWhereInput
    none?: NouveauNeWhereInput
  }

  export type NouveauNeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DossierMaterniteCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    dateDebutGrossesse?: SortOrder
    parite?: SortOrder
    gestite?: SortOrder
    groupageRhesus?: SortOrder
    examensPrenataux?: SortOrder
    accouchement?: SortOrder
    createdAt?: SortOrder
  }

  export type DossierMaterniteAvgOrderByAggregateInput = {
    parite?: SortOrder
    gestite?: SortOrder
  }

  export type DossierMaterniteMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    dateDebutGrossesse?: SortOrder
    parite?: SortOrder
    gestite?: SortOrder
    groupageRhesus?: SortOrder
    createdAt?: SortOrder
  }

  export type DossierMaterniteMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    dateDebutGrossesse?: SortOrder
    parite?: SortOrder
    gestite?: SortOrder
    groupageRhesus?: SortOrder
    createdAt?: SortOrder
  }

  export type DossierMaterniteSumOrderByAggregateInput = {
    parite?: SortOrder
    gestite?: SortOrder
  }

  export type DossierMaterniteScalarRelationFilter = {
    is?: DossierMaterniteWhereInput
    isNot?: DossierMaterniteWhereInput
  }

  export type NouveauNeCountOrderByAggregateInput = {
    id?: SortOrder
    dossierMaterniteId?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateHeureNaissance?: SortOrder
    sexe?: SortOrder
    poids?: SortOrder
    scoreApgar?: SortOrder
    createdAt?: SortOrder
  }

  export type NouveauNeAvgOrderByAggregateInput = {
    poids?: SortOrder
    scoreApgar?: SortOrder
  }

  export type NouveauNeMaxOrderByAggregateInput = {
    id?: SortOrder
    dossierMaterniteId?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateHeureNaissance?: SortOrder
    sexe?: SortOrder
    poids?: SortOrder
    scoreApgar?: SortOrder
    createdAt?: SortOrder
  }

  export type NouveauNeMinOrderByAggregateInput = {
    id?: SortOrder
    dossierMaterniteId?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateHeureNaissance?: SortOrder
    sexe?: SortOrder
    poids?: SortOrder
    scoreApgar?: SortOrder
    createdAt?: SortOrder
  }

  export type NouveauNeSumOrderByAggregateInput = {
    poids?: SortOrder
    scoreApgar?: SortOrder
  }

  export type MouvementLogistiqueListRelationFilter = {
    every?: MouvementLogistiqueWhereInput
    some?: MouvementLogistiqueWhereInput
    none?: MouvementLogistiqueWhereInput
  }

  export type MouvementLogistiqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArticleLogistiqueCountOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    categorie?: SortOrder
    famille?: SortOrder
    uniteMesure?: SortOrder
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleLogistiqueAvgOrderByAggregateInput = {
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
  }

  export type ArticleLogistiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    categorie?: SortOrder
    famille?: SortOrder
    uniteMesure?: SortOrder
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleLogistiqueMinOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    categorie?: SortOrder
    famille?: SortOrder
    uniteMesure?: SortOrder
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleLogistiqueSumOrderByAggregateInput = {
    stockAlerte?: SortOrder
    stockActuel?: SortOrder
  }

  export type ArticleLogistiqueScalarRelationFilter = {
    is?: ArticleLogistiqueWhereInput
    isNot?: ArticleLogistiqueWhereInput
  }

  export type MouvementLogistiqueCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    serviceDestinataire?: SortOrder
    motif?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementLogistiqueAvgOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type MouvementLogistiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    serviceDestinataire?: SortOrder
    motif?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementLogistiqueMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    type?: SortOrder
    quantite?: SortOrder
    serviceDestinataire?: SortOrder
    motif?: SortOrder
    utilisateur?: SortOrder
    createdAt?: SortOrder
  }

  export type MouvementLogistiqueSumOrderByAggregateInput = {
    quantite?: SortOrder
  }

  export type PatientNullableScalarRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type DocumentGEDCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    titre?: SortOrder
    type?: SortOrder
    url?: SortOrder
    module?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentGEDMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    titre?: SortOrder
    type?: SortOrder
    url?: SortOrder
    module?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentGEDMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    titre?: SortOrder
    type?: SortOrder
    url?: SortOrder
    module?: SortOrder
    createdAt?: SortOrder
  }

  export type CongeListRelationFilter = {
    every?: CongeWhereInput
    some?: CongeWhereInput
    none?: CongeWhereInput
  }

  export type PlanningListRelationFilter = {
    every?: PlanningWhereInput
    some?: PlanningWhereInput
    none?: PlanningWhereInput
  }

  export type BulletinPaieListRelationFilter = {
    every?: BulletinPaieWhereInput
    some?: BulletinPaieWhereInput
    none?: BulletinPaieWhereInput
  }

  export type CongeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BulletinPaieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    categorie?: SortOrder
    fonction?: SortOrder
    specialite?: SortOrder
    dateEmbauche?: SortOrder
    typeContrat?: SortOrder
    salaireBrut?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeAvgOrderByAggregateInput = {
    salaireBrut?: SortOrder
  }

  export type EmployeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    categorie?: SortOrder
    fonction?: SortOrder
    specialite?: SortOrder
    dateEmbauche?: SortOrder
    typeContrat?: SortOrder
    salaireBrut?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    matricule?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    dateNaissance?: SortOrder
    sexe?: SortOrder
    telephone?: SortOrder
    email?: SortOrder
    adresse?: SortOrder
    categorie?: SortOrder
    fonction?: SortOrder
    specialite?: SortOrder
    dateEmbauche?: SortOrder
    typeContrat?: SortOrder
    salaireBrut?: SortOrder
    actif?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeSumOrderByAggregateInput = {
    salaireBrut?: SortOrder
  }

  export type EmployeScalarRelationFilter = {
    is?: EmployeWhereInput
    isNot?: EmployeWhereInput
  }

  export type CongeCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nbJours?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
  }

  export type CongeAvgOrderByAggregateInput = {
    nbJours?: SortOrder
  }

  export type CongeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nbJours?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
  }

  export type CongeMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    nbJours?: SortOrder
    motif?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
  }

  export type CongeSumOrderByAggregateInput = {
    nbJours?: SortOrder
  }

  export type LigneBulletinListRelationFilter = {
    every?: LigneBulletinWhereInput
    some?: LigneBulletinWhereInput
    none?: LigneBulletinWhereInput
  }

  export type LigneBulletinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BulletinPaieCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    periode?: SortOrder
    dateEmission?: SortOrder
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
    statut?: SortOrder
  }

  export type BulletinPaieAvgOrderByAggregateInput = {
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
  }

  export type BulletinPaieMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    periode?: SortOrder
    dateEmission?: SortOrder
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
    statut?: SortOrder
  }

  export type BulletinPaieMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    periode?: SortOrder
    dateEmission?: SortOrder
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
    statut?: SortOrder
  }

  export type BulletinPaieSumOrderByAggregateInput = {
    salaireBase?: SortOrder
    totalPrimes?: SortOrder
    totalRetenues?: SortOrder
    salaireNet?: SortOrder
  }

  export type BulletinPaieScalarRelationFilter = {
    is?: BulletinPaieWhereInput
    isNot?: BulletinPaieWhereInput
  }

  export type LigneBulletinCountOrderByAggregateInput = {
    id?: SortOrder
    bulletinId?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    base?: SortOrder
    taux?: SortOrder
    montant?: SortOrder
  }

  export type LigneBulletinAvgOrderByAggregateInput = {
    base?: SortOrder
    taux?: SortOrder
    montant?: SortOrder
  }

  export type LigneBulletinMaxOrderByAggregateInput = {
    id?: SortOrder
    bulletinId?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    base?: SortOrder
    taux?: SortOrder
    montant?: SortOrder
  }

  export type LigneBulletinMinOrderByAggregateInput = {
    id?: SortOrder
    bulletinId?: SortOrder
    libelle?: SortOrder
    type?: SortOrder
    base?: SortOrder
    taux?: SortOrder
    montant?: SortOrder
  }

  export type LigneBulletinSumOrderByAggregateInput = {
    base?: SortOrder
    taux?: SortOrder
    montant?: SortOrder
  }

  export type PlanningCountOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanningMaxOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PlanningMinOrderByAggregateInput = {
    id?: SortOrder
    employeId?: SortOrder
    date?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type TicketMaintenanceListRelationFilter = {
    every?: TicketMaintenanceWhereInput
    some?: TicketMaintenanceWhereInput
    none?: TicketMaintenanceWhereInput
  }

  export type TicketMaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipementCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    serie?: SortOrder
    dateAchat?: SortOrder
    dateDerniereMaintenace?: SortOrder
    dateProchaineMaintenance?: SortOrder
    statut?: SortOrder
    localisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    serie?: SortOrder
    dateAchat?: SortOrder
    dateDerniereMaintenace?: SortOrder
    dateProchaineMaintenance?: SortOrder
    statut?: SortOrder
    localisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nom?: SortOrder
    type?: SortOrder
    marque?: SortOrder
    modele?: SortOrder
    serie?: SortOrder
    dateAchat?: SortOrder
    dateDerniereMaintenace?: SortOrder
    dateProchaineMaintenance?: SortOrder
    statut?: SortOrder
    localisation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipementScalarRelationFilter = {
    is?: EquipementWhereInput
    isNot?: EquipementWhereInput
  }

  export type TicketMaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    objet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    intervenant?: SortOrder
    dateResolution?: SortOrder
    coutEstime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaintenanceAvgOrderByAggregateInput = {
    coutEstime?: SortOrder
  }

  export type TicketMaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    objet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    intervenant?: SortOrder
    dateResolution?: SortOrder
    coutEstime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    equipementId?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    objet?: SortOrder
    description?: SortOrder
    statut?: SortOrder
    intervenant?: SortOrder
    dateResolution?: SortOrder
    coutEstime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMaintenanceSumOrderByAggregateInput = {
    coutEstime?: SortOrder
  }

  export type EvenementIndesirableCountOrderByAggregateInput = {
    id?: SortOrder
    dateEvenement?: SortOrder
    service?: SortOrder
    type?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    mesuresPrises?: SortOrder
    statut?: SortOrder
    declaréPar?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type EvenementIndesirableMaxOrderByAggregateInput = {
    id?: SortOrder
    dateEvenement?: SortOrder
    service?: SortOrder
    type?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    mesuresPrises?: SortOrder
    statut?: SortOrder
    declaréPar?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type EvenementIndesirableMinOrderByAggregateInput = {
    id?: SortOrder
    dateEvenement?: SortOrder
    service?: SortOrder
    type?: SortOrder
    gravite?: SortOrder
    description?: SortOrder
    mesuresPrises?: SortOrder
    statut?: SortOrder
    declaréPar?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditQualiteCountOrderByAggregateInput = {
    id?: SortOrder
    dateAudit?: SortOrder
    service?: SortOrder
    auditeur?: SortOrder
    type?: SortOrder
    score?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditQualiteAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type AuditQualiteMaxOrderByAggregateInput = {
    id?: SortOrder
    dateAudit?: SortOrder
    service?: SortOrder
    auditeur?: SortOrder
    type?: SortOrder
    score?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditQualiteMinOrderByAggregateInput = {
    id?: SortOrder
    dateAudit?: SortOrder
    service?: SortOrder
    auditeur?: SortOrder
    type?: SortOrder
    score?: SortOrder
    observations?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditQualiteSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    type?: SortOrder
    module?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    type?: SortOrder
    module?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    cle?: SortOrder
    valeur?: SortOrder
    type?: SortOrder
    module?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ConsultationCreateNestedManyWithoutMedecinInput = {
    create?: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput> | ConsultationCreateWithoutMedecinInput[] | ConsultationUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedecinInput | ConsultationCreateOrConnectWithoutMedecinInput[]
    createMany?: ConsultationCreateManyMedecinInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type RendezVousCreateNestedManyWithoutMedecinInput = {
    create?: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput> | RendezVousCreateWithoutMedecinInput[] | RendezVousUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutMedecinInput | RendezVousCreateOrConnectWithoutMedecinInput[]
    createMany?: RendezVousCreateManyMedecinInputEnvelope
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
  }

  export type EcritureComptableCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput> | EcritureComptableCreateWithoutCreatedByInput[] | EcritureComptableUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCreatedByInput | EcritureComptableCreateOrConnectWithoutCreatedByInput[]
    createMany?: EcritureComptableCreateManyCreatedByInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput> | PaiementCreateWithoutCreatedByInput[] | PaiementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCreatedByInput | PaiementCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaiementCreateManyCreatedByInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ObservationInfirmierCreateNestedManyWithoutInfirmierInput = {
    create?: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput> | ObservationInfirmierCreateWithoutInfirmierInput[] | ObservationInfirmierUncheckedCreateWithoutInfirmierInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutInfirmierInput | ObservationInfirmierCreateOrConnectWithoutInfirmierInput[]
    createMany?: ObservationInfirmierCreateManyInfirmierInputEnvelope
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutChirurgienInput = {
    create?: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput> | InterventionCreateWithoutChirurgienInput[] | InterventionUncheckedCreateWithoutChirurgienInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutChirurgienInput | InterventionCreateOrConnectWithoutChirurgienInput[]
    createMany?: InterventionCreateManyChirurgienInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutAnesthesisteInput = {
    create?: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput> | InterventionCreateWithoutAnesthesisteInput[] | InterventionUncheckedCreateWithoutAnesthesisteInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutAnesthesisteInput | InterventionCreateOrConnectWithoutAnesthesisteInput[]
    createMany?: InterventionCreateManyAnesthesisteInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type EmployeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutUserInput
    connect?: EmployeWhereUniqueInput
  }

  export type ConsultationUncheckedCreateNestedManyWithoutMedecinInput = {
    create?: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput> | ConsultationCreateWithoutMedecinInput[] | ConsultationUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedecinInput | ConsultationCreateOrConnectWithoutMedecinInput[]
    createMany?: ConsultationCreateManyMedecinInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type RendezVousUncheckedCreateNestedManyWithoutMedecinInput = {
    create?: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput> | RendezVousCreateWithoutMedecinInput[] | RendezVousUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutMedecinInput | RendezVousCreateOrConnectWithoutMedecinInput[]
    createMany?: RendezVousCreateManyMedecinInputEnvelope
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
  }

  export type EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput> | EcritureComptableCreateWithoutCreatedByInput[] | EcritureComptableUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCreatedByInput | EcritureComptableCreateOrConnectWithoutCreatedByInput[]
    createMany?: EcritureComptableCreateManyCreatedByInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput> | PaiementCreateWithoutCreatedByInput[] | PaiementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCreatedByInput | PaiementCreateOrConnectWithoutCreatedByInput[]
    createMany?: PaiementCreateManyCreatedByInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput = {
    create?: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput> | ObservationInfirmierCreateWithoutInfirmierInput[] | ObservationInfirmierUncheckedCreateWithoutInfirmierInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutInfirmierInput | ObservationInfirmierCreateOrConnectWithoutInfirmierInput[]
    createMany?: ObservationInfirmierCreateManyInfirmierInputEnvelope
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutChirurgienInput = {
    create?: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput> | InterventionCreateWithoutChirurgienInput[] | InterventionUncheckedCreateWithoutChirurgienInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutChirurgienInput | InterventionCreateOrConnectWithoutChirurgienInput[]
    createMany?: InterventionCreateManyChirurgienInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput = {
    create?: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput> | InterventionCreateWithoutAnesthesisteInput[] | InterventionUncheckedCreateWithoutAnesthesisteInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutAnesthesisteInput | InterventionCreateOrConnectWithoutAnesthesisteInput[]
    createMany?: InterventionCreateManyAnesthesisteInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type EmployeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutUserInput
    connect?: EmployeWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ConsultationUpdateManyWithoutMedecinNestedInput = {
    create?: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput> | ConsultationCreateWithoutMedecinInput[] | ConsultationUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedecinInput | ConsultationCreateOrConnectWithoutMedecinInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutMedecinInput | ConsultationUpsertWithWhereUniqueWithoutMedecinInput[]
    createMany?: ConsultationCreateManyMedecinInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutMedecinInput | ConsultationUpdateWithWhereUniqueWithoutMedecinInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutMedecinInput | ConsultationUpdateManyWithWhereWithoutMedecinInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type RendezVousUpdateManyWithoutMedecinNestedInput = {
    create?: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput> | RendezVousCreateWithoutMedecinInput[] | RendezVousUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutMedecinInput | RendezVousCreateOrConnectWithoutMedecinInput[]
    upsert?: RendezVousUpsertWithWhereUniqueWithoutMedecinInput | RendezVousUpsertWithWhereUniqueWithoutMedecinInput[]
    createMany?: RendezVousCreateManyMedecinInputEnvelope
    set?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    disconnect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    delete?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    update?: RendezVousUpdateWithWhereUniqueWithoutMedecinInput | RendezVousUpdateWithWhereUniqueWithoutMedecinInput[]
    updateMany?: RendezVousUpdateManyWithWhereWithoutMedecinInput | RendezVousUpdateManyWithWhereWithoutMedecinInput[]
    deleteMany?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
  }

  export type EcritureComptableUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput> | EcritureComptableCreateWithoutCreatedByInput[] | EcritureComptableUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCreatedByInput | EcritureComptableCreateOrConnectWithoutCreatedByInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCreatedByInput | EcritureComptableUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EcritureComptableCreateManyCreatedByInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCreatedByInput | EcritureComptableUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCreatedByInput | EcritureComptableUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput> | PaiementCreateWithoutCreatedByInput[] | PaiementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCreatedByInput | PaiementCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCreatedByInput | PaiementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaiementCreateManyCreatedByInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCreatedByInput | PaiementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCreatedByInput | PaiementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ObservationInfirmierUpdateManyWithoutInfirmierNestedInput = {
    create?: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput> | ObservationInfirmierCreateWithoutInfirmierInput[] | ObservationInfirmierUncheckedCreateWithoutInfirmierInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutInfirmierInput | ObservationInfirmierCreateOrConnectWithoutInfirmierInput[]
    upsert?: ObservationInfirmierUpsertWithWhereUniqueWithoutInfirmierInput | ObservationInfirmierUpsertWithWhereUniqueWithoutInfirmierInput[]
    createMany?: ObservationInfirmierCreateManyInfirmierInputEnvelope
    set?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    disconnect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    delete?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    update?: ObservationInfirmierUpdateWithWhereUniqueWithoutInfirmierInput | ObservationInfirmierUpdateWithWhereUniqueWithoutInfirmierInput[]
    updateMany?: ObservationInfirmierUpdateManyWithWhereWithoutInfirmierInput | ObservationInfirmierUpdateManyWithWhereWithoutInfirmierInput[]
    deleteMany?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutChirurgienNestedInput = {
    create?: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput> | InterventionCreateWithoutChirurgienInput[] | InterventionUncheckedCreateWithoutChirurgienInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutChirurgienInput | InterventionCreateOrConnectWithoutChirurgienInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutChirurgienInput | InterventionUpsertWithWhereUniqueWithoutChirurgienInput[]
    createMany?: InterventionCreateManyChirurgienInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutChirurgienInput | InterventionUpdateWithWhereUniqueWithoutChirurgienInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutChirurgienInput | InterventionUpdateManyWithWhereWithoutChirurgienInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutAnesthesisteNestedInput = {
    create?: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput> | InterventionCreateWithoutAnesthesisteInput[] | InterventionUncheckedCreateWithoutAnesthesisteInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutAnesthesisteInput | InterventionCreateOrConnectWithoutAnesthesisteInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutAnesthesisteInput | InterventionUpsertWithWhereUniqueWithoutAnesthesisteInput[]
    createMany?: InterventionCreateManyAnesthesisteInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutAnesthesisteInput | InterventionUpdateWithWhereUniqueWithoutAnesthesisteInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutAnesthesisteInput | InterventionUpdateManyWithWhereWithoutAnesthesisteInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type EmployeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutUserInput
    upsert?: EmployeUpsertWithoutUserInput
    disconnect?: EmployeWhereInput | boolean
    delete?: EmployeWhereInput | boolean
    connect?: EmployeWhereUniqueInput
    update?: XOR<XOR<EmployeUpdateToOneWithWhereWithoutUserInput, EmployeUpdateWithoutUserInput>, EmployeUncheckedUpdateWithoutUserInput>
  }

  export type ConsultationUncheckedUpdateManyWithoutMedecinNestedInput = {
    create?: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput> | ConsultationCreateWithoutMedecinInput[] | ConsultationUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutMedecinInput | ConsultationCreateOrConnectWithoutMedecinInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutMedecinInput | ConsultationUpsertWithWhereUniqueWithoutMedecinInput[]
    createMany?: ConsultationCreateManyMedecinInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutMedecinInput | ConsultationUpdateWithWhereUniqueWithoutMedecinInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutMedecinInput | ConsultationUpdateManyWithWhereWithoutMedecinInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type RendezVousUncheckedUpdateManyWithoutMedecinNestedInput = {
    create?: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput> | RendezVousCreateWithoutMedecinInput[] | RendezVousUncheckedCreateWithoutMedecinInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutMedecinInput | RendezVousCreateOrConnectWithoutMedecinInput[]
    upsert?: RendezVousUpsertWithWhereUniqueWithoutMedecinInput | RendezVousUpsertWithWhereUniqueWithoutMedecinInput[]
    createMany?: RendezVousCreateManyMedecinInputEnvelope
    set?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    disconnect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    delete?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    update?: RendezVousUpdateWithWhereUniqueWithoutMedecinInput | RendezVousUpdateWithWhereUniqueWithoutMedecinInput[]
    updateMany?: RendezVousUpdateManyWithWhereWithoutMedecinInput | RendezVousUpdateManyWithWhereWithoutMedecinInput[]
    deleteMany?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput> | EcritureComptableCreateWithoutCreatedByInput[] | EcritureComptableUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCreatedByInput | EcritureComptableCreateOrConnectWithoutCreatedByInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCreatedByInput | EcritureComptableUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EcritureComptableCreateManyCreatedByInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCreatedByInput | EcritureComptableUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCreatedByInput | EcritureComptableUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput> | PaiementCreateWithoutCreatedByInput[] | PaiementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCreatedByInput | PaiementCreateOrConnectWithoutCreatedByInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCreatedByInput | PaiementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PaiementCreateManyCreatedByInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCreatedByInput | PaiementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCreatedByInput | PaiementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput = {
    create?: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput> | ObservationInfirmierCreateWithoutInfirmierInput[] | ObservationInfirmierUncheckedCreateWithoutInfirmierInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutInfirmierInput | ObservationInfirmierCreateOrConnectWithoutInfirmierInput[]
    upsert?: ObservationInfirmierUpsertWithWhereUniqueWithoutInfirmierInput | ObservationInfirmierUpsertWithWhereUniqueWithoutInfirmierInput[]
    createMany?: ObservationInfirmierCreateManyInfirmierInputEnvelope
    set?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    disconnect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    delete?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    update?: ObservationInfirmierUpdateWithWhereUniqueWithoutInfirmierInput | ObservationInfirmierUpdateWithWhereUniqueWithoutInfirmierInput[]
    updateMany?: ObservationInfirmierUpdateManyWithWhereWithoutInfirmierInput | ObservationInfirmierUpdateManyWithWhereWithoutInfirmierInput[]
    deleteMany?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutChirurgienNestedInput = {
    create?: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput> | InterventionCreateWithoutChirurgienInput[] | InterventionUncheckedCreateWithoutChirurgienInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutChirurgienInput | InterventionCreateOrConnectWithoutChirurgienInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutChirurgienInput | InterventionUpsertWithWhereUniqueWithoutChirurgienInput[]
    createMany?: InterventionCreateManyChirurgienInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutChirurgienInput | InterventionUpdateWithWhereUniqueWithoutChirurgienInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutChirurgienInput | InterventionUpdateManyWithWhereWithoutChirurgienInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput = {
    create?: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput> | InterventionCreateWithoutAnesthesisteInput[] | InterventionUncheckedCreateWithoutAnesthesisteInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutAnesthesisteInput | InterventionCreateOrConnectWithoutAnesthesisteInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutAnesthesisteInput | InterventionUpsertWithWhereUniqueWithoutAnesthesisteInput[]
    createMany?: InterventionCreateManyAnesthesisteInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutAnesthesisteInput | InterventionUpdateWithWhereUniqueWithoutAnesthesisteInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutAnesthesisteInput | InterventionUpdateManyWithWhereWithoutAnesthesisteInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type EmployeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutUserInput
    upsert?: EmployeUpsertWithoutUserInput
    disconnect?: EmployeWhereInput | boolean
    delete?: EmployeWhereInput | boolean
    connect?: EmployeWhereUniqueInput
    update?: XOR<XOR<EmployeUpdateToOneWithWhereWithoutUserInput, EmployeUpdateWithoutUserInput>, EmployeUncheckedUpdateWithoutUserInput>
  }

  export type PermissionCreateNestedManyWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRolesInput | PermissionUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRolesInput | PermissionUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRolesInput | PermissionUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRolesInput | PermissionUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRolesInput | PermissionUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRolesInput | PermissionUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RoleCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput> | RoleCreateWithoutPermissionsInput[] | RoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput | RoleCreateOrConnectWithoutPermissionsInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput> | RoleCreateWithoutPermissionsInput[] | RoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput | RoleCreateOrConnectWithoutPermissionsInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
  }

  export type RoleUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput> | RoleCreateWithoutPermissionsInput[] | RoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput | RoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionsInput | RoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionsInput | RoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionsInput | RoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type RoleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput> | RoleCreateWithoutPermissionsInput[] | RoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput | RoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: RoleUpsertWithWhereUniqueWithoutPermissionsInput | RoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[]
    update?: RoleUpdateWithWhereUniqueWithoutPermissionsInput | RoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: RoleUpdateManyWithWhereWithoutPermissionsInput | RoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type EcritureComptableCreateNestedManyWithoutCompteInput = {
    create?: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput> | EcritureComptableCreateWithoutCompteInput[] | EcritureComptableUncheckedCreateWithoutCompteInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCompteInput | EcritureComptableCreateOrConnectWithoutCompteInput[]
    createMany?: EcritureComptableCreateManyCompteInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type EcritureComptableUncheckedCreateNestedManyWithoutCompteInput = {
    create?: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput> | EcritureComptableCreateWithoutCompteInput[] | EcritureComptableUncheckedCreateWithoutCompteInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCompteInput | EcritureComptableCreateOrConnectWithoutCompteInput[]
    createMany?: EcritureComptableCreateManyCompteInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EcritureComptableUpdateManyWithoutCompteNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput> | EcritureComptableCreateWithoutCompteInput[] | EcritureComptableUncheckedCreateWithoutCompteInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCompteInput | EcritureComptableCreateOrConnectWithoutCompteInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCompteInput | EcritureComptableUpsertWithWhereUniqueWithoutCompteInput[]
    createMany?: EcritureComptableCreateManyCompteInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCompteInput | EcritureComptableUpdateWithWhereUniqueWithoutCompteInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCompteInput | EcritureComptableUpdateManyWithWhereWithoutCompteInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCompteNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput> | EcritureComptableCreateWithoutCompteInput[] | EcritureComptableUncheckedCreateWithoutCompteInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCompteInput | EcritureComptableCreateOrConnectWithoutCompteInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCompteInput | EcritureComptableUpsertWithWhereUniqueWithoutCompteInput[]
    createMany?: EcritureComptableCreateManyCompteInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCompteInput | EcritureComptableUpdateWithWhereUniqueWithoutCompteInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCompteInput | EcritureComptableUpdateManyWithWhereWithoutCompteInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type EcritureComptableCreateNestedManyWithoutJournalInput = {
    create?: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput> | EcritureComptableCreateWithoutJournalInput[] | EcritureComptableUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutJournalInput | EcritureComptableCreateOrConnectWithoutJournalInput[]
    createMany?: EcritureComptableCreateManyJournalInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type EcritureComptableUncheckedCreateNestedManyWithoutJournalInput = {
    create?: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput> | EcritureComptableCreateWithoutJournalInput[] | EcritureComptableUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutJournalInput | EcritureComptableCreateOrConnectWithoutJournalInput[]
    createMany?: EcritureComptableCreateManyJournalInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type EcritureComptableUpdateManyWithoutJournalNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput> | EcritureComptableCreateWithoutJournalInput[] | EcritureComptableUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutJournalInput | EcritureComptableCreateOrConnectWithoutJournalInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutJournalInput | EcritureComptableUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: EcritureComptableCreateManyJournalInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutJournalInput | EcritureComptableUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutJournalInput | EcritureComptableUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type EcritureComptableUncheckedUpdateManyWithoutJournalNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput> | EcritureComptableCreateWithoutJournalInput[] | EcritureComptableUncheckedCreateWithoutJournalInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutJournalInput | EcritureComptableCreateOrConnectWithoutJournalInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutJournalInput | EcritureComptableUpsertWithWhereUniqueWithoutJournalInput[]
    createMany?: EcritureComptableCreateManyJournalInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutJournalInput | EcritureComptableUpdateWithWhereUniqueWithoutJournalInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutJournalInput | EcritureComptableUpdateManyWithWhereWithoutJournalInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type EcritureComptableCreateNestedManyWithoutExerciceInput = {
    create?: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput> | EcritureComptableCreateWithoutExerciceInput[] | EcritureComptableUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutExerciceInput | EcritureComptableCreateOrConnectWithoutExerciceInput[]
    createMany?: EcritureComptableCreateManyExerciceInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type BudgetCreateNestedManyWithoutExerciceInput = {
    create?: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput> | BudgetCreateWithoutExerciceInput[] | BudgetUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutExerciceInput | BudgetCreateOrConnectWithoutExerciceInput[]
    createMany?: BudgetCreateManyExerciceInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type EcritureComptableUncheckedCreateNestedManyWithoutExerciceInput = {
    create?: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput> | EcritureComptableCreateWithoutExerciceInput[] | EcritureComptableUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutExerciceInput | EcritureComptableCreateOrConnectWithoutExerciceInput[]
    createMany?: EcritureComptableCreateManyExerciceInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type BudgetUncheckedCreateNestedManyWithoutExerciceInput = {
    create?: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput> | BudgetCreateWithoutExerciceInput[] | BudgetUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutExerciceInput | BudgetCreateOrConnectWithoutExerciceInput[]
    createMany?: BudgetCreateManyExerciceInputEnvelope
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
  }

  export type EcritureComptableUpdateManyWithoutExerciceNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput> | EcritureComptableCreateWithoutExerciceInput[] | EcritureComptableUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutExerciceInput | EcritureComptableCreateOrConnectWithoutExerciceInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutExerciceInput | EcritureComptableUpsertWithWhereUniqueWithoutExerciceInput[]
    createMany?: EcritureComptableCreateManyExerciceInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutExerciceInput | EcritureComptableUpdateWithWhereUniqueWithoutExerciceInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutExerciceInput | EcritureComptableUpdateManyWithWhereWithoutExerciceInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type BudgetUpdateManyWithoutExerciceNestedInput = {
    create?: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput> | BudgetCreateWithoutExerciceInput[] | BudgetUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutExerciceInput | BudgetCreateOrConnectWithoutExerciceInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutExerciceInput | BudgetUpsertWithWhereUniqueWithoutExerciceInput[]
    createMany?: BudgetCreateManyExerciceInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutExerciceInput | BudgetUpdateWithWhereUniqueWithoutExerciceInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutExerciceInput | BudgetUpdateManyWithWhereWithoutExerciceInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type EcritureComptableUncheckedUpdateManyWithoutExerciceNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput> | EcritureComptableCreateWithoutExerciceInput[] | EcritureComptableUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutExerciceInput | EcritureComptableCreateOrConnectWithoutExerciceInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutExerciceInput | EcritureComptableUpsertWithWhereUniqueWithoutExerciceInput[]
    createMany?: EcritureComptableCreateManyExerciceInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutExerciceInput | EcritureComptableUpdateWithWhereUniqueWithoutExerciceInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutExerciceInput | EcritureComptableUpdateManyWithWhereWithoutExerciceInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type BudgetUncheckedUpdateManyWithoutExerciceNestedInput = {
    create?: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput> | BudgetCreateWithoutExerciceInput[] | BudgetUncheckedCreateWithoutExerciceInput[]
    connectOrCreate?: BudgetCreateOrConnectWithoutExerciceInput | BudgetCreateOrConnectWithoutExerciceInput[]
    upsert?: BudgetUpsertWithWhereUniqueWithoutExerciceInput | BudgetUpsertWithWhereUniqueWithoutExerciceInput[]
    createMany?: BudgetCreateManyExerciceInputEnvelope
    set?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    disconnect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    delete?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    connect?: BudgetWhereUniqueInput | BudgetWhereUniqueInput[]
    update?: BudgetUpdateWithWhereUniqueWithoutExerciceInput | BudgetUpdateWithWhereUniqueWithoutExerciceInput[]
    updateMany?: BudgetUpdateManyWithWhereWithoutExerciceInput | BudgetUpdateManyWithWhereWithoutExerciceInput[]
    deleteMany?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
  }

  export type JournalCreateNestedOneWithoutEcrituresInput = {
    create?: XOR<JournalCreateWithoutEcrituresInput, JournalUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: JournalCreateOrConnectWithoutEcrituresInput
    connect?: JournalWhereUniqueInput
  }

  export type CompteComptableCreateNestedOneWithoutEcrituresInput = {
    create?: XOR<CompteComptableCreateWithoutEcrituresInput, CompteComptableUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: CompteComptableCreateOrConnectWithoutEcrituresInput
    connect?: CompteComptableWhereUniqueInput
  }

  export type ExerciceComptableCreateNestedOneWithoutEcrituresInput = {
    create?: XOR<ExerciceComptableCreateWithoutEcrituresInput, ExerciceComptableUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: ExerciceComptableCreateOrConnectWithoutEcrituresInput
    connect?: ExerciceComptableWhereUniqueInput
  }

  export type CentreAnalytiqueCreateNestedOneWithoutEcrituresInput = {
    create?: XOR<CentreAnalytiqueCreateWithoutEcrituresInput, CentreAnalytiqueUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: CentreAnalytiqueCreateOrConnectWithoutEcrituresInput
    connect?: CentreAnalytiqueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEcrituresInput = {
    create?: XOR<UserCreateWithoutEcrituresInput, UserUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcrituresInput
    connect?: UserWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type JournalUpdateOneRequiredWithoutEcrituresNestedInput = {
    create?: XOR<JournalCreateWithoutEcrituresInput, JournalUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: JournalCreateOrConnectWithoutEcrituresInput
    upsert?: JournalUpsertWithoutEcrituresInput
    connect?: JournalWhereUniqueInput
    update?: XOR<XOR<JournalUpdateToOneWithWhereWithoutEcrituresInput, JournalUpdateWithoutEcrituresInput>, JournalUncheckedUpdateWithoutEcrituresInput>
  }

  export type CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput = {
    create?: XOR<CompteComptableCreateWithoutEcrituresInput, CompteComptableUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: CompteComptableCreateOrConnectWithoutEcrituresInput
    upsert?: CompteComptableUpsertWithoutEcrituresInput
    connect?: CompteComptableWhereUniqueInput
    update?: XOR<XOR<CompteComptableUpdateToOneWithWhereWithoutEcrituresInput, CompteComptableUpdateWithoutEcrituresInput>, CompteComptableUncheckedUpdateWithoutEcrituresInput>
  }

  export type ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput = {
    create?: XOR<ExerciceComptableCreateWithoutEcrituresInput, ExerciceComptableUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: ExerciceComptableCreateOrConnectWithoutEcrituresInput
    upsert?: ExerciceComptableUpsertWithoutEcrituresInput
    connect?: ExerciceComptableWhereUniqueInput
    update?: XOR<XOR<ExerciceComptableUpdateToOneWithWhereWithoutEcrituresInput, ExerciceComptableUpdateWithoutEcrituresInput>, ExerciceComptableUncheckedUpdateWithoutEcrituresInput>
  }

  export type CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput = {
    create?: XOR<CentreAnalytiqueCreateWithoutEcrituresInput, CentreAnalytiqueUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: CentreAnalytiqueCreateOrConnectWithoutEcrituresInput
    upsert?: CentreAnalytiqueUpsertWithoutEcrituresInput
    disconnect?: CentreAnalytiqueWhereInput | boolean
    delete?: CentreAnalytiqueWhereInput | boolean
    connect?: CentreAnalytiqueWhereUniqueInput
    update?: XOR<XOR<CentreAnalytiqueUpdateToOneWithWhereWithoutEcrituresInput, CentreAnalytiqueUpdateWithoutEcrituresInput>, CentreAnalytiqueUncheckedUpdateWithoutEcrituresInput>
  }

  export type UserUpdateOneRequiredWithoutEcrituresNestedInput = {
    create?: XOR<UserCreateWithoutEcrituresInput, UserUncheckedCreateWithoutEcrituresInput>
    connectOrCreate?: UserCreateOrConnectWithoutEcrituresInput
    upsert?: UserUpsertWithoutEcrituresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEcrituresInput, UserUpdateWithoutEcrituresInput>, UserUncheckedUpdateWithoutEcrituresInput>
  }

  export type EcritureComptableCreateNestedManyWithoutCentreAnalytiqueInput = {
    create?: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput> | EcritureComptableCreateWithoutCentreAnalytiqueInput[] | EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput | EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput[]
    createMany?: EcritureComptableCreateManyCentreAnalytiqueInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type EcritureComptableUncheckedCreateNestedManyWithoutCentreAnalytiqueInput = {
    create?: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput> | EcritureComptableCreateWithoutCentreAnalytiqueInput[] | EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput | EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput[]
    createMany?: EcritureComptableCreateManyCentreAnalytiqueInputEnvelope
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
  }

  export type EcritureComptableUpdateManyWithoutCentreAnalytiqueNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput> | EcritureComptableCreateWithoutCentreAnalytiqueInput[] | EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput | EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCentreAnalytiqueInput | EcritureComptableUpsertWithWhereUniqueWithoutCentreAnalytiqueInput[]
    createMany?: EcritureComptableCreateManyCentreAnalytiqueInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCentreAnalytiqueInput | EcritureComptableUpdateWithWhereUniqueWithoutCentreAnalytiqueInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCentreAnalytiqueInput | EcritureComptableUpdateManyWithWhereWithoutCentreAnalytiqueInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCentreAnalytiqueNestedInput = {
    create?: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput> | EcritureComptableCreateWithoutCentreAnalytiqueInput[] | EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput[]
    connectOrCreate?: EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput | EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput[]
    upsert?: EcritureComptableUpsertWithWhereUniqueWithoutCentreAnalytiqueInput | EcritureComptableUpsertWithWhereUniqueWithoutCentreAnalytiqueInput[]
    createMany?: EcritureComptableCreateManyCentreAnalytiqueInputEnvelope
    set?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    disconnect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    delete?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    connect?: EcritureComptableWhereUniqueInput | EcritureComptableWhereUniqueInput[]
    update?: EcritureComptableUpdateWithWhereUniqueWithoutCentreAnalytiqueInput | EcritureComptableUpdateWithWhereUniqueWithoutCentreAnalytiqueInput[]
    updateMany?: EcritureComptableUpdateManyWithWhereWithoutCentreAnalytiqueInput | EcritureComptableUpdateManyWithWhereWithoutCentreAnalytiqueInput[]
    deleteMany?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
  }

  export type ExerciceComptableCreateNestedOneWithoutBudgetsInput = {
    create?: XOR<ExerciceComptableCreateWithoutBudgetsInput, ExerciceComptableUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: ExerciceComptableCreateOrConnectWithoutBudgetsInput
    connect?: ExerciceComptableWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExerciceComptableUpdateOneRequiredWithoutBudgetsNestedInput = {
    create?: XOR<ExerciceComptableCreateWithoutBudgetsInput, ExerciceComptableUncheckedCreateWithoutBudgetsInput>
    connectOrCreate?: ExerciceComptableCreateOrConnectWithoutBudgetsInput
    upsert?: ExerciceComptableUpsertWithoutBudgetsInput
    connect?: ExerciceComptableWhereUniqueInput
    update?: XOR<XOR<ExerciceComptableUpdateToOneWithWhereWithoutBudgetsInput, ExerciceComptableUpdateWithoutBudgetsInput>, ExerciceComptableUncheckedUpdateWithoutBudgetsInput>
  }

  export type AntecedentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput> | AntecedentCreateWithoutPatientInput[] | AntecedentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AntecedentCreateOrConnectWithoutPatientInput | AntecedentCreateOrConnectWithoutPatientInput[]
    createMany?: AntecedentCreateManyPatientInputEnvelope
    connect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
  }

  export type AllergieCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput> | AllergieCreateWithoutPatientInput[] | AllergieUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergieCreateOrConnectWithoutPatientInput | AllergieCreateOrConnectWithoutPatientInput[]
    createMany?: AllergieCreateManyPatientInputEnvelope
    connect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
  }

  export type VaccinationCreateNestedManyWithoutPatientInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type ConsultationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type RendezVousCreateNestedManyWithoutPatientInput = {
    create?: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput> | RendezVousCreateWithoutPatientInput[] | RendezVousUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutPatientInput | RendezVousCreateOrConnectWithoutPatientInput[]
    createMany?: RendezVousCreateManyPatientInputEnvelope
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
  }

  export type FactureCreateNestedManyWithoutPatientInput = {
    create?: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput> | FactureCreateWithoutPatientInput[] | FactureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FactureCreateOrConnectWithoutPatientInput | FactureCreateOrConnectWithoutPatientInput[]
    createMany?: FactureCreateManyPatientInputEnvelope
    connect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
  }

  export type DispensationCreateNestedManyWithoutPatientInput = {
    create?: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput> | DispensationCreateWithoutPatientInput[] | DispensationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutPatientInput | DispensationCreateOrConnectWithoutPatientInput[]
    createMany?: DispensationCreateManyPatientInputEnvelope
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
  }

  export type HospitalisationCreateNestedManyWithoutPatientInput = {
    create?: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput> | HospitalisationCreateWithoutPatientInput[] | HospitalisationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutPatientInput | HospitalisationCreateOrConnectWithoutPatientInput[]
    createMany?: HospitalisationCreateManyPatientInputEnvelope
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutPatientInput = {
    create?: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput> | InterventionCreateWithoutPatientInput[] | InterventionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPatientInput | InterventionCreateOrConnectWithoutPatientInput[]
    createMany?: InterventionCreateManyPatientInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type DossierMaterniteCreateNestedManyWithoutPatientInput = {
    create?: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput> | DossierMaterniteCreateWithoutPatientInput[] | DossierMaterniteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutPatientInput | DossierMaterniteCreateOrConnectWithoutPatientInput[]
    createMany?: DossierMaterniteCreateManyPatientInputEnvelope
    connect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
  }

  export type DocumentGEDCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput> | DocumentGEDCreateWithoutPatientInput[] | DocumentGEDUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentGEDCreateOrConnectWithoutPatientInput | DocumentGEDCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentGEDCreateManyPatientInputEnvelope
    connect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
  }

  export type AntecedentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput> | AntecedentCreateWithoutPatientInput[] | AntecedentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AntecedentCreateOrConnectWithoutPatientInput | AntecedentCreateOrConnectWithoutPatientInput[]
    createMany?: AntecedentCreateManyPatientInputEnvelope
    connect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
  }

  export type AllergieUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput> | AllergieCreateWithoutPatientInput[] | AllergieUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergieCreateOrConnectWithoutPatientInput | AllergieCreateOrConnectWithoutPatientInput[]
    createMany?: AllergieCreateManyPatientInputEnvelope
    connect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type RendezVousUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput> | RendezVousCreateWithoutPatientInput[] | RendezVousUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutPatientInput | RendezVousCreateOrConnectWithoutPatientInput[]
    createMany?: RendezVousCreateManyPatientInputEnvelope
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
  }

  export type FactureUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput> | FactureCreateWithoutPatientInput[] | FactureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FactureCreateOrConnectWithoutPatientInput | FactureCreateOrConnectWithoutPatientInput[]
    createMany?: FactureCreateManyPatientInputEnvelope
    connect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
  }

  export type DispensationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput> | DispensationCreateWithoutPatientInput[] | DispensationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutPatientInput | DispensationCreateOrConnectWithoutPatientInput[]
    createMany?: DispensationCreateManyPatientInputEnvelope
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
  }

  export type HospitalisationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput> | HospitalisationCreateWithoutPatientInput[] | HospitalisationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutPatientInput | HospitalisationCreateOrConnectWithoutPatientInput[]
    createMany?: HospitalisationCreateManyPatientInputEnvelope
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput> | InterventionCreateWithoutPatientInput[] | InterventionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPatientInput | InterventionCreateOrConnectWithoutPatientInput[]
    createMany?: InterventionCreateManyPatientInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput> | DossierMaterniteCreateWithoutPatientInput[] | DossierMaterniteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutPatientInput | DossierMaterniteCreateOrConnectWithoutPatientInput[]
    createMany?: DossierMaterniteCreateManyPatientInputEnvelope
    connect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
  }

  export type DocumentGEDUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput> | DocumentGEDCreateWithoutPatientInput[] | DocumentGEDUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentGEDCreateOrConnectWithoutPatientInput | DocumentGEDCreateOrConnectWithoutPatientInput[]
    createMany?: DocumentGEDCreateManyPatientInputEnvelope
    connect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AntecedentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput> | AntecedentCreateWithoutPatientInput[] | AntecedentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AntecedentCreateOrConnectWithoutPatientInput | AntecedentCreateOrConnectWithoutPatientInput[]
    upsert?: AntecedentUpsertWithWhereUniqueWithoutPatientInput | AntecedentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AntecedentCreateManyPatientInputEnvelope
    set?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    disconnect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    delete?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    connect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    update?: AntecedentUpdateWithWhereUniqueWithoutPatientInput | AntecedentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AntecedentUpdateManyWithWhereWithoutPatientInput | AntecedentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AntecedentScalarWhereInput | AntecedentScalarWhereInput[]
  }

  export type AllergieUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput> | AllergieCreateWithoutPatientInput[] | AllergieUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergieCreateOrConnectWithoutPatientInput | AllergieCreateOrConnectWithoutPatientInput[]
    upsert?: AllergieUpsertWithWhereUniqueWithoutPatientInput | AllergieUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergieCreateManyPatientInputEnvelope
    set?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    disconnect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    delete?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    connect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    update?: AllergieUpdateWithWhereUniqueWithoutPatientInput | AllergieUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergieUpdateManyWithWhereWithoutPatientInput | AllergieUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergieScalarWhereInput | AllergieScalarWhereInput[]
  }

  export type VaccinationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutPatientInput | VaccinationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutPatientInput | VaccinationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutPatientInput | VaccinationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type ConsultationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type RendezVousUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput> | RendezVousCreateWithoutPatientInput[] | RendezVousUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutPatientInput | RendezVousCreateOrConnectWithoutPatientInput[]
    upsert?: RendezVousUpsertWithWhereUniqueWithoutPatientInput | RendezVousUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RendezVousCreateManyPatientInputEnvelope
    set?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    disconnect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    delete?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    update?: RendezVousUpdateWithWhereUniqueWithoutPatientInput | RendezVousUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RendezVousUpdateManyWithWhereWithoutPatientInput | RendezVousUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
  }

  export type FactureUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput> | FactureCreateWithoutPatientInput[] | FactureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FactureCreateOrConnectWithoutPatientInput | FactureCreateOrConnectWithoutPatientInput[]
    upsert?: FactureUpsertWithWhereUniqueWithoutPatientInput | FactureUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FactureCreateManyPatientInputEnvelope
    set?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    disconnect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    delete?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    connect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    update?: FactureUpdateWithWhereUniqueWithoutPatientInput | FactureUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FactureUpdateManyWithWhereWithoutPatientInput | FactureUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FactureScalarWhereInput | FactureScalarWhereInput[]
  }

  export type DispensationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput> | DispensationCreateWithoutPatientInput[] | DispensationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutPatientInput | DispensationCreateOrConnectWithoutPatientInput[]
    upsert?: DispensationUpsertWithWhereUniqueWithoutPatientInput | DispensationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DispensationCreateManyPatientInputEnvelope
    set?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    disconnect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    delete?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    update?: DispensationUpdateWithWhereUniqueWithoutPatientInput | DispensationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DispensationUpdateManyWithWhereWithoutPatientInput | DispensationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
  }

  export type HospitalisationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput> | HospitalisationCreateWithoutPatientInput[] | HospitalisationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutPatientInput | HospitalisationCreateOrConnectWithoutPatientInput[]
    upsert?: HospitalisationUpsertWithWhereUniqueWithoutPatientInput | HospitalisationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: HospitalisationCreateManyPatientInputEnvelope
    set?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    disconnect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    delete?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    update?: HospitalisationUpdateWithWhereUniqueWithoutPatientInput | HospitalisationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: HospitalisationUpdateManyWithWhereWithoutPatientInput | HospitalisationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput> | InterventionCreateWithoutPatientInput[] | InterventionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPatientInput | InterventionCreateOrConnectWithoutPatientInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutPatientInput | InterventionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InterventionCreateManyPatientInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutPatientInput | InterventionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutPatientInput | InterventionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type DossierMaterniteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput> | DossierMaterniteCreateWithoutPatientInput[] | DossierMaterniteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutPatientInput | DossierMaterniteCreateOrConnectWithoutPatientInput[]
    upsert?: DossierMaterniteUpsertWithWhereUniqueWithoutPatientInput | DossierMaterniteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DossierMaterniteCreateManyPatientInputEnvelope
    set?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    disconnect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    delete?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    connect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    update?: DossierMaterniteUpdateWithWhereUniqueWithoutPatientInput | DossierMaterniteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DossierMaterniteUpdateManyWithWhereWithoutPatientInput | DossierMaterniteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DossierMaterniteScalarWhereInput | DossierMaterniteScalarWhereInput[]
  }

  export type DocumentGEDUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput> | DocumentGEDCreateWithoutPatientInput[] | DocumentGEDUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentGEDCreateOrConnectWithoutPatientInput | DocumentGEDCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentGEDUpsertWithWhereUniqueWithoutPatientInput | DocumentGEDUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentGEDCreateManyPatientInputEnvelope
    set?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    disconnect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    delete?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    connect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    update?: DocumentGEDUpdateWithWhereUniqueWithoutPatientInput | DocumentGEDUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentGEDUpdateManyWithWhereWithoutPatientInput | DocumentGEDUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentGEDScalarWhereInput | DocumentGEDScalarWhereInput[]
  }

  export type AntecedentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput> | AntecedentCreateWithoutPatientInput[] | AntecedentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AntecedentCreateOrConnectWithoutPatientInput | AntecedentCreateOrConnectWithoutPatientInput[]
    upsert?: AntecedentUpsertWithWhereUniqueWithoutPatientInput | AntecedentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AntecedentCreateManyPatientInputEnvelope
    set?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    disconnect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    delete?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    connect?: AntecedentWhereUniqueInput | AntecedentWhereUniqueInput[]
    update?: AntecedentUpdateWithWhereUniqueWithoutPatientInput | AntecedentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AntecedentUpdateManyWithWhereWithoutPatientInput | AntecedentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AntecedentScalarWhereInput | AntecedentScalarWhereInput[]
  }

  export type AllergieUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput> | AllergieCreateWithoutPatientInput[] | AllergieUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AllergieCreateOrConnectWithoutPatientInput | AllergieCreateOrConnectWithoutPatientInput[]
    upsert?: AllergieUpsertWithWhereUniqueWithoutPatientInput | AllergieUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AllergieCreateManyPatientInputEnvelope
    set?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    disconnect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    delete?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    connect?: AllergieWhereUniqueInput | AllergieWhereUniqueInput[]
    update?: AllergieUpdateWithWhereUniqueWithoutPatientInput | AllergieUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AllergieUpdateManyWithWhereWithoutPatientInput | AllergieUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AllergieScalarWhereInput | AllergieScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput> | VaccinationCreateWithoutPatientInput[] | VaccinationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutPatientInput | VaccinationCreateOrConnectWithoutPatientInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutPatientInput | VaccinationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: VaccinationCreateManyPatientInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutPatientInput | VaccinationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutPatientInput | VaccinationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput> | ConsultationCreateWithoutPatientInput[] | ConsultationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutPatientInput | ConsultationCreateOrConnectWithoutPatientInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutPatientInput | ConsultationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ConsultationCreateManyPatientInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutPatientInput | ConsultationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutPatientInput | ConsultationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type RendezVousUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput> | RendezVousCreateWithoutPatientInput[] | RendezVousUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: RendezVousCreateOrConnectWithoutPatientInput | RendezVousCreateOrConnectWithoutPatientInput[]
    upsert?: RendezVousUpsertWithWhereUniqueWithoutPatientInput | RendezVousUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: RendezVousCreateManyPatientInputEnvelope
    set?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    disconnect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    delete?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    connect?: RendezVousWhereUniqueInput | RendezVousWhereUniqueInput[]
    update?: RendezVousUpdateWithWhereUniqueWithoutPatientInput | RendezVousUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: RendezVousUpdateManyWithWhereWithoutPatientInput | RendezVousUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
  }

  export type FactureUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput> | FactureCreateWithoutPatientInput[] | FactureUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: FactureCreateOrConnectWithoutPatientInput | FactureCreateOrConnectWithoutPatientInput[]
    upsert?: FactureUpsertWithWhereUniqueWithoutPatientInput | FactureUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: FactureCreateManyPatientInputEnvelope
    set?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    disconnect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    delete?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    connect?: FactureWhereUniqueInput | FactureWhereUniqueInput[]
    update?: FactureUpdateWithWhereUniqueWithoutPatientInput | FactureUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: FactureUpdateManyWithWhereWithoutPatientInput | FactureUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: FactureScalarWhereInput | FactureScalarWhereInput[]
  }

  export type DispensationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput> | DispensationCreateWithoutPatientInput[] | DispensationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutPatientInput | DispensationCreateOrConnectWithoutPatientInput[]
    upsert?: DispensationUpsertWithWhereUniqueWithoutPatientInput | DispensationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DispensationCreateManyPatientInputEnvelope
    set?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    disconnect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    delete?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    update?: DispensationUpdateWithWhereUniqueWithoutPatientInput | DispensationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DispensationUpdateManyWithWhereWithoutPatientInput | DispensationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
  }

  export type HospitalisationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput> | HospitalisationCreateWithoutPatientInput[] | HospitalisationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutPatientInput | HospitalisationCreateOrConnectWithoutPatientInput[]
    upsert?: HospitalisationUpsertWithWhereUniqueWithoutPatientInput | HospitalisationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: HospitalisationCreateManyPatientInputEnvelope
    set?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    disconnect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    delete?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    update?: HospitalisationUpdateWithWhereUniqueWithoutPatientInput | HospitalisationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: HospitalisationUpdateManyWithWhereWithoutPatientInput | HospitalisationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput> | InterventionCreateWithoutPatientInput[] | InterventionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPatientInput | InterventionCreateOrConnectWithoutPatientInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutPatientInput | InterventionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InterventionCreateManyPatientInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutPatientInput | InterventionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutPatientInput | InterventionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput> | DossierMaterniteCreateWithoutPatientInput[] | DossierMaterniteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutPatientInput | DossierMaterniteCreateOrConnectWithoutPatientInput[]
    upsert?: DossierMaterniteUpsertWithWhereUniqueWithoutPatientInput | DossierMaterniteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DossierMaterniteCreateManyPatientInputEnvelope
    set?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    disconnect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    delete?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    connect?: DossierMaterniteWhereUniqueInput | DossierMaterniteWhereUniqueInput[]
    update?: DossierMaterniteUpdateWithWhereUniqueWithoutPatientInput | DossierMaterniteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DossierMaterniteUpdateManyWithWhereWithoutPatientInput | DossierMaterniteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DossierMaterniteScalarWhereInput | DossierMaterniteScalarWhereInput[]
  }

  export type DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput> | DocumentGEDCreateWithoutPatientInput[] | DocumentGEDUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DocumentGEDCreateOrConnectWithoutPatientInput | DocumentGEDCreateOrConnectWithoutPatientInput[]
    upsert?: DocumentGEDUpsertWithWhereUniqueWithoutPatientInput | DocumentGEDUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DocumentGEDCreateManyPatientInputEnvelope
    set?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    disconnect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    delete?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    connect?: DocumentGEDWhereUniqueInput | DocumentGEDWhereUniqueInput[]
    update?: DocumentGEDUpdateWithWhereUniqueWithoutPatientInput | DocumentGEDUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DocumentGEDUpdateManyWithWhereWithoutPatientInput | DocumentGEDUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DocumentGEDScalarWhereInput | DocumentGEDScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAntecedentsInput = {
    create?: XOR<PatientCreateWithoutAntecedentsInput, PatientUncheckedCreateWithoutAntecedentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAntecedentsInput
    connect?: PatientWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PatientUpdateOneRequiredWithoutAntecedentsNestedInput = {
    create?: XOR<PatientCreateWithoutAntecedentsInput, PatientUncheckedCreateWithoutAntecedentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAntecedentsInput
    upsert?: PatientUpsertWithoutAntecedentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAntecedentsInput, PatientUpdateWithoutAntecedentsInput>, PatientUncheckedUpdateWithoutAntecedentsInput>
  }

  export type PatientCreateNestedOneWithoutAllergiesInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAllergiesNestedInput = {
    create?: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAllergiesInput
    upsert?: PatientUpsertWithoutAllergiesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAllergiesInput, PatientUpdateWithoutAllergiesInput>, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVaccinationsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutVaccinationsNestedInput = {
    create?: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutVaccinationsInput
    upsert?: PatientUpsertWithoutVaccinationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutVaccinationsInput, PatientUpdateWithoutVaccinationsInput>, PatientUncheckedUpdateWithoutVaccinationsInput>
  }

  export type PatientCreateNestedOneWithoutRendezvousInput = {
    create?: XOR<PatientCreateWithoutRendezvousInput, PatientUncheckedCreateWithoutRendezvousInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRendezvousInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRendezvousInput = {
    create?: XOR<UserCreateWithoutRendezvousInput, UserUncheckedCreateWithoutRendezvousInput>
    connectOrCreate?: UserCreateOrConnectWithoutRendezvousInput
    connect?: UserWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutRendezvousNestedInput = {
    create?: XOR<PatientCreateWithoutRendezvousInput, PatientUncheckedCreateWithoutRendezvousInput>
    connectOrCreate?: PatientCreateOrConnectWithoutRendezvousInput
    upsert?: PatientUpsertWithoutRendezvousInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutRendezvousInput, PatientUpdateWithoutRendezvousInput>, PatientUncheckedUpdateWithoutRendezvousInput>
  }

  export type UserUpdateOneRequiredWithoutRendezvousNestedInput = {
    create?: XOR<UserCreateWithoutRendezvousInput, UserUncheckedCreateWithoutRendezvousInput>
    connectOrCreate?: UserCreateOrConnectWithoutRendezvousInput
    upsert?: UserUpsertWithoutRendezvousInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRendezvousInput, UserUpdateWithoutRendezvousInput>, UserUncheckedUpdateWithoutRendezvousInput>
  }

  export type PatientCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationsInput
    connect?: UserWhereUniqueInput
  }

  export type PrescriptionCreateNestedManyWithoutConsultationInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type ActeRealiseCreateNestedManyWithoutConsultationInput = {
    create?: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput> | ActeRealiseCreateWithoutConsultationInput[] | ActeRealiseUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutConsultationInput | ActeRealiseCreateOrConnectWithoutConsultationInput[]
    createMany?: ActeRealiseCreateManyConsultationInputEnvelope
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
  }

  export type FactureCreateNestedOneWithoutConsultationsInput = {
    create?: XOR<FactureCreateWithoutConsultationsInput, FactureUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: FactureCreateOrConnectWithoutConsultationsInput
    connect?: FactureWhereUniqueInput
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput = {
    create?: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput> | ActeRealiseCreateWithoutConsultationInput[] | ActeRealiseUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutConsultationInput | ActeRealiseCreateOrConnectWithoutConsultationInput[]
    createMany?: ActeRealiseCreateManyConsultationInputEnvelope
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutConsultationsInput
    upsert?: PatientUpsertWithoutConsultationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutConsultationsInput, PatientUpdateWithoutConsultationsInput>, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type UserUpdateOneRequiredWithoutConsultationsNestedInput = {
    create?: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsultationsInput
    upsert?: UserUpsertWithoutConsultationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsultationsInput, UserUpdateWithoutConsultationsInput>, UserUncheckedUpdateWithoutConsultationsInput>
  }

  export type PrescriptionUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutConsultationInput | PrescriptionUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutConsultationInput | PrescriptionUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutConsultationInput | PrescriptionUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type ActeRealiseUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput> | ActeRealiseCreateWithoutConsultationInput[] | ActeRealiseUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutConsultationInput | ActeRealiseCreateOrConnectWithoutConsultationInput[]
    upsert?: ActeRealiseUpsertWithWhereUniqueWithoutConsultationInput | ActeRealiseUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: ActeRealiseCreateManyConsultationInputEnvelope
    set?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    disconnect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    delete?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    update?: ActeRealiseUpdateWithWhereUniqueWithoutConsultationInput | ActeRealiseUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: ActeRealiseUpdateManyWithWhereWithoutConsultationInput | ActeRealiseUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
  }

  export type FactureUpdateOneWithoutConsultationsNestedInput = {
    create?: XOR<FactureCreateWithoutConsultationsInput, FactureUncheckedCreateWithoutConsultationsInput>
    connectOrCreate?: FactureCreateOrConnectWithoutConsultationsInput
    upsert?: FactureUpsertWithoutConsultationsInput
    disconnect?: FactureWhereInput | boolean
    delete?: FactureWhereInput | boolean
    connect?: FactureWhereUniqueInput
    update?: XOR<XOR<FactureUpdateToOneWithWhereWithoutConsultationsInput, FactureUpdateWithoutConsultationsInput>, FactureUncheckedUpdateWithoutConsultationsInput>
  }

  export type PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput> | PrescriptionCreateWithoutConsultationInput[] | PrescriptionUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutConsultationInput | PrescriptionCreateOrConnectWithoutConsultationInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutConsultationInput | PrescriptionUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: PrescriptionCreateManyConsultationInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutConsultationInput | PrescriptionUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutConsultationInput | PrescriptionUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput = {
    create?: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput> | ActeRealiseCreateWithoutConsultationInput[] | ActeRealiseUncheckedCreateWithoutConsultationInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutConsultationInput | ActeRealiseCreateOrConnectWithoutConsultationInput[]
    upsert?: ActeRealiseUpsertWithWhereUniqueWithoutConsultationInput | ActeRealiseUpsertWithWhereUniqueWithoutConsultationInput[]
    createMany?: ActeRealiseCreateManyConsultationInputEnvelope
    set?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    disconnect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    delete?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    update?: ActeRealiseUpdateWithWhereUniqueWithoutConsultationInput | ActeRealiseUpdateWithWhereUniqueWithoutConsultationInput[]
    updateMany?: ActeRealiseUpdateManyWithWhereWithoutConsultationInput | ActeRealiseUpdateManyWithWhereWithoutConsultationInput[]
    deleteMany?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
  }

  export type ConsultationCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutPrescriptionsInput
    connect?: ConsultationWhereUniqueInput
  }

  export type ConsultationUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutPrescriptionsInput
    upsert?: ConsultationUpsertWithoutPrescriptionsInput
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutPrescriptionsInput, ConsultationUpdateWithoutPrescriptionsInput>, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type ActeRealiseCreateNestedManyWithoutActeInput = {
    create?: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput> | ActeRealiseCreateWithoutActeInput[] | ActeRealiseUncheckedCreateWithoutActeInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutActeInput | ActeRealiseCreateOrConnectWithoutActeInput[]
    createMany?: ActeRealiseCreateManyActeInputEnvelope
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
  }

  export type ActeRealiseUncheckedCreateNestedManyWithoutActeInput = {
    create?: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput> | ActeRealiseCreateWithoutActeInput[] | ActeRealiseUncheckedCreateWithoutActeInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutActeInput | ActeRealiseCreateOrConnectWithoutActeInput[]
    createMany?: ActeRealiseCreateManyActeInputEnvelope
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
  }

  export type ActeRealiseUpdateManyWithoutActeNestedInput = {
    create?: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput> | ActeRealiseCreateWithoutActeInput[] | ActeRealiseUncheckedCreateWithoutActeInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutActeInput | ActeRealiseCreateOrConnectWithoutActeInput[]
    upsert?: ActeRealiseUpsertWithWhereUniqueWithoutActeInput | ActeRealiseUpsertWithWhereUniqueWithoutActeInput[]
    createMany?: ActeRealiseCreateManyActeInputEnvelope
    set?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    disconnect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    delete?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    update?: ActeRealiseUpdateWithWhereUniqueWithoutActeInput | ActeRealiseUpdateWithWhereUniqueWithoutActeInput[]
    updateMany?: ActeRealiseUpdateManyWithWhereWithoutActeInput | ActeRealiseUpdateManyWithWhereWithoutActeInput[]
    deleteMany?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
  }

  export type ActeRealiseUncheckedUpdateManyWithoutActeNestedInput = {
    create?: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput> | ActeRealiseCreateWithoutActeInput[] | ActeRealiseUncheckedCreateWithoutActeInput[]
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutActeInput | ActeRealiseCreateOrConnectWithoutActeInput[]
    upsert?: ActeRealiseUpsertWithWhereUniqueWithoutActeInput | ActeRealiseUpsertWithWhereUniqueWithoutActeInput[]
    createMany?: ActeRealiseCreateManyActeInputEnvelope
    set?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    disconnect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    delete?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    connect?: ActeRealiseWhereUniqueInput | ActeRealiseWhereUniqueInput[]
    update?: ActeRealiseUpdateWithWhereUniqueWithoutActeInput | ActeRealiseUpdateWithWhereUniqueWithoutActeInput[]
    updateMany?: ActeRealiseUpdateManyWithWhereWithoutActeInput | ActeRealiseUpdateManyWithWhereWithoutActeInput[]
    deleteMany?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
  }

  export type ConsultationCreateNestedOneWithoutActesRealisesInput = {
    create?: XOR<ConsultationCreateWithoutActesRealisesInput, ConsultationUncheckedCreateWithoutActesRealisesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutActesRealisesInput
    connect?: ConsultationWhereUniqueInput
  }

  export type NomenclatureActeCreateNestedOneWithoutActesInput = {
    create?: XOR<NomenclatureActeCreateWithoutActesInput, NomenclatureActeUncheckedCreateWithoutActesInput>
    connectOrCreate?: NomenclatureActeCreateOrConnectWithoutActesInput
    connect?: NomenclatureActeWhereUniqueInput
  }

  export type ResultatExamenCreateNestedOneWithoutActeRealiseInput = {
    create?: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
    connectOrCreate?: ResultatExamenCreateOrConnectWithoutActeRealiseInput
    connect?: ResultatExamenWhereUniqueInput
  }

  export type ResultatExamenUncheckedCreateNestedOneWithoutActeRealiseInput = {
    create?: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
    connectOrCreate?: ResultatExamenCreateOrConnectWithoutActeRealiseInput
    connect?: ResultatExamenWhereUniqueInput
  }

  export type ConsultationUpdateOneRequiredWithoutActesRealisesNestedInput = {
    create?: XOR<ConsultationCreateWithoutActesRealisesInput, ConsultationUncheckedCreateWithoutActesRealisesInput>
    connectOrCreate?: ConsultationCreateOrConnectWithoutActesRealisesInput
    upsert?: ConsultationUpsertWithoutActesRealisesInput
    connect?: ConsultationWhereUniqueInput
    update?: XOR<XOR<ConsultationUpdateToOneWithWhereWithoutActesRealisesInput, ConsultationUpdateWithoutActesRealisesInput>, ConsultationUncheckedUpdateWithoutActesRealisesInput>
  }

  export type NomenclatureActeUpdateOneRequiredWithoutActesNestedInput = {
    create?: XOR<NomenclatureActeCreateWithoutActesInput, NomenclatureActeUncheckedCreateWithoutActesInput>
    connectOrCreate?: NomenclatureActeCreateOrConnectWithoutActesInput
    upsert?: NomenclatureActeUpsertWithoutActesInput
    connect?: NomenclatureActeWhereUniqueInput
    update?: XOR<XOR<NomenclatureActeUpdateToOneWithWhereWithoutActesInput, NomenclatureActeUpdateWithoutActesInput>, NomenclatureActeUncheckedUpdateWithoutActesInput>
  }

  export type ResultatExamenUpdateOneWithoutActeRealiseNestedInput = {
    create?: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
    connectOrCreate?: ResultatExamenCreateOrConnectWithoutActeRealiseInput
    upsert?: ResultatExamenUpsertWithoutActeRealiseInput
    disconnect?: ResultatExamenWhereInput | boolean
    delete?: ResultatExamenWhereInput | boolean
    connect?: ResultatExamenWhereUniqueInput
    update?: XOR<XOR<ResultatExamenUpdateToOneWithWhereWithoutActeRealiseInput, ResultatExamenUpdateWithoutActeRealiseInput>, ResultatExamenUncheckedUpdateWithoutActeRealiseInput>
  }

  export type ResultatExamenUncheckedUpdateOneWithoutActeRealiseNestedInput = {
    create?: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
    connectOrCreate?: ResultatExamenCreateOrConnectWithoutActeRealiseInput
    upsert?: ResultatExamenUpsertWithoutActeRealiseInput
    disconnect?: ResultatExamenWhereInput | boolean
    delete?: ResultatExamenWhereInput | boolean
    connect?: ResultatExamenWhereUniqueInput
    update?: XOR<XOR<ResultatExamenUpdateToOneWithWhereWithoutActeRealiseInput, ResultatExamenUpdateWithoutActeRealiseInput>, ResultatExamenUncheckedUpdateWithoutActeRealiseInput>
  }

  export type ResultatExamenCreateimagesInput = {
    set: string[]
  }

  export type ActeRealiseCreateNestedOneWithoutResultatInput = {
    create?: XOR<ActeRealiseCreateWithoutResultatInput, ActeRealiseUncheckedCreateWithoutResultatInput>
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutResultatInput
    connect?: ActeRealiseWhereUniqueInput
  }

  export type ResultatExamenUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ActeRealiseUpdateOneRequiredWithoutResultatNestedInput = {
    create?: XOR<ActeRealiseCreateWithoutResultatInput, ActeRealiseUncheckedCreateWithoutResultatInput>
    connectOrCreate?: ActeRealiseCreateOrConnectWithoutResultatInput
    upsert?: ActeRealiseUpsertWithoutResultatInput
    connect?: ActeRealiseWhereUniqueInput
    update?: XOR<XOR<ActeRealiseUpdateToOneWithWhereWithoutResultatInput, ActeRealiseUpdateWithoutResultatInput>, ActeRealiseUncheckedUpdateWithoutResultatInput>
  }

  export type StockCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput> | StockCreateWithoutMedicamentInput[] | StockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: StockCreateOrConnectWithoutMedicamentInput | StockCreateOrConnectWithoutMedicamentInput[]
    createMany?: StockCreateManyMedicamentInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type MouvementStockCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput> | MouvementStockCreateWithoutMedicamentInput[] | MouvementStockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutMedicamentInput | MouvementStockCreateOrConnectWithoutMedicamentInput[]
    createMany?: MouvementStockCreateManyMedicamentInputEnvelope
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
  }

  export type DispensationCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput> | DispensationCreateWithoutMedicamentInput[] | DispensationUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutMedicamentInput | DispensationCreateOrConnectWithoutMedicamentInput[]
    createMany?: DispensationCreateManyMedicamentInputEnvelope
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
  }

  export type LigneCommandePharmacieCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput> | LigneCommandePharmacieCreateWithoutMedicamentInput[] | LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput | LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput[]
    createMany?: LigneCommandePharmacieCreateManyMedicamentInputEnvelope
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
  }

  export type StockUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput> | StockCreateWithoutMedicamentInput[] | StockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: StockCreateOrConnectWithoutMedicamentInput | StockCreateOrConnectWithoutMedicamentInput[]
    createMany?: StockCreateManyMedicamentInputEnvelope
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
  }

  export type MouvementStockUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput> | MouvementStockCreateWithoutMedicamentInput[] | MouvementStockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutMedicamentInput | MouvementStockCreateOrConnectWithoutMedicamentInput[]
    createMany?: MouvementStockCreateManyMedicamentInputEnvelope
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
  }

  export type DispensationUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput> | DispensationCreateWithoutMedicamentInput[] | DispensationUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutMedicamentInput | DispensationCreateOrConnectWithoutMedicamentInput[]
    createMany?: DispensationCreateManyMedicamentInputEnvelope
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
  }

  export type LigneCommandePharmacieUncheckedCreateNestedManyWithoutMedicamentInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput> | LigneCommandePharmacieCreateWithoutMedicamentInput[] | LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput | LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput[]
    createMany?: LigneCommandePharmacieCreateManyMedicamentInputEnvelope
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
  }

  export type StockUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput> | StockCreateWithoutMedicamentInput[] | StockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: StockCreateOrConnectWithoutMedicamentInput | StockCreateOrConnectWithoutMedicamentInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutMedicamentInput | StockUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: StockCreateManyMedicamentInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutMedicamentInput | StockUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: StockUpdateManyWithWhereWithoutMedicamentInput | StockUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type MouvementStockUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput> | MouvementStockCreateWithoutMedicamentInput[] | MouvementStockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutMedicamentInput | MouvementStockCreateOrConnectWithoutMedicamentInput[]
    upsert?: MouvementStockUpsertWithWhereUniqueWithoutMedicamentInput | MouvementStockUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: MouvementStockCreateManyMedicamentInputEnvelope
    set?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    disconnect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    delete?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    update?: MouvementStockUpdateWithWhereUniqueWithoutMedicamentInput | MouvementStockUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: MouvementStockUpdateManyWithWhereWithoutMedicamentInput | MouvementStockUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
  }

  export type DispensationUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput> | DispensationCreateWithoutMedicamentInput[] | DispensationUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutMedicamentInput | DispensationCreateOrConnectWithoutMedicamentInput[]
    upsert?: DispensationUpsertWithWhereUniqueWithoutMedicamentInput | DispensationUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: DispensationCreateManyMedicamentInputEnvelope
    set?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    disconnect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    delete?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    update?: DispensationUpdateWithWhereUniqueWithoutMedicamentInput | DispensationUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: DispensationUpdateManyWithWhereWithoutMedicamentInput | DispensationUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
  }

  export type LigneCommandePharmacieUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput> | LigneCommandePharmacieCreateWithoutMedicamentInput[] | LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput | LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput[]
    upsert?: LigneCommandePharmacieUpsertWithWhereUniqueWithoutMedicamentInput | LigneCommandePharmacieUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: LigneCommandePharmacieCreateManyMedicamentInputEnvelope
    set?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    disconnect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    delete?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    update?: LigneCommandePharmacieUpdateWithWhereUniqueWithoutMedicamentInput | LigneCommandePharmacieUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: LigneCommandePharmacieUpdateManyWithWhereWithoutMedicamentInput | LigneCommandePharmacieUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
  }

  export type StockUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput> | StockCreateWithoutMedicamentInput[] | StockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: StockCreateOrConnectWithoutMedicamentInput | StockCreateOrConnectWithoutMedicamentInput[]
    upsert?: StockUpsertWithWhereUniqueWithoutMedicamentInput | StockUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: StockCreateManyMedicamentInputEnvelope
    set?: StockWhereUniqueInput | StockWhereUniqueInput[]
    disconnect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    delete?: StockWhereUniqueInput | StockWhereUniqueInput[]
    connect?: StockWhereUniqueInput | StockWhereUniqueInput[]
    update?: StockUpdateWithWhereUniqueWithoutMedicamentInput | StockUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: StockUpdateManyWithWhereWithoutMedicamentInput | StockUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: StockScalarWhereInput | StockScalarWhereInput[]
  }

  export type MouvementStockUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput> | MouvementStockCreateWithoutMedicamentInput[] | MouvementStockUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: MouvementStockCreateOrConnectWithoutMedicamentInput | MouvementStockCreateOrConnectWithoutMedicamentInput[]
    upsert?: MouvementStockUpsertWithWhereUniqueWithoutMedicamentInput | MouvementStockUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: MouvementStockCreateManyMedicamentInputEnvelope
    set?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    disconnect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    delete?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    connect?: MouvementStockWhereUniqueInput | MouvementStockWhereUniqueInput[]
    update?: MouvementStockUpdateWithWhereUniqueWithoutMedicamentInput | MouvementStockUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: MouvementStockUpdateManyWithWhereWithoutMedicamentInput | MouvementStockUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
  }

  export type DispensationUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput> | DispensationCreateWithoutMedicamentInput[] | DispensationUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: DispensationCreateOrConnectWithoutMedicamentInput | DispensationCreateOrConnectWithoutMedicamentInput[]
    upsert?: DispensationUpsertWithWhereUniqueWithoutMedicamentInput | DispensationUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: DispensationCreateManyMedicamentInputEnvelope
    set?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    disconnect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    delete?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    connect?: DispensationWhereUniqueInput | DispensationWhereUniqueInput[]
    update?: DispensationUpdateWithWhereUniqueWithoutMedicamentInput | DispensationUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: DispensationUpdateManyWithWhereWithoutMedicamentInput | DispensationUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
  }

  export type LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentNestedInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput> | LigneCommandePharmacieCreateWithoutMedicamentInput[] | LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput | LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput[]
    upsert?: LigneCommandePharmacieUpsertWithWhereUniqueWithoutMedicamentInput | LigneCommandePharmacieUpsertWithWhereUniqueWithoutMedicamentInput[]
    createMany?: LigneCommandePharmacieCreateManyMedicamentInputEnvelope
    set?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    disconnect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    delete?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    update?: LigneCommandePharmacieUpdateWithWhereUniqueWithoutMedicamentInput | LigneCommandePharmacieUpdateWithWhereUniqueWithoutMedicamentInput[]
    updateMany?: LigneCommandePharmacieUpdateManyWithWhereWithoutMedicamentInput | LigneCommandePharmacieUpdateManyWithWhereWithoutMedicamentInput[]
    deleteMany?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
  }

  export type CommandePharmacieCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput> | CommandePharmacieCreateWithoutFournisseurInput[] | CommandePharmacieUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutFournisseurInput | CommandePharmacieCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandePharmacieCreateManyFournisseurInputEnvelope
    connect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
  }

  export type CommandePharmacieUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput> | CommandePharmacieCreateWithoutFournisseurInput[] | CommandePharmacieUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutFournisseurInput | CommandePharmacieCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandePharmacieCreateManyFournisseurInputEnvelope
    connect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
  }

  export type CommandePharmacieUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput> | CommandePharmacieCreateWithoutFournisseurInput[] | CommandePharmacieUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutFournisseurInput | CommandePharmacieCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandePharmacieUpsertWithWhereUniqueWithoutFournisseurInput | CommandePharmacieUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandePharmacieCreateManyFournisseurInputEnvelope
    set?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    disconnect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    delete?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    connect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    update?: CommandePharmacieUpdateWithWhereUniqueWithoutFournisseurInput | CommandePharmacieUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandePharmacieUpdateManyWithWhereWithoutFournisseurInput | CommandePharmacieUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandePharmacieScalarWhereInput | CommandePharmacieScalarWhereInput[]
  }

  export type CommandePharmacieUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput> | CommandePharmacieCreateWithoutFournisseurInput[] | CommandePharmacieUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutFournisseurInput | CommandePharmacieCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandePharmacieUpsertWithWhereUniqueWithoutFournisseurInput | CommandePharmacieUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandePharmacieCreateManyFournisseurInputEnvelope
    set?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    disconnect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    delete?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    connect?: CommandePharmacieWhereUniqueInput | CommandePharmacieWhereUniqueInput[]
    update?: CommandePharmacieUpdateWithWhereUniqueWithoutFournisseurInput | CommandePharmacieUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandePharmacieUpdateManyWithWhereWithoutFournisseurInput | CommandePharmacieUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandePharmacieScalarWhereInput | CommandePharmacieScalarWhereInput[]
  }

  export type FournisseurCreateNestedOneWithoutCommandesInput = {
    create?: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandesInput
    connect?: FournisseurWhereUniqueInput
  }

  export type LigneCommandePharmacieCreateNestedManyWithoutCommandeInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput> | LigneCommandePharmacieCreateWithoutCommandeInput[] | LigneCommandePharmacieUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutCommandeInput | LigneCommandePharmacieCreateOrConnectWithoutCommandeInput[]
    createMany?: LigneCommandePharmacieCreateManyCommandeInputEnvelope
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
  }

  export type LigneCommandePharmacieUncheckedCreateNestedManyWithoutCommandeInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput> | LigneCommandePharmacieCreateWithoutCommandeInput[] | LigneCommandePharmacieUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutCommandeInput | LigneCommandePharmacieCreateOrConnectWithoutCommandeInput[]
    createMany?: LigneCommandePharmacieCreateManyCommandeInputEnvelope
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
  }

  export type FournisseurUpdateOneRequiredWithoutCommandesNestedInput = {
    create?: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandesInput
    upsert?: FournisseurUpsertWithoutCommandesInput
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutCommandesInput, FournisseurUpdateWithoutCommandesInput>, FournisseurUncheckedUpdateWithoutCommandesInput>
  }

  export type LigneCommandePharmacieUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput> | LigneCommandePharmacieCreateWithoutCommandeInput[] | LigneCommandePharmacieUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutCommandeInput | LigneCommandePharmacieCreateOrConnectWithoutCommandeInput[]
    upsert?: LigneCommandePharmacieUpsertWithWhereUniqueWithoutCommandeInput | LigneCommandePharmacieUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: LigneCommandePharmacieCreateManyCommandeInputEnvelope
    set?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    disconnect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    delete?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    update?: LigneCommandePharmacieUpdateWithWhereUniqueWithoutCommandeInput | LigneCommandePharmacieUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: LigneCommandePharmacieUpdateManyWithWhereWithoutCommandeInput | LigneCommandePharmacieUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
  }

  export type LigneCommandePharmacieUncheckedUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput> | LigneCommandePharmacieCreateWithoutCommandeInput[] | LigneCommandePharmacieUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: LigneCommandePharmacieCreateOrConnectWithoutCommandeInput | LigneCommandePharmacieCreateOrConnectWithoutCommandeInput[]
    upsert?: LigneCommandePharmacieUpsertWithWhereUniqueWithoutCommandeInput | LigneCommandePharmacieUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: LigneCommandePharmacieCreateManyCommandeInputEnvelope
    set?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    disconnect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    delete?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    connect?: LigneCommandePharmacieWhereUniqueInput | LigneCommandePharmacieWhereUniqueInput[]
    update?: LigneCommandePharmacieUpdateWithWhereUniqueWithoutCommandeInput | LigneCommandePharmacieUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: LigneCommandePharmacieUpdateManyWithWhereWithoutCommandeInput | LigneCommandePharmacieUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
  }

  export type CommandePharmacieCreateNestedOneWithoutLignesInput = {
    create?: XOR<CommandePharmacieCreateWithoutLignesInput, CommandePharmacieUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutLignesInput
    connect?: CommandePharmacieWhereUniqueInput
  }

  export type MedicamentCreateNestedOneWithoutCommandesInput = {
    create?: XOR<MedicamentCreateWithoutCommandesInput, MedicamentUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutCommandesInput
    connect?: MedicamentWhereUniqueInput
  }

  export type CommandePharmacieUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<CommandePharmacieCreateWithoutLignesInput, CommandePharmacieUncheckedCreateWithoutLignesInput>
    connectOrCreate?: CommandePharmacieCreateOrConnectWithoutLignesInput
    upsert?: CommandePharmacieUpsertWithoutLignesInput
    connect?: CommandePharmacieWhereUniqueInput
    update?: XOR<XOR<CommandePharmacieUpdateToOneWithWhereWithoutLignesInput, CommandePharmacieUpdateWithoutLignesInput>, CommandePharmacieUncheckedUpdateWithoutLignesInput>
  }

  export type MedicamentUpdateOneRequiredWithoutCommandesNestedInput = {
    create?: XOR<MedicamentCreateWithoutCommandesInput, MedicamentUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutCommandesInput
    upsert?: MedicamentUpsertWithoutCommandesInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutCommandesInput, MedicamentUpdateWithoutCommandesInput>, MedicamentUncheckedUpdateWithoutCommandesInput>
  }

  export type MedicamentCreateNestedOneWithoutStocksInput = {
    create?: XOR<MedicamentCreateWithoutStocksInput, MedicamentUncheckedCreateWithoutStocksInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutStocksInput
    connect?: MedicamentWhereUniqueInput
  }

  export type MedicamentUpdateOneRequiredWithoutStocksNestedInput = {
    create?: XOR<MedicamentCreateWithoutStocksInput, MedicamentUncheckedCreateWithoutStocksInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutStocksInput
    upsert?: MedicamentUpsertWithoutStocksInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutStocksInput, MedicamentUpdateWithoutStocksInput>, MedicamentUncheckedUpdateWithoutStocksInput>
  }

  export type MedicamentCreateNestedOneWithoutMouvementsInput = {
    create?: XOR<MedicamentCreateWithoutMouvementsInput, MedicamentUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutMouvementsInput
    connect?: MedicamentWhereUniqueInput
  }

  export type MedicamentUpdateOneRequiredWithoutMouvementsNestedInput = {
    create?: XOR<MedicamentCreateWithoutMouvementsInput, MedicamentUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutMouvementsInput
    upsert?: MedicamentUpsertWithoutMouvementsInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutMouvementsInput, MedicamentUpdateWithoutMouvementsInput>, MedicamentUncheckedUpdateWithoutMouvementsInput>
  }

  export type MedicamentCreateNestedOneWithoutDispensationsInput = {
    create?: XOR<MedicamentCreateWithoutDispensationsInput, MedicamentUncheckedCreateWithoutDispensationsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutDispensationsInput
    connect?: MedicamentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutDispensationsInput = {
    create?: XOR<PatientCreateWithoutDispensationsInput, PatientUncheckedCreateWithoutDispensationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDispensationsInput
    connect?: PatientWhereUniqueInput
  }

  export type MedicamentUpdateOneRequiredWithoutDispensationsNestedInput = {
    create?: XOR<MedicamentCreateWithoutDispensationsInput, MedicamentUncheckedCreateWithoutDispensationsInput>
    connectOrCreate?: MedicamentCreateOrConnectWithoutDispensationsInput
    upsert?: MedicamentUpsertWithoutDispensationsInput
    connect?: MedicamentWhereUniqueInput
    update?: XOR<XOR<MedicamentUpdateToOneWithWhereWithoutDispensationsInput, MedicamentUpdateWithoutDispensationsInput>, MedicamentUncheckedUpdateWithoutDispensationsInput>
  }

  export type PatientUpdateOneRequiredWithoutDispensationsNestedInput = {
    create?: XOR<PatientCreateWithoutDispensationsInput, PatientUncheckedCreateWithoutDispensationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDispensationsInput
    upsert?: PatientUpsertWithoutDispensationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDispensationsInput, PatientUpdateWithoutDispensationsInput>, PatientUncheckedUpdateWithoutDispensationsInput>
  }

  export type PatientCreateNestedOneWithoutFacturesInput = {
    create?: XOR<PatientCreateWithoutFacturesInput, PatientUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFacturesInput
    connect?: PatientWhereUniqueInput
  }

  export type LigneFactureCreateNestedManyWithoutFactureInput = {
    create?: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput> | LigneFactureCreateWithoutFactureInput[] | LigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: LigneFactureCreateOrConnectWithoutFactureInput | LigneFactureCreateOrConnectWithoutFactureInput[]
    createMany?: LigneFactureCreateManyFactureInputEnvelope
    connect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutFactureInput = {
    create?: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput> | PaiementCreateWithoutFactureInput[] | PaiementUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutFactureInput | PaiementCreateOrConnectWithoutFactureInput[]
    createMany?: PaiementCreateManyFactureInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type ConsultationCreateNestedManyWithoutFactureInput = {
    create?: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput> | ConsultationCreateWithoutFactureInput[] | ConsultationUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutFactureInput | ConsultationCreateOrConnectWithoutFactureInput[]
    createMany?: ConsultationCreateManyFactureInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type LigneFactureUncheckedCreateNestedManyWithoutFactureInput = {
    create?: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput> | LigneFactureCreateWithoutFactureInput[] | LigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: LigneFactureCreateOrConnectWithoutFactureInput | LigneFactureCreateOrConnectWithoutFactureInput[]
    createMany?: LigneFactureCreateManyFactureInputEnvelope
    connect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutFactureInput = {
    create?: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput> | PaiementCreateWithoutFactureInput[] | PaiementUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutFactureInput | PaiementCreateOrConnectWithoutFactureInput[]
    createMany?: PaiementCreateManyFactureInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type ConsultationUncheckedCreateNestedManyWithoutFactureInput = {
    create?: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput> | ConsultationCreateWithoutFactureInput[] | ConsultationUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutFactureInput | ConsultationCreateOrConnectWithoutFactureInput[]
    createMany?: ConsultationCreateManyFactureInputEnvelope
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutFacturesNestedInput = {
    create?: XOR<PatientCreateWithoutFacturesInput, PatientUncheckedCreateWithoutFacturesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutFacturesInput
    upsert?: PatientUpsertWithoutFacturesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutFacturesInput, PatientUpdateWithoutFacturesInput>, PatientUncheckedUpdateWithoutFacturesInput>
  }

  export type LigneFactureUpdateManyWithoutFactureNestedInput = {
    create?: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput> | LigneFactureCreateWithoutFactureInput[] | LigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: LigneFactureCreateOrConnectWithoutFactureInput | LigneFactureCreateOrConnectWithoutFactureInput[]
    upsert?: LigneFactureUpsertWithWhereUniqueWithoutFactureInput | LigneFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: LigneFactureCreateManyFactureInputEnvelope
    set?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    disconnect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    delete?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    connect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    update?: LigneFactureUpdateWithWhereUniqueWithoutFactureInput | LigneFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: LigneFactureUpdateManyWithWhereWithoutFactureInput | LigneFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: LigneFactureScalarWhereInput | LigneFactureScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutFactureNestedInput = {
    create?: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput> | PaiementCreateWithoutFactureInput[] | PaiementUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutFactureInput | PaiementCreateOrConnectWithoutFactureInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutFactureInput | PaiementUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: PaiementCreateManyFactureInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutFactureInput | PaiementUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutFactureInput | PaiementUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type ConsultationUpdateManyWithoutFactureNestedInput = {
    create?: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput> | ConsultationCreateWithoutFactureInput[] | ConsultationUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutFactureInput | ConsultationCreateOrConnectWithoutFactureInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutFactureInput | ConsultationUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: ConsultationCreateManyFactureInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutFactureInput | ConsultationUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutFactureInput | ConsultationUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type LigneFactureUncheckedUpdateManyWithoutFactureNestedInput = {
    create?: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput> | LigneFactureCreateWithoutFactureInput[] | LigneFactureUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: LigneFactureCreateOrConnectWithoutFactureInput | LigneFactureCreateOrConnectWithoutFactureInput[]
    upsert?: LigneFactureUpsertWithWhereUniqueWithoutFactureInput | LigneFactureUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: LigneFactureCreateManyFactureInputEnvelope
    set?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    disconnect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    delete?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    connect?: LigneFactureWhereUniqueInput | LigneFactureWhereUniqueInput[]
    update?: LigneFactureUpdateWithWhereUniqueWithoutFactureInput | LigneFactureUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: LigneFactureUpdateManyWithWhereWithoutFactureInput | LigneFactureUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: LigneFactureScalarWhereInput | LigneFactureScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutFactureNestedInput = {
    create?: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput> | PaiementCreateWithoutFactureInput[] | PaiementUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutFactureInput | PaiementCreateOrConnectWithoutFactureInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutFactureInput | PaiementUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: PaiementCreateManyFactureInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutFactureInput | PaiementUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutFactureInput | PaiementUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type ConsultationUncheckedUpdateManyWithoutFactureNestedInput = {
    create?: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput> | ConsultationCreateWithoutFactureInput[] | ConsultationUncheckedCreateWithoutFactureInput[]
    connectOrCreate?: ConsultationCreateOrConnectWithoutFactureInput | ConsultationCreateOrConnectWithoutFactureInput[]
    upsert?: ConsultationUpsertWithWhereUniqueWithoutFactureInput | ConsultationUpsertWithWhereUniqueWithoutFactureInput[]
    createMany?: ConsultationCreateManyFactureInputEnvelope
    set?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    disconnect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    delete?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    connect?: ConsultationWhereUniqueInput | ConsultationWhereUniqueInput[]
    update?: ConsultationUpdateWithWhereUniqueWithoutFactureInput | ConsultationUpdateWithWhereUniqueWithoutFactureInput[]
    updateMany?: ConsultationUpdateManyWithWhereWithoutFactureInput | ConsultationUpdateManyWithWhereWithoutFactureInput[]
    deleteMany?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
  }

  export type FactureCreateNestedOneWithoutLignesInput = {
    create?: XOR<FactureCreateWithoutLignesInput, FactureUncheckedCreateWithoutLignesInput>
    connectOrCreate?: FactureCreateOrConnectWithoutLignesInput
    connect?: FactureWhereUniqueInput
  }

  export type FactureUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<FactureCreateWithoutLignesInput, FactureUncheckedCreateWithoutLignesInput>
    connectOrCreate?: FactureCreateOrConnectWithoutLignesInput
    upsert?: FactureUpsertWithoutLignesInput
    connect?: FactureWhereUniqueInput
    update?: XOR<XOR<FactureUpdateToOneWithWhereWithoutLignesInput, FactureUpdateWithoutLignesInput>, FactureUncheckedUpdateWithoutLignesInput>
  }

  export type FactureCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<FactureCreateWithoutPaiementsInput, FactureUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: FactureCreateOrConnectWithoutPaiementsInput
    connect?: FactureWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<UserCreateWithoutPaiementsInput, UserUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaiementsInput
    connect?: UserWhereUniqueInput
  }

  export type FactureUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<FactureCreateWithoutPaiementsInput, FactureUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: FactureCreateOrConnectWithoutPaiementsInput
    upsert?: FactureUpsertWithoutPaiementsInput
    connect?: FactureWhereUniqueInput
    update?: XOR<XOR<FactureUpdateToOneWithWhereWithoutPaiementsInput, FactureUpdateWithoutPaiementsInput>, FactureUncheckedUpdateWithoutPaiementsInput>
  }

  export type UserUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<UserCreateWithoutPaiementsInput, UserUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaiementsInput
    upsert?: UserUpsertWithoutPaiementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaiementsInput, UserUpdateWithoutPaiementsInput>, UserUncheckedUpdateWithoutPaiementsInput>
  }

  export type HospitalisationCreateNestedManyWithoutLitInput = {
    create?: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput> | HospitalisationCreateWithoutLitInput[] | HospitalisationUncheckedCreateWithoutLitInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutLitInput | HospitalisationCreateOrConnectWithoutLitInput[]
    createMany?: HospitalisationCreateManyLitInputEnvelope
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
  }

  export type HospitalisationUncheckedCreateNestedManyWithoutLitInput = {
    create?: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput> | HospitalisationCreateWithoutLitInput[] | HospitalisationUncheckedCreateWithoutLitInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutLitInput | HospitalisationCreateOrConnectWithoutLitInput[]
    createMany?: HospitalisationCreateManyLitInputEnvelope
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
  }

  export type HospitalisationUpdateManyWithoutLitNestedInput = {
    create?: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput> | HospitalisationCreateWithoutLitInput[] | HospitalisationUncheckedCreateWithoutLitInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutLitInput | HospitalisationCreateOrConnectWithoutLitInput[]
    upsert?: HospitalisationUpsertWithWhereUniqueWithoutLitInput | HospitalisationUpsertWithWhereUniqueWithoutLitInput[]
    createMany?: HospitalisationCreateManyLitInputEnvelope
    set?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    disconnect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    delete?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    update?: HospitalisationUpdateWithWhereUniqueWithoutLitInput | HospitalisationUpdateWithWhereUniqueWithoutLitInput[]
    updateMany?: HospitalisationUpdateManyWithWhereWithoutLitInput | HospitalisationUpdateManyWithWhereWithoutLitInput[]
    deleteMany?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
  }

  export type HospitalisationUncheckedUpdateManyWithoutLitNestedInput = {
    create?: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput> | HospitalisationCreateWithoutLitInput[] | HospitalisationUncheckedCreateWithoutLitInput[]
    connectOrCreate?: HospitalisationCreateOrConnectWithoutLitInput | HospitalisationCreateOrConnectWithoutLitInput[]
    upsert?: HospitalisationUpsertWithWhereUniqueWithoutLitInput | HospitalisationUpsertWithWhereUniqueWithoutLitInput[]
    createMany?: HospitalisationCreateManyLitInputEnvelope
    set?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    disconnect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    delete?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    connect?: HospitalisationWhereUniqueInput | HospitalisationWhereUniqueInput[]
    update?: HospitalisationUpdateWithWhereUniqueWithoutLitInput | HospitalisationUpdateWithWhereUniqueWithoutLitInput[]
    updateMany?: HospitalisationUpdateManyWithWhereWithoutLitInput | HospitalisationUpdateManyWithWhereWithoutLitInput[]
    deleteMany?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutHospitalisationsInput = {
    create?: XOR<PatientCreateWithoutHospitalisationsInput, PatientUncheckedCreateWithoutHospitalisationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalisationsInput
    connect?: PatientWhereUniqueInput
  }

  export type LitCreateNestedOneWithoutHospitalisationsInput = {
    create?: XOR<LitCreateWithoutHospitalisationsInput, LitUncheckedCreateWithoutHospitalisationsInput>
    connectOrCreate?: LitCreateOrConnectWithoutHospitalisationsInput
    connect?: LitWhereUniqueInput
  }

  export type ObservationInfirmierCreateNestedManyWithoutHospitalisationInput = {
    create?: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput> | ObservationInfirmierCreateWithoutHospitalisationInput[] | ObservationInfirmierUncheckedCreateWithoutHospitalisationInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutHospitalisationInput | ObservationInfirmierCreateOrConnectWithoutHospitalisationInput[]
    createMany?: ObservationInfirmierCreateManyHospitalisationInputEnvelope
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
  }

  export type ObservationInfirmierUncheckedCreateNestedManyWithoutHospitalisationInput = {
    create?: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput> | ObservationInfirmierCreateWithoutHospitalisationInput[] | ObservationInfirmierUncheckedCreateWithoutHospitalisationInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutHospitalisationInput | ObservationInfirmierCreateOrConnectWithoutHospitalisationInput[]
    createMany?: ObservationInfirmierCreateManyHospitalisationInputEnvelope
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutHospitalisationsNestedInput = {
    create?: XOR<PatientCreateWithoutHospitalisationsInput, PatientUncheckedCreateWithoutHospitalisationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutHospitalisationsInput
    upsert?: PatientUpsertWithoutHospitalisationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutHospitalisationsInput, PatientUpdateWithoutHospitalisationsInput>, PatientUncheckedUpdateWithoutHospitalisationsInput>
  }

  export type LitUpdateOneRequiredWithoutHospitalisationsNestedInput = {
    create?: XOR<LitCreateWithoutHospitalisationsInput, LitUncheckedCreateWithoutHospitalisationsInput>
    connectOrCreate?: LitCreateOrConnectWithoutHospitalisationsInput
    upsert?: LitUpsertWithoutHospitalisationsInput
    connect?: LitWhereUniqueInput
    update?: XOR<XOR<LitUpdateToOneWithWhereWithoutHospitalisationsInput, LitUpdateWithoutHospitalisationsInput>, LitUncheckedUpdateWithoutHospitalisationsInput>
  }

  export type ObservationInfirmierUpdateManyWithoutHospitalisationNestedInput = {
    create?: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput> | ObservationInfirmierCreateWithoutHospitalisationInput[] | ObservationInfirmierUncheckedCreateWithoutHospitalisationInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutHospitalisationInput | ObservationInfirmierCreateOrConnectWithoutHospitalisationInput[]
    upsert?: ObservationInfirmierUpsertWithWhereUniqueWithoutHospitalisationInput | ObservationInfirmierUpsertWithWhereUniqueWithoutHospitalisationInput[]
    createMany?: ObservationInfirmierCreateManyHospitalisationInputEnvelope
    set?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    disconnect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    delete?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    update?: ObservationInfirmierUpdateWithWhereUniqueWithoutHospitalisationInput | ObservationInfirmierUpdateWithWhereUniqueWithoutHospitalisationInput[]
    updateMany?: ObservationInfirmierUpdateManyWithWhereWithoutHospitalisationInput | ObservationInfirmierUpdateManyWithWhereWithoutHospitalisationInput[]
    deleteMany?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
  }

  export type ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationNestedInput = {
    create?: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput> | ObservationInfirmierCreateWithoutHospitalisationInput[] | ObservationInfirmierUncheckedCreateWithoutHospitalisationInput[]
    connectOrCreate?: ObservationInfirmierCreateOrConnectWithoutHospitalisationInput | ObservationInfirmierCreateOrConnectWithoutHospitalisationInput[]
    upsert?: ObservationInfirmierUpsertWithWhereUniqueWithoutHospitalisationInput | ObservationInfirmierUpsertWithWhereUniqueWithoutHospitalisationInput[]
    createMany?: ObservationInfirmierCreateManyHospitalisationInputEnvelope
    set?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    disconnect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    delete?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    connect?: ObservationInfirmierWhereUniqueInput | ObservationInfirmierWhereUniqueInput[]
    update?: ObservationInfirmierUpdateWithWhereUniqueWithoutHospitalisationInput | ObservationInfirmierUpdateWithWhereUniqueWithoutHospitalisationInput[]
    updateMany?: ObservationInfirmierUpdateManyWithWhereWithoutHospitalisationInput | ObservationInfirmierUpdateManyWithWhereWithoutHospitalisationInput[]
    deleteMany?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
  }

  export type HospitalisationCreateNestedOneWithoutObservationsInput = {
    create?: XOR<HospitalisationCreateWithoutObservationsInput, HospitalisationUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: HospitalisationCreateOrConnectWithoutObservationsInput
    connect?: HospitalisationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutObservationsCreesInput = {
    create?: XOR<UserCreateWithoutObservationsCreesInput, UserUncheckedCreateWithoutObservationsCreesInput>
    connectOrCreate?: UserCreateOrConnectWithoutObservationsCreesInput
    connect?: UserWhereUniqueInput
  }

  export type HospitalisationUpdateOneRequiredWithoutObservationsNestedInput = {
    create?: XOR<HospitalisationCreateWithoutObservationsInput, HospitalisationUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: HospitalisationCreateOrConnectWithoutObservationsInput
    upsert?: HospitalisationUpsertWithoutObservationsInput
    connect?: HospitalisationWhereUniqueInput
    update?: XOR<XOR<HospitalisationUpdateToOneWithWhereWithoutObservationsInput, HospitalisationUpdateWithoutObservationsInput>, HospitalisationUncheckedUpdateWithoutObservationsInput>
  }

  export type UserUpdateOneRequiredWithoutObservationsCreesNestedInput = {
    create?: XOR<UserCreateWithoutObservationsCreesInput, UserUncheckedCreateWithoutObservationsCreesInput>
    connectOrCreate?: UserCreateOrConnectWithoutObservationsCreesInput
    upsert?: UserUpsertWithoutObservationsCreesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutObservationsCreesInput, UserUpdateWithoutObservationsCreesInput>, UserUncheckedUpdateWithoutObservationsCreesInput>
  }

  export type PatientCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<PatientCreateWithoutInterventionsInput, PatientUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInterventionsInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChirurgiesInput = {
    create?: XOR<UserCreateWithoutChirurgiesInput, UserUncheckedCreateWithoutChirurgiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChirurgiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAnesthesiesInput = {
    create?: XOR<UserCreateWithoutAnesthesiesInput, UserUncheckedCreateWithoutAnesthesiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnesthesiesInput
    connect?: UserWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<PatientCreateWithoutInterventionsInput, PatientUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInterventionsInput
    upsert?: PatientUpsertWithoutInterventionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInterventionsInput, PatientUpdateWithoutInterventionsInput>, PatientUncheckedUpdateWithoutInterventionsInput>
  }

  export type UserUpdateOneRequiredWithoutChirurgiesNestedInput = {
    create?: XOR<UserCreateWithoutChirurgiesInput, UserUncheckedCreateWithoutChirurgiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChirurgiesInput
    upsert?: UserUpsertWithoutChirurgiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChirurgiesInput, UserUpdateWithoutChirurgiesInput>, UserUncheckedUpdateWithoutChirurgiesInput>
  }

  export type UserUpdateOneWithoutAnesthesiesNestedInput = {
    create?: XOR<UserCreateWithoutAnesthesiesInput, UserUncheckedCreateWithoutAnesthesiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnesthesiesInput
    upsert?: UserUpsertWithoutAnesthesiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnesthesiesInput, UserUpdateWithoutAnesthesiesInput>, UserUncheckedUpdateWithoutAnesthesiesInput>
  }

  export type PatientCreateNestedOneWithoutDossiersMaterniteInput = {
    create?: XOR<PatientCreateWithoutDossiersMaterniteInput, PatientUncheckedCreateWithoutDossiersMaterniteInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDossiersMaterniteInput
    connect?: PatientWhereUniqueInput
  }

  export type NouveauNeCreateNestedManyWithoutDossierMaterniteInput = {
    create?: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput> | NouveauNeCreateWithoutDossierMaterniteInput[] | NouveauNeUncheckedCreateWithoutDossierMaterniteInput[]
    connectOrCreate?: NouveauNeCreateOrConnectWithoutDossierMaterniteInput | NouveauNeCreateOrConnectWithoutDossierMaterniteInput[]
    createMany?: NouveauNeCreateManyDossierMaterniteInputEnvelope
    connect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
  }

  export type NouveauNeUncheckedCreateNestedManyWithoutDossierMaterniteInput = {
    create?: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput> | NouveauNeCreateWithoutDossierMaterniteInput[] | NouveauNeUncheckedCreateWithoutDossierMaterniteInput[]
    connectOrCreate?: NouveauNeCreateOrConnectWithoutDossierMaterniteInput | NouveauNeCreateOrConnectWithoutDossierMaterniteInput[]
    createMany?: NouveauNeCreateManyDossierMaterniteInputEnvelope
    connect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutDossiersMaterniteNestedInput = {
    create?: XOR<PatientCreateWithoutDossiersMaterniteInput, PatientUncheckedCreateWithoutDossiersMaterniteInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDossiersMaterniteInput
    upsert?: PatientUpsertWithoutDossiersMaterniteInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDossiersMaterniteInput, PatientUpdateWithoutDossiersMaterniteInput>, PatientUncheckedUpdateWithoutDossiersMaterniteInput>
  }

  export type NouveauNeUpdateManyWithoutDossierMaterniteNestedInput = {
    create?: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput> | NouveauNeCreateWithoutDossierMaterniteInput[] | NouveauNeUncheckedCreateWithoutDossierMaterniteInput[]
    connectOrCreate?: NouveauNeCreateOrConnectWithoutDossierMaterniteInput | NouveauNeCreateOrConnectWithoutDossierMaterniteInput[]
    upsert?: NouveauNeUpsertWithWhereUniqueWithoutDossierMaterniteInput | NouveauNeUpsertWithWhereUniqueWithoutDossierMaterniteInput[]
    createMany?: NouveauNeCreateManyDossierMaterniteInputEnvelope
    set?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    disconnect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    delete?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    connect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    update?: NouveauNeUpdateWithWhereUniqueWithoutDossierMaterniteInput | NouveauNeUpdateWithWhereUniqueWithoutDossierMaterniteInput[]
    updateMany?: NouveauNeUpdateManyWithWhereWithoutDossierMaterniteInput | NouveauNeUpdateManyWithWhereWithoutDossierMaterniteInput[]
    deleteMany?: NouveauNeScalarWhereInput | NouveauNeScalarWhereInput[]
  }

  export type NouveauNeUncheckedUpdateManyWithoutDossierMaterniteNestedInput = {
    create?: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput> | NouveauNeCreateWithoutDossierMaterniteInput[] | NouveauNeUncheckedCreateWithoutDossierMaterniteInput[]
    connectOrCreate?: NouveauNeCreateOrConnectWithoutDossierMaterniteInput | NouveauNeCreateOrConnectWithoutDossierMaterniteInput[]
    upsert?: NouveauNeUpsertWithWhereUniqueWithoutDossierMaterniteInput | NouveauNeUpsertWithWhereUniqueWithoutDossierMaterniteInput[]
    createMany?: NouveauNeCreateManyDossierMaterniteInputEnvelope
    set?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    disconnect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    delete?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    connect?: NouveauNeWhereUniqueInput | NouveauNeWhereUniqueInput[]
    update?: NouveauNeUpdateWithWhereUniqueWithoutDossierMaterniteInput | NouveauNeUpdateWithWhereUniqueWithoutDossierMaterniteInput[]
    updateMany?: NouveauNeUpdateManyWithWhereWithoutDossierMaterniteInput | NouveauNeUpdateManyWithWhereWithoutDossierMaterniteInput[]
    deleteMany?: NouveauNeScalarWhereInput | NouveauNeScalarWhereInput[]
  }

  export type DossierMaterniteCreateNestedOneWithoutNouveauNesInput = {
    create?: XOR<DossierMaterniteCreateWithoutNouveauNesInput, DossierMaterniteUncheckedCreateWithoutNouveauNesInput>
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutNouveauNesInput
    connect?: DossierMaterniteWhereUniqueInput
  }

  export type DossierMaterniteUpdateOneRequiredWithoutNouveauNesNestedInput = {
    create?: XOR<DossierMaterniteCreateWithoutNouveauNesInput, DossierMaterniteUncheckedCreateWithoutNouveauNesInput>
    connectOrCreate?: DossierMaterniteCreateOrConnectWithoutNouveauNesInput
    upsert?: DossierMaterniteUpsertWithoutNouveauNesInput
    connect?: DossierMaterniteWhereUniqueInput
    update?: XOR<XOR<DossierMaterniteUpdateToOneWithWhereWithoutNouveauNesInput, DossierMaterniteUpdateWithoutNouveauNesInput>, DossierMaterniteUncheckedUpdateWithoutNouveauNesInput>
  }

  export type MouvementLogistiqueCreateNestedManyWithoutArticleInput = {
    create?: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput> | MouvementLogistiqueCreateWithoutArticleInput[] | MouvementLogistiqueUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementLogistiqueCreateOrConnectWithoutArticleInput | MouvementLogistiqueCreateOrConnectWithoutArticleInput[]
    createMany?: MouvementLogistiqueCreateManyArticleInputEnvelope
    connect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
  }

  export type MouvementLogistiqueUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput> | MouvementLogistiqueCreateWithoutArticleInput[] | MouvementLogistiqueUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementLogistiqueCreateOrConnectWithoutArticleInput | MouvementLogistiqueCreateOrConnectWithoutArticleInput[]
    createMany?: MouvementLogistiqueCreateManyArticleInputEnvelope
    connect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
  }

  export type MouvementLogistiqueUpdateManyWithoutArticleNestedInput = {
    create?: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput> | MouvementLogistiqueCreateWithoutArticleInput[] | MouvementLogistiqueUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementLogistiqueCreateOrConnectWithoutArticleInput | MouvementLogistiqueCreateOrConnectWithoutArticleInput[]
    upsert?: MouvementLogistiqueUpsertWithWhereUniqueWithoutArticleInput | MouvementLogistiqueUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: MouvementLogistiqueCreateManyArticleInputEnvelope
    set?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    disconnect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    delete?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    connect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    update?: MouvementLogistiqueUpdateWithWhereUniqueWithoutArticleInput | MouvementLogistiqueUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: MouvementLogistiqueUpdateManyWithWhereWithoutArticleInput | MouvementLogistiqueUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: MouvementLogistiqueScalarWhereInput | MouvementLogistiqueScalarWhereInput[]
  }

  export type MouvementLogistiqueUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput> | MouvementLogistiqueCreateWithoutArticleInput[] | MouvementLogistiqueUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: MouvementLogistiqueCreateOrConnectWithoutArticleInput | MouvementLogistiqueCreateOrConnectWithoutArticleInput[]
    upsert?: MouvementLogistiqueUpsertWithWhereUniqueWithoutArticleInput | MouvementLogistiqueUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: MouvementLogistiqueCreateManyArticleInputEnvelope
    set?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    disconnect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    delete?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    connect?: MouvementLogistiqueWhereUniqueInput | MouvementLogistiqueWhereUniqueInput[]
    update?: MouvementLogistiqueUpdateWithWhereUniqueWithoutArticleInput | MouvementLogistiqueUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: MouvementLogistiqueUpdateManyWithWhereWithoutArticleInput | MouvementLogistiqueUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: MouvementLogistiqueScalarWhereInput | MouvementLogistiqueScalarWhereInput[]
  }

  export type ArticleLogistiqueCreateNestedOneWithoutMouvementsInput = {
    create?: XOR<ArticleLogistiqueCreateWithoutMouvementsInput, ArticleLogistiqueUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: ArticleLogistiqueCreateOrConnectWithoutMouvementsInput
    connect?: ArticleLogistiqueWhereUniqueInput
  }

  export type ArticleLogistiqueUpdateOneRequiredWithoutMouvementsNestedInput = {
    create?: XOR<ArticleLogistiqueCreateWithoutMouvementsInput, ArticleLogistiqueUncheckedCreateWithoutMouvementsInput>
    connectOrCreate?: ArticleLogistiqueCreateOrConnectWithoutMouvementsInput
    upsert?: ArticleLogistiqueUpsertWithoutMouvementsInput
    connect?: ArticleLogistiqueWhereUniqueInput
    update?: XOR<XOR<ArticleLogistiqueUpdateToOneWithWhereWithoutMouvementsInput, ArticleLogistiqueUpdateWithoutMouvementsInput>, ArticleLogistiqueUncheckedUpdateWithoutMouvementsInput>
  }

  export type PatientCreateNestedOneWithoutDocumentsGEDInput = {
    create?: XOR<PatientCreateWithoutDocumentsGEDInput, PatientUncheckedCreateWithoutDocumentsGEDInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsGEDInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneWithoutDocumentsGEDNestedInput = {
    create?: XOR<PatientCreateWithoutDocumentsGEDInput, PatientUncheckedCreateWithoutDocumentsGEDInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsGEDInput
    upsert?: PatientUpsertWithoutDocumentsGEDInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDocumentsGEDInput, PatientUpdateWithoutDocumentsGEDInput>, PatientUncheckedUpdateWithoutDocumentsGEDInput>
  }

  export type UserCreateNestedOneWithoutEmployeInput = {
    create?: XOR<UserCreateWithoutEmployeInput, UserUncheckedCreateWithoutEmployeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeInput
    connect?: UserWhereUniqueInput
  }

  export type CongeCreateNestedManyWithoutEmployeInput = {
    create?: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput> | CongeCreateWithoutEmployeInput[] | CongeUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: CongeCreateOrConnectWithoutEmployeInput | CongeCreateOrConnectWithoutEmployeInput[]
    createMany?: CongeCreateManyEmployeInputEnvelope
    connect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
  }

  export type PlanningCreateNestedManyWithoutEmployeInput = {
    create?: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput> | PlanningCreateWithoutEmployeInput[] | PlanningUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutEmployeInput | PlanningCreateOrConnectWithoutEmployeInput[]
    createMany?: PlanningCreateManyEmployeInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type BulletinPaieCreateNestedManyWithoutEmployeInput = {
    create?: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput> | BulletinPaieCreateWithoutEmployeInput[] | BulletinPaieUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutEmployeInput | BulletinPaieCreateOrConnectWithoutEmployeInput[]
    createMany?: BulletinPaieCreateManyEmployeInputEnvelope
    connect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
  }

  export type CongeUncheckedCreateNestedManyWithoutEmployeInput = {
    create?: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput> | CongeCreateWithoutEmployeInput[] | CongeUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: CongeCreateOrConnectWithoutEmployeInput | CongeCreateOrConnectWithoutEmployeInput[]
    createMany?: CongeCreateManyEmployeInputEnvelope
    connect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
  }

  export type PlanningUncheckedCreateNestedManyWithoutEmployeInput = {
    create?: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput> | PlanningCreateWithoutEmployeInput[] | PlanningUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutEmployeInput | PlanningCreateOrConnectWithoutEmployeInput[]
    createMany?: PlanningCreateManyEmployeInputEnvelope
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
  }

  export type BulletinPaieUncheckedCreateNestedManyWithoutEmployeInput = {
    create?: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput> | BulletinPaieCreateWithoutEmployeInput[] | BulletinPaieUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutEmployeInput | BulletinPaieCreateOrConnectWithoutEmployeInput[]
    createMany?: BulletinPaieCreateManyEmployeInputEnvelope
    connect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutEmployeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeInput, UserUncheckedCreateWithoutEmployeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeInput
    upsert?: UserUpsertWithoutEmployeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeInput, UserUpdateWithoutEmployeInput>, UserUncheckedUpdateWithoutEmployeInput>
  }

  export type CongeUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput> | CongeCreateWithoutEmployeInput[] | CongeUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: CongeCreateOrConnectWithoutEmployeInput | CongeCreateOrConnectWithoutEmployeInput[]
    upsert?: CongeUpsertWithWhereUniqueWithoutEmployeInput | CongeUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: CongeCreateManyEmployeInputEnvelope
    set?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    disconnect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    delete?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    connect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    update?: CongeUpdateWithWhereUniqueWithoutEmployeInput | CongeUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: CongeUpdateManyWithWhereWithoutEmployeInput | CongeUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: CongeScalarWhereInput | CongeScalarWhereInput[]
  }

  export type PlanningUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput> | PlanningCreateWithoutEmployeInput[] | PlanningUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutEmployeInput | PlanningCreateOrConnectWithoutEmployeInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutEmployeInput | PlanningUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: PlanningCreateManyEmployeInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutEmployeInput | PlanningUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutEmployeInput | PlanningUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type BulletinPaieUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput> | BulletinPaieCreateWithoutEmployeInput[] | BulletinPaieUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutEmployeInput | BulletinPaieCreateOrConnectWithoutEmployeInput[]
    upsert?: BulletinPaieUpsertWithWhereUniqueWithoutEmployeInput | BulletinPaieUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: BulletinPaieCreateManyEmployeInputEnvelope
    set?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    disconnect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    delete?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    connect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    update?: BulletinPaieUpdateWithWhereUniqueWithoutEmployeInput | BulletinPaieUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: BulletinPaieUpdateManyWithWhereWithoutEmployeInput | BulletinPaieUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: BulletinPaieScalarWhereInput | BulletinPaieScalarWhereInput[]
  }

  export type CongeUncheckedUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput> | CongeCreateWithoutEmployeInput[] | CongeUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: CongeCreateOrConnectWithoutEmployeInput | CongeCreateOrConnectWithoutEmployeInput[]
    upsert?: CongeUpsertWithWhereUniqueWithoutEmployeInput | CongeUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: CongeCreateManyEmployeInputEnvelope
    set?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    disconnect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    delete?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    connect?: CongeWhereUniqueInput | CongeWhereUniqueInput[]
    update?: CongeUpdateWithWhereUniqueWithoutEmployeInput | CongeUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: CongeUpdateManyWithWhereWithoutEmployeInput | CongeUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: CongeScalarWhereInput | CongeScalarWhereInput[]
  }

  export type PlanningUncheckedUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput> | PlanningCreateWithoutEmployeInput[] | PlanningUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: PlanningCreateOrConnectWithoutEmployeInput | PlanningCreateOrConnectWithoutEmployeInput[]
    upsert?: PlanningUpsertWithWhereUniqueWithoutEmployeInput | PlanningUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: PlanningCreateManyEmployeInputEnvelope
    set?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    disconnect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    delete?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    connect?: PlanningWhereUniqueInput | PlanningWhereUniqueInput[]
    update?: PlanningUpdateWithWhereUniqueWithoutEmployeInput | PlanningUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: PlanningUpdateManyWithWhereWithoutEmployeInput | PlanningUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
  }

  export type BulletinPaieUncheckedUpdateManyWithoutEmployeNestedInput = {
    create?: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput> | BulletinPaieCreateWithoutEmployeInput[] | BulletinPaieUncheckedCreateWithoutEmployeInput[]
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutEmployeInput | BulletinPaieCreateOrConnectWithoutEmployeInput[]
    upsert?: BulletinPaieUpsertWithWhereUniqueWithoutEmployeInput | BulletinPaieUpsertWithWhereUniqueWithoutEmployeInput[]
    createMany?: BulletinPaieCreateManyEmployeInputEnvelope
    set?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    disconnect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    delete?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    connect?: BulletinPaieWhereUniqueInput | BulletinPaieWhereUniqueInput[]
    update?: BulletinPaieUpdateWithWhereUniqueWithoutEmployeInput | BulletinPaieUpdateWithWhereUniqueWithoutEmployeInput[]
    updateMany?: BulletinPaieUpdateManyWithWhereWithoutEmployeInput | BulletinPaieUpdateManyWithWhereWithoutEmployeInput[]
    deleteMany?: BulletinPaieScalarWhereInput | BulletinPaieScalarWhereInput[]
  }

  export type EmployeCreateNestedOneWithoutCongesInput = {
    create?: XOR<EmployeCreateWithoutCongesInput, EmployeUncheckedCreateWithoutCongesInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutCongesInput
    connect?: EmployeWhereUniqueInput
  }

  export type EmployeUpdateOneRequiredWithoutCongesNestedInput = {
    create?: XOR<EmployeCreateWithoutCongesInput, EmployeUncheckedCreateWithoutCongesInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutCongesInput
    upsert?: EmployeUpsertWithoutCongesInput
    connect?: EmployeWhereUniqueInput
    update?: XOR<XOR<EmployeUpdateToOneWithWhereWithoutCongesInput, EmployeUpdateWithoutCongesInput>, EmployeUncheckedUpdateWithoutCongesInput>
  }

  export type EmployeCreateNestedOneWithoutBulletinsInput = {
    create?: XOR<EmployeCreateWithoutBulletinsInput, EmployeUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutBulletinsInput
    connect?: EmployeWhereUniqueInput
  }

  export type LigneBulletinCreateNestedManyWithoutBulletinInput = {
    create?: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput> | LigneBulletinCreateWithoutBulletinInput[] | LigneBulletinUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: LigneBulletinCreateOrConnectWithoutBulletinInput | LigneBulletinCreateOrConnectWithoutBulletinInput[]
    createMany?: LigneBulletinCreateManyBulletinInputEnvelope
    connect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
  }

  export type LigneBulletinUncheckedCreateNestedManyWithoutBulletinInput = {
    create?: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput> | LigneBulletinCreateWithoutBulletinInput[] | LigneBulletinUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: LigneBulletinCreateOrConnectWithoutBulletinInput | LigneBulletinCreateOrConnectWithoutBulletinInput[]
    createMany?: LigneBulletinCreateManyBulletinInputEnvelope
    connect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
  }

  export type EmployeUpdateOneRequiredWithoutBulletinsNestedInput = {
    create?: XOR<EmployeCreateWithoutBulletinsInput, EmployeUncheckedCreateWithoutBulletinsInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutBulletinsInput
    upsert?: EmployeUpsertWithoutBulletinsInput
    connect?: EmployeWhereUniqueInput
    update?: XOR<XOR<EmployeUpdateToOneWithWhereWithoutBulletinsInput, EmployeUpdateWithoutBulletinsInput>, EmployeUncheckedUpdateWithoutBulletinsInput>
  }

  export type LigneBulletinUpdateManyWithoutBulletinNestedInput = {
    create?: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput> | LigneBulletinCreateWithoutBulletinInput[] | LigneBulletinUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: LigneBulletinCreateOrConnectWithoutBulletinInput | LigneBulletinCreateOrConnectWithoutBulletinInput[]
    upsert?: LigneBulletinUpsertWithWhereUniqueWithoutBulletinInput | LigneBulletinUpsertWithWhereUniqueWithoutBulletinInput[]
    createMany?: LigneBulletinCreateManyBulletinInputEnvelope
    set?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    disconnect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    delete?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    connect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    update?: LigneBulletinUpdateWithWhereUniqueWithoutBulletinInput | LigneBulletinUpdateWithWhereUniqueWithoutBulletinInput[]
    updateMany?: LigneBulletinUpdateManyWithWhereWithoutBulletinInput | LigneBulletinUpdateManyWithWhereWithoutBulletinInput[]
    deleteMany?: LigneBulletinScalarWhereInput | LigneBulletinScalarWhereInput[]
  }

  export type LigneBulletinUncheckedUpdateManyWithoutBulletinNestedInput = {
    create?: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput> | LigneBulletinCreateWithoutBulletinInput[] | LigneBulletinUncheckedCreateWithoutBulletinInput[]
    connectOrCreate?: LigneBulletinCreateOrConnectWithoutBulletinInput | LigneBulletinCreateOrConnectWithoutBulletinInput[]
    upsert?: LigneBulletinUpsertWithWhereUniqueWithoutBulletinInput | LigneBulletinUpsertWithWhereUniqueWithoutBulletinInput[]
    createMany?: LigneBulletinCreateManyBulletinInputEnvelope
    set?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    disconnect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    delete?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    connect?: LigneBulletinWhereUniqueInput | LigneBulletinWhereUniqueInput[]
    update?: LigneBulletinUpdateWithWhereUniqueWithoutBulletinInput | LigneBulletinUpdateWithWhereUniqueWithoutBulletinInput[]
    updateMany?: LigneBulletinUpdateManyWithWhereWithoutBulletinInput | LigneBulletinUpdateManyWithWhereWithoutBulletinInput[]
    deleteMany?: LigneBulletinScalarWhereInput | LigneBulletinScalarWhereInput[]
  }

  export type BulletinPaieCreateNestedOneWithoutLignesInput = {
    create?: XOR<BulletinPaieCreateWithoutLignesInput, BulletinPaieUncheckedCreateWithoutLignesInput>
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutLignesInput
    connect?: BulletinPaieWhereUniqueInput
  }

  export type BulletinPaieUpdateOneRequiredWithoutLignesNestedInput = {
    create?: XOR<BulletinPaieCreateWithoutLignesInput, BulletinPaieUncheckedCreateWithoutLignesInput>
    connectOrCreate?: BulletinPaieCreateOrConnectWithoutLignesInput
    upsert?: BulletinPaieUpsertWithoutLignesInput
    connect?: BulletinPaieWhereUniqueInput
    update?: XOR<XOR<BulletinPaieUpdateToOneWithWhereWithoutLignesInput, BulletinPaieUpdateWithoutLignesInput>, BulletinPaieUncheckedUpdateWithoutLignesInput>
  }

  export type EmployeCreateNestedOneWithoutPlanningsInput = {
    create?: XOR<EmployeCreateWithoutPlanningsInput, EmployeUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutPlanningsInput
    connect?: EmployeWhereUniqueInput
  }

  export type EmployeUpdateOneRequiredWithoutPlanningsNestedInput = {
    create?: XOR<EmployeCreateWithoutPlanningsInput, EmployeUncheckedCreateWithoutPlanningsInput>
    connectOrCreate?: EmployeCreateOrConnectWithoutPlanningsInput
    upsert?: EmployeUpsertWithoutPlanningsInput
    connect?: EmployeWhereUniqueInput
    update?: XOR<XOR<EmployeUpdateToOneWithWhereWithoutPlanningsInput, EmployeUpdateWithoutPlanningsInput>, EmployeUncheckedUpdateWithoutPlanningsInput>
  }

  export type TicketMaintenanceCreateNestedManyWithoutEquipementInput = {
    create?: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput> | TicketMaintenanceCreateWithoutEquipementInput[] | TicketMaintenanceUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: TicketMaintenanceCreateOrConnectWithoutEquipementInput | TicketMaintenanceCreateOrConnectWithoutEquipementInput[]
    createMany?: TicketMaintenanceCreateManyEquipementInputEnvelope
    connect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
  }

  export type TicketMaintenanceUncheckedCreateNestedManyWithoutEquipementInput = {
    create?: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput> | TicketMaintenanceCreateWithoutEquipementInput[] | TicketMaintenanceUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: TicketMaintenanceCreateOrConnectWithoutEquipementInput | TicketMaintenanceCreateOrConnectWithoutEquipementInput[]
    createMany?: TicketMaintenanceCreateManyEquipementInputEnvelope
    connect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
  }

  export type TicketMaintenanceUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput> | TicketMaintenanceCreateWithoutEquipementInput[] | TicketMaintenanceUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: TicketMaintenanceCreateOrConnectWithoutEquipementInput | TicketMaintenanceCreateOrConnectWithoutEquipementInput[]
    upsert?: TicketMaintenanceUpsertWithWhereUniqueWithoutEquipementInput | TicketMaintenanceUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: TicketMaintenanceCreateManyEquipementInputEnvelope
    set?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    disconnect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    delete?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    connect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    update?: TicketMaintenanceUpdateWithWhereUniqueWithoutEquipementInput | TicketMaintenanceUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: TicketMaintenanceUpdateManyWithWhereWithoutEquipementInput | TicketMaintenanceUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: TicketMaintenanceScalarWhereInput | TicketMaintenanceScalarWhereInput[]
  }

  export type TicketMaintenanceUncheckedUpdateManyWithoutEquipementNestedInput = {
    create?: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput> | TicketMaintenanceCreateWithoutEquipementInput[] | TicketMaintenanceUncheckedCreateWithoutEquipementInput[]
    connectOrCreate?: TicketMaintenanceCreateOrConnectWithoutEquipementInput | TicketMaintenanceCreateOrConnectWithoutEquipementInput[]
    upsert?: TicketMaintenanceUpsertWithWhereUniqueWithoutEquipementInput | TicketMaintenanceUpsertWithWhereUniqueWithoutEquipementInput[]
    createMany?: TicketMaintenanceCreateManyEquipementInputEnvelope
    set?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    disconnect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    delete?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    connect?: TicketMaintenanceWhereUniqueInput | TicketMaintenanceWhereUniqueInput[]
    update?: TicketMaintenanceUpdateWithWhereUniqueWithoutEquipementInput | TicketMaintenanceUpdateWithWhereUniqueWithoutEquipementInput[]
    updateMany?: TicketMaintenanceUpdateManyWithWhereWithoutEquipementInput | TicketMaintenanceUpdateManyWithWhereWithoutEquipementInput[]
    deleteMany?: TicketMaintenanceScalarWhereInput | TicketMaintenanceScalarWhereInput[]
  }

  export type EquipementCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EquipementCreateWithoutTicketsInput, EquipementUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutTicketsInput
    connect?: EquipementWhereUniqueInput
  }

  export type EquipementUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<EquipementCreateWithoutTicketsInput, EquipementUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EquipementCreateOrConnectWithoutTicketsInput
    upsert?: EquipementUpsertWithoutTicketsInput
    connect?: EquipementWhereUniqueInput
    update?: XOR<XOR<EquipementUpdateToOneWithWhereWithoutTicketsInput, EquipementUpdateWithoutTicketsInput>, EquipementUncheckedUpdateWithoutTicketsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    permissions?: PermissionCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ConsultationCreateWithoutMedecinInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseCreateNestedManyWithoutConsultationInput
    facture?: FactureCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationUncheckedCreateWithoutMedecinInput = {
    id?: string
    patientId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutMedecinInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput>
  }

  export type ConsultationCreateManyMedecinInputEnvelope = {
    data: ConsultationCreateManyMedecinInput | ConsultationCreateManyMedecinInput[]
    skipDuplicates?: boolean
  }

  export type RendezVousCreateWithoutMedecinInput = {
    id?: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutRendezvousInput
  }

  export type RendezVousUncheckedCreateWithoutMedecinInput = {
    id?: string
    patientId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousCreateOrConnectWithoutMedecinInput = {
    where: RendezVousWhereUniqueInput
    create: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput>
  }

  export type RendezVousCreateManyMedecinInputEnvelope = {
    data: RendezVousCreateManyMedecinInput | RendezVousCreateManyMedecinInput[]
    skipDuplicates?: boolean
  }

  export type EcritureComptableCreateWithoutCreatedByInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal: JournalCreateNestedOneWithoutEcrituresInput
    compte: CompteComptableCreateNestedOneWithoutEcrituresInput
    exercice: ExerciceComptableCreateNestedOneWithoutEcrituresInput
    centreAnalytique?: CentreAnalytiqueCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateWithoutCreatedByInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateOrConnectWithoutCreatedByInput = {
    where: EcritureComptableWhereUniqueInput
    create: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput>
  }

  export type EcritureComptableCreateManyCreatedByInputEnvelope = {
    data: EcritureComptableCreateManyCreatedByInput | EcritureComptableCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutCreatedByInput = {
    id?: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    facture: FactureCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    factureId: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutCreatedByInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput>
  }

  export type PaiementCreateManyCreatedByInputEnvelope = {
    data: PaiementCreateManyCreatedByInput | PaiementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ObservationInfirmierCreateWithoutInfirmierInput = {
    id?: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
    hospitalisation: HospitalisationCreateNestedOneWithoutObservationsInput
  }

  export type ObservationInfirmierUncheckedCreateWithoutInfirmierInput = {
    id?: string
    hospitalisationId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type ObservationInfirmierCreateOrConnectWithoutInfirmierInput = {
    where: ObservationInfirmierWhereUniqueInput
    create: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput>
  }

  export type ObservationInfirmierCreateManyInfirmierInputEnvelope = {
    data: ObservationInfirmierCreateManyInfirmierInput | ObservationInfirmierCreateManyInfirmierInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutChirurgienInput = {
    id?: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInterventionsInput
    anesthesiste?: UserCreateNestedOneWithoutAnesthesiesInput
  }

  export type InterventionUncheckedCreateWithoutChirurgienInput = {
    id?: string
    patientId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionCreateOrConnectWithoutChirurgienInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput>
  }

  export type InterventionCreateManyChirurgienInputEnvelope = {
    data: InterventionCreateManyChirurgienInput | InterventionCreateManyChirurgienInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutAnesthesisteInput = {
    id?: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutInterventionsInput
    chirurgien: UserCreateNestedOneWithoutChirurgiesInput
  }

  export type InterventionUncheckedCreateWithoutAnesthesisteInput = {
    id?: string
    patientId: string
    chirurgienId: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionCreateOrConnectWithoutAnesthesisteInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput>
  }

  export type InterventionCreateManyAnesthesisteInputEnvelope = {
    data: InterventionCreateManyAnesthesisteInput | InterventionCreateManyAnesthesisteInput[]
    skipDuplicates?: boolean
  }

  export type EmployeCreateWithoutUserInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conges?: CongeCreateNestedManyWithoutEmployeInput
    plannings?: PlanningCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUncheckedCreateWithoutUserInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conges?: CongeUncheckedCreateNestedManyWithoutEmployeInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeCreateOrConnectWithoutUserInput = {
    where: EmployeWhereUniqueInput
    create: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUpdateManyWithoutRolesNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type ConsultationUpsertWithWhereUniqueWithoutMedecinInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutMedecinInput, ConsultationUncheckedUpdateWithoutMedecinInput>
    create: XOR<ConsultationCreateWithoutMedecinInput, ConsultationUncheckedCreateWithoutMedecinInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutMedecinInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutMedecinInput, ConsultationUncheckedUpdateWithoutMedecinInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutMedecinInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutMedecinInput>
  }

  export type ConsultationScalarWhereInput = {
    AND?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    OR?: ConsultationScalarWhereInput[]
    NOT?: ConsultationScalarWhereInput | ConsultationScalarWhereInput[]
    id?: StringFilter<"Consultation"> | string
    patientId?: StringFilter<"Consultation"> | string
    medecinId?: StringFilter<"Consultation"> | string
    dateConsultation?: DateTimeFilter<"Consultation"> | Date | string
    motifConsultation?: StringFilter<"Consultation"> | string
    anamnese?: StringNullableFilter<"Consultation"> | string | null
    examenClinique?: StringNullableFilter<"Consultation"> | string | null
    diagnostic?: StringNullableFilter<"Consultation"> | string | null
    planTraitement?: StringNullableFilter<"Consultation"> | string | null
    poids?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    taille?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    temperature?: DecimalNullableFilter<"Consultation"> | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: IntNullableFilter<"Consultation"> | number | null
    tensionDiastolique?: IntNullableFilter<"Consultation"> | number | null
    frequenceCardiaque?: IntNullableFilter<"Consultation"> | number | null
    saturationOxygene?: IntNullableFilter<"Consultation"> | number | null
    donneesSpecialite?: JsonNullableFilter<"Consultation">
    factureId?: StringNullableFilter<"Consultation"> | string | null
    createdAt?: DateTimeFilter<"Consultation"> | Date | string
    updatedAt?: DateTimeFilter<"Consultation"> | Date | string
  }

  export type RendezVousUpsertWithWhereUniqueWithoutMedecinInput = {
    where: RendezVousWhereUniqueInput
    update: XOR<RendezVousUpdateWithoutMedecinInput, RendezVousUncheckedUpdateWithoutMedecinInput>
    create: XOR<RendezVousCreateWithoutMedecinInput, RendezVousUncheckedCreateWithoutMedecinInput>
  }

  export type RendezVousUpdateWithWhereUniqueWithoutMedecinInput = {
    where: RendezVousWhereUniqueInput
    data: XOR<RendezVousUpdateWithoutMedecinInput, RendezVousUncheckedUpdateWithoutMedecinInput>
  }

  export type RendezVousUpdateManyWithWhereWithoutMedecinInput = {
    where: RendezVousScalarWhereInput
    data: XOR<RendezVousUpdateManyMutationInput, RendezVousUncheckedUpdateManyWithoutMedecinInput>
  }

  export type RendezVousScalarWhereInput = {
    AND?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
    OR?: RendezVousScalarWhereInput[]
    NOT?: RendezVousScalarWhereInput | RendezVousScalarWhereInput[]
    id?: StringFilter<"RendezVous"> | string
    patientId?: StringFilter<"RendezVous"> | string
    medecinId?: StringFilter<"RendezVous"> | string
    dateHeure?: DateTimeFilter<"RendezVous"> | Date | string
    duree?: IntFilter<"RendezVous"> | number
    motif?: StringFilter<"RendezVous"> | string
    statut?: StringFilter<"RendezVous"> | string
    notes?: StringNullableFilter<"RendezVous"> | string | null
    createdAt?: DateTimeFilter<"RendezVous"> | Date | string
    updatedAt?: DateTimeFilter<"RendezVous"> | Date | string
  }

  export type EcritureComptableUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EcritureComptableWhereUniqueInput
    update: XOR<EcritureComptableUpdateWithoutCreatedByInput, EcritureComptableUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EcritureComptableCreateWithoutCreatedByInput, EcritureComptableUncheckedCreateWithoutCreatedByInput>
  }

  export type EcritureComptableUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EcritureComptableWhereUniqueInput
    data: XOR<EcritureComptableUpdateWithoutCreatedByInput, EcritureComptableUncheckedUpdateWithoutCreatedByInput>
  }

  export type EcritureComptableUpdateManyWithWhereWithoutCreatedByInput = {
    where: EcritureComptableScalarWhereInput
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type EcritureComptableScalarWhereInput = {
    AND?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
    OR?: EcritureComptableScalarWhereInput[]
    NOT?: EcritureComptableScalarWhereInput | EcritureComptableScalarWhereInput[]
    id?: StringFilter<"EcritureComptable"> | string
    journalId?: StringFilter<"EcritureComptable"> | string
    compteId?: StringFilter<"EcritureComptable"> | string
    exerciceId?: StringFilter<"EcritureComptable"> | string
    dateEcriture?: DateTimeFilter<"EcritureComptable"> | Date | string
    libelle?: StringFilter<"EcritureComptable"> | string
    debit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    credit?: DecimalFilter<"EcritureComptable"> | Decimal | DecimalJsLike | number | string
    pieceRef?: StringNullableFilter<"EcritureComptable"> | string | null
    centreAnalytiqueId?: StringNullableFilter<"EcritureComptable"> | string | null
    valide?: BoolFilter<"EcritureComptable"> | boolean
    createdById?: StringFilter<"EcritureComptable"> | string
    createdAt?: DateTimeFilter<"EcritureComptable"> | Date | string
    updatedAt?: DateTimeFilter<"EcritureComptable"> | Date | string
  }

  export type PaiementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutCreatedByInput, PaiementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PaiementCreateWithoutCreatedByInput, PaiementUncheckedCreateWithoutCreatedByInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutCreatedByInput, PaiementUncheckedUpdateWithoutCreatedByInput>
  }

  export type PaiementUpdateManyWithWhereWithoutCreatedByInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: StringFilter<"Paiement"> | string
    factureId?: StringFilter<"Paiement"> | string
    datePaiement?: DateTimeFilter<"Paiement"> | Date | string
    montant?: DecimalFilter<"Paiement"> | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFilter<"Paiement"> | string
    reference?: StringNullableFilter<"Paiement"> | string | null
    notes?: StringNullableFilter<"Paiement"> | string | null
    createdById?: StringFilter<"Paiement"> | string
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    module?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type ObservationInfirmierUpsertWithWhereUniqueWithoutInfirmierInput = {
    where: ObservationInfirmierWhereUniqueInput
    update: XOR<ObservationInfirmierUpdateWithoutInfirmierInput, ObservationInfirmierUncheckedUpdateWithoutInfirmierInput>
    create: XOR<ObservationInfirmierCreateWithoutInfirmierInput, ObservationInfirmierUncheckedCreateWithoutInfirmierInput>
  }

  export type ObservationInfirmierUpdateWithWhereUniqueWithoutInfirmierInput = {
    where: ObservationInfirmierWhereUniqueInput
    data: XOR<ObservationInfirmierUpdateWithoutInfirmierInput, ObservationInfirmierUncheckedUpdateWithoutInfirmierInput>
  }

  export type ObservationInfirmierUpdateManyWithWhereWithoutInfirmierInput = {
    where: ObservationInfirmierScalarWhereInput
    data: XOR<ObservationInfirmierUpdateManyMutationInput, ObservationInfirmierUncheckedUpdateManyWithoutInfirmierInput>
  }

  export type ObservationInfirmierScalarWhereInput = {
    AND?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
    OR?: ObservationInfirmierScalarWhereInput[]
    NOT?: ObservationInfirmierScalarWhereInput | ObservationInfirmierScalarWhereInput[]
    id?: StringFilter<"ObservationInfirmier"> | string
    hospitalisationId?: StringFilter<"ObservationInfirmier"> | string
    infirmierId?: StringFilter<"ObservationInfirmier"> | string
    pressionArterielle?: StringNullableFilter<"ObservationInfirmier"> | string | null
    temperature?: DecimalNullableFilter<"ObservationInfirmier"> | Decimal | DecimalJsLike | number | string | null
    note?: StringFilter<"ObservationInfirmier"> | string
    dateHeure?: DateTimeFilter<"ObservationInfirmier"> | Date | string
  }

  export type InterventionUpsertWithWhereUniqueWithoutChirurgienInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutChirurgienInput, InterventionUncheckedUpdateWithoutChirurgienInput>
    create: XOR<InterventionCreateWithoutChirurgienInput, InterventionUncheckedCreateWithoutChirurgienInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutChirurgienInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutChirurgienInput, InterventionUncheckedUpdateWithoutChirurgienInput>
  }

  export type InterventionUpdateManyWithWhereWithoutChirurgienInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutChirurgienInput>
  }

  export type InterventionScalarWhereInput = {
    AND?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    OR?: InterventionScalarWhereInput[]
    NOT?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    id?: StringFilter<"Intervention"> | string
    patientId?: StringFilter<"Intervention"> | string
    chirurgienId?: StringFilter<"Intervention"> | string
    anesthesisteId?: StringNullableFilter<"Intervention"> | string | null
    typeIntervention?: StringFilter<"Intervention"> | string
    dateHeure?: DateTimeFilter<"Intervention"> | Date | string
    salle?: StringFilter<"Intervention"> | string
    statut?: StringFilter<"Intervention"> | string
    protocoleOp?: StringNullableFilter<"Intervention"> | string | null
    typeAnesthesie?: StringNullableFilter<"Intervention"> | string | null
    duree?: IntNullableFilter<"Intervention"> | number | null
    createdAt?: DateTimeFilter<"Intervention"> | Date | string
  }

  export type InterventionUpsertWithWhereUniqueWithoutAnesthesisteInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutAnesthesisteInput, InterventionUncheckedUpdateWithoutAnesthesisteInput>
    create: XOR<InterventionCreateWithoutAnesthesisteInput, InterventionUncheckedCreateWithoutAnesthesisteInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutAnesthesisteInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutAnesthesisteInput, InterventionUncheckedUpdateWithoutAnesthesisteInput>
  }

  export type InterventionUpdateManyWithWhereWithoutAnesthesisteInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutAnesthesisteInput>
  }

  export type EmployeUpsertWithoutUserInput = {
    update: XOR<EmployeUpdateWithoutUserInput, EmployeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeCreateWithoutUserInput, EmployeUncheckedCreateWithoutUserInput>
    where?: EmployeWhereInput
  }

  export type EmployeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeWhereInput
    data: XOR<EmployeUpdateWithoutUserInput, EmployeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conges?: CongeUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conges?: CongeUncheckedUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    nom: string
    description?: string | null
    module: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    nom: string
    description?: string | null
    module: string
    action: string
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionUpsertWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRolesInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRolesInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    id?: StringFilter<"Permission"> | string
    nom?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    module?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    createdAt?: DateTimeFilter<"Permission"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    nom?: StringFilter<"User"> | string
    prenom?: StringFilter<"User"> | string
    telephone?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    actif?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    nom: string
    description?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type RoleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateManyWithWhereWithoutPermissionsInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[]
    OR?: RoleScalarWhereInput[]
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[]
    id?: StringFilter<"Role"> | string
    nom?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EcritureComptableCreateWithoutCompteInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal: JournalCreateNestedOneWithoutEcrituresInput
    exercice: ExerciceComptableCreateNestedOneWithoutEcrituresInput
    centreAnalytique?: CentreAnalytiqueCreateNestedOneWithoutEcrituresInput
    createdBy: UserCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateWithoutCompteInput = {
    id?: string
    journalId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateOrConnectWithoutCompteInput = {
    where: EcritureComptableWhereUniqueInput
    create: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput>
  }

  export type EcritureComptableCreateManyCompteInputEnvelope = {
    data: EcritureComptableCreateManyCompteInput | EcritureComptableCreateManyCompteInput[]
    skipDuplicates?: boolean
  }

  export type EcritureComptableUpsertWithWhereUniqueWithoutCompteInput = {
    where: EcritureComptableWhereUniqueInput
    update: XOR<EcritureComptableUpdateWithoutCompteInput, EcritureComptableUncheckedUpdateWithoutCompteInput>
    create: XOR<EcritureComptableCreateWithoutCompteInput, EcritureComptableUncheckedCreateWithoutCompteInput>
  }

  export type EcritureComptableUpdateWithWhereUniqueWithoutCompteInput = {
    where: EcritureComptableWhereUniqueInput
    data: XOR<EcritureComptableUpdateWithoutCompteInput, EcritureComptableUncheckedUpdateWithoutCompteInput>
  }

  export type EcritureComptableUpdateManyWithWhereWithoutCompteInput = {
    where: EcritureComptableScalarWhereInput
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyWithoutCompteInput>
  }

  export type EcritureComptableCreateWithoutJournalInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    compte: CompteComptableCreateNestedOneWithoutEcrituresInput
    exercice: ExerciceComptableCreateNestedOneWithoutEcrituresInput
    centreAnalytique?: CentreAnalytiqueCreateNestedOneWithoutEcrituresInput
    createdBy: UserCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateWithoutJournalInput = {
    id?: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateOrConnectWithoutJournalInput = {
    where: EcritureComptableWhereUniqueInput
    create: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput>
  }

  export type EcritureComptableCreateManyJournalInputEnvelope = {
    data: EcritureComptableCreateManyJournalInput | EcritureComptableCreateManyJournalInput[]
    skipDuplicates?: boolean
  }

  export type EcritureComptableUpsertWithWhereUniqueWithoutJournalInput = {
    where: EcritureComptableWhereUniqueInput
    update: XOR<EcritureComptableUpdateWithoutJournalInput, EcritureComptableUncheckedUpdateWithoutJournalInput>
    create: XOR<EcritureComptableCreateWithoutJournalInput, EcritureComptableUncheckedCreateWithoutJournalInput>
  }

  export type EcritureComptableUpdateWithWhereUniqueWithoutJournalInput = {
    where: EcritureComptableWhereUniqueInput
    data: XOR<EcritureComptableUpdateWithoutJournalInput, EcritureComptableUncheckedUpdateWithoutJournalInput>
  }

  export type EcritureComptableUpdateManyWithWhereWithoutJournalInput = {
    where: EcritureComptableScalarWhereInput
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyWithoutJournalInput>
  }

  export type EcritureComptableCreateWithoutExerciceInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal: JournalCreateNestedOneWithoutEcrituresInput
    compte: CompteComptableCreateNestedOneWithoutEcrituresInput
    centreAnalytique?: CentreAnalytiqueCreateNestedOneWithoutEcrituresInput
    createdBy: UserCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateWithoutExerciceInput = {
    id?: string
    journalId: string
    compteId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateOrConnectWithoutExerciceInput = {
    where: EcritureComptableWhereUniqueInput
    create: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput>
  }

  export type EcritureComptableCreateManyExerciceInputEnvelope = {
    data: EcritureComptableCreateManyExerciceInput | EcritureComptableCreateManyExerciceInput[]
    skipDuplicates?: boolean
  }

  export type BudgetCreateWithoutExerciceInput = {
    id?: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
  }

  export type BudgetUncheckedCreateWithoutExerciceInput = {
    id?: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
  }

  export type BudgetCreateOrConnectWithoutExerciceInput = {
    where: BudgetWhereUniqueInput
    create: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput>
  }

  export type BudgetCreateManyExerciceInputEnvelope = {
    data: BudgetCreateManyExerciceInput | BudgetCreateManyExerciceInput[]
    skipDuplicates?: boolean
  }

  export type EcritureComptableUpsertWithWhereUniqueWithoutExerciceInput = {
    where: EcritureComptableWhereUniqueInput
    update: XOR<EcritureComptableUpdateWithoutExerciceInput, EcritureComptableUncheckedUpdateWithoutExerciceInput>
    create: XOR<EcritureComptableCreateWithoutExerciceInput, EcritureComptableUncheckedCreateWithoutExerciceInput>
  }

  export type EcritureComptableUpdateWithWhereUniqueWithoutExerciceInput = {
    where: EcritureComptableWhereUniqueInput
    data: XOR<EcritureComptableUpdateWithoutExerciceInput, EcritureComptableUncheckedUpdateWithoutExerciceInput>
  }

  export type EcritureComptableUpdateManyWithWhereWithoutExerciceInput = {
    where: EcritureComptableScalarWhereInput
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyWithoutExerciceInput>
  }

  export type BudgetUpsertWithWhereUniqueWithoutExerciceInput = {
    where: BudgetWhereUniqueInput
    update: XOR<BudgetUpdateWithoutExerciceInput, BudgetUncheckedUpdateWithoutExerciceInput>
    create: XOR<BudgetCreateWithoutExerciceInput, BudgetUncheckedCreateWithoutExerciceInput>
  }

  export type BudgetUpdateWithWhereUniqueWithoutExerciceInput = {
    where: BudgetWhereUniqueInput
    data: XOR<BudgetUpdateWithoutExerciceInput, BudgetUncheckedUpdateWithoutExerciceInput>
  }

  export type BudgetUpdateManyWithWhereWithoutExerciceInput = {
    where: BudgetScalarWhereInput
    data: XOR<BudgetUpdateManyMutationInput, BudgetUncheckedUpdateManyWithoutExerciceInput>
  }

  export type BudgetScalarWhereInput = {
    AND?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    OR?: BudgetScalarWhereInput[]
    NOT?: BudgetScalarWhereInput | BudgetScalarWhereInput[]
    id?: StringFilter<"Budget"> | string
    exerciceId?: StringFilter<"Budget"> | string
    compte?: StringFilter<"Budget"> | string
    libelle?: StringFilter<"Budget"> | string
    montant?: DecimalFilter<"Budget"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"Budget"> | string
    mois?: IntNullableFilter<"Budget"> | number | null
    createdAt?: DateTimeFilter<"Budget"> | Date | string
  }

  export type JournalCreateWithoutEcrituresInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type JournalUncheckedCreateWithoutEcrituresInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type JournalCreateOrConnectWithoutEcrituresInput = {
    where: JournalWhereUniqueInput
    create: XOR<JournalCreateWithoutEcrituresInput, JournalUncheckedCreateWithoutEcrituresInput>
  }

  export type CompteComptableCreateWithoutEcrituresInput = {
    id?: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompteComptableUncheckedCreateWithoutEcrituresInput = {
    id?: string
    numero: string
    libelle: string
    classe: number
    type: string
    sens: string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompteComptableCreateOrConnectWithoutEcrituresInput = {
    where: CompteComptableWhereUniqueInput
    create: XOR<CompteComptableCreateWithoutEcrituresInput, CompteComptableUncheckedCreateWithoutEcrituresInput>
  }

  export type ExerciceComptableCreateWithoutEcrituresInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    budgets?: BudgetCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableUncheckedCreateWithoutEcrituresInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    budgets?: BudgetUncheckedCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableCreateOrConnectWithoutEcrituresInput = {
    where: ExerciceComptableWhereUniqueInput
    create: XOR<ExerciceComptableCreateWithoutEcrituresInput, ExerciceComptableUncheckedCreateWithoutEcrituresInput>
  }

  export type CentreAnalytiqueCreateWithoutEcrituresInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type CentreAnalytiqueUncheckedCreateWithoutEcrituresInput = {
    id?: string
    code: string
    libelle: string
    type: string
    actif?: boolean
    createdAt?: Date | string
  }

  export type CentreAnalytiqueCreateOrConnectWithoutEcrituresInput = {
    where: CentreAnalytiqueWhereUniqueInput
    create: XOR<CentreAnalytiqueCreateWithoutEcrituresInput, CentreAnalytiqueUncheckedCreateWithoutEcrituresInput>
  }

  export type UserCreateWithoutEcrituresInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEcrituresInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEcrituresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEcrituresInput, UserUncheckedCreateWithoutEcrituresInput>
  }

  export type JournalUpsertWithoutEcrituresInput = {
    update: XOR<JournalUpdateWithoutEcrituresInput, JournalUncheckedUpdateWithoutEcrituresInput>
    create: XOR<JournalCreateWithoutEcrituresInput, JournalUncheckedCreateWithoutEcrituresInput>
    where?: JournalWhereInput
  }

  export type JournalUpdateToOneWithWhereWithoutEcrituresInput = {
    where?: JournalWhereInput
    data: XOR<JournalUpdateWithoutEcrituresInput, JournalUncheckedUpdateWithoutEcrituresInput>
  }

  export type JournalUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalUncheckedUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteComptableUpsertWithoutEcrituresInput = {
    update: XOR<CompteComptableUpdateWithoutEcrituresInput, CompteComptableUncheckedUpdateWithoutEcrituresInput>
    create: XOR<CompteComptableCreateWithoutEcrituresInput, CompteComptableUncheckedCreateWithoutEcrituresInput>
    where?: CompteComptableWhereInput
  }

  export type CompteComptableUpdateToOneWithWhereWithoutEcrituresInput = {
    where?: CompteComptableWhereInput
    data: XOR<CompteComptableUpdateWithoutEcrituresInput, CompteComptableUncheckedUpdateWithoutEcrituresInput>
  }

  export type CompteComptableUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompteComptableUncheckedUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    classe?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sens?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciceComptableUpsertWithoutEcrituresInput = {
    update: XOR<ExerciceComptableUpdateWithoutEcrituresInput, ExerciceComptableUncheckedUpdateWithoutEcrituresInput>
    create: XOR<ExerciceComptableCreateWithoutEcrituresInput, ExerciceComptableUncheckedCreateWithoutEcrituresInput>
    where?: ExerciceComptableWhereInput
  }

  export type ExerciceComptableUpdateToOneWithWhereWithoutEcrituresInput = {
    where?: ExerciceComptableWhereInput
    data: XOR<ExerciceComptableUpdateWithoutEcrituresInput, ExerciceComptableUncheckedUpdateWithoutEcrituresInput>
  }

  export type ExerciceComptableUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgets?: BudgetUpdateManyWithoutExerciceNestedInput
  }

  export type ExerciceComptableUncheckedUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    budgets?: BudgetUncheckedUpdateManyWithoutExerciceNestedInput
  }

  export type CentreAnalytiqueUpsertWithoutEcrituresInput = {
    update: XOR<CentreAnalytiqueUpdateWithoutEcrituresInput, CentreAnalytiqueUncheckedUpdateWithoutEcrituresInput>
    create: XOR<CentreAnalytiqueCreateWithoutEcrituresInput, CentreAnalytiqueUncheckedCreateWithoutEcrituresInput>
    where?: CentreAnalytiqueWhereInput
  }

  export type CentreAnalytiqueUpdateToOneWithWhereWithoutEcrituresInput = {
    where?: CentreAnalytiqueWhereInput
    data: XOR<CentreAnalytiqueUpdateWithoutEcrituresInput, CentreAnalytiqueUncheckedUpdateWithoutEcrituresInput>
  }

  export type CentreAnalytiqueUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CentreAnalytiqueUncheckedUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEcrituresInput = {
    update: XOR<UserUpdateWithoutEcrituresInput, UserUncheckedUpdateWithoutEcrituresInput>
    create: XOR<UserCreateWithoutEcrituresInput, UserUncheckedCreateWithoutEcrituresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEcrituresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEcrituresInput, UserUncheckedUpdateWithoutEcrituresInput>
  }

  export type UserUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEcrituresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type EcritureComptableCreateWithoutCentreAnalytiqueInput = {
    id?: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    journal: JournalCreateNestedOneWithoutEcrituresInput
    compte: CompteComptableCreateNestedOneWithoutEcrituresInput
    exercice: ExerciceComptableCreateNestedOneWithoutEcrituresInput
    createdBy: UserCreateNestedOneWithoutEcrituresInput
  }

  export type EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateOrConnectWithoutCentreAnalytiqueInput = {
    where: EcritureComptableWhereUniqueInput
    create: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput>
  }

  export type EcritureComptableCreateManyCentreAnalytiqueInputEnvelope = {
    data: EcritureComptableCreateManyCentreAnalytiqueInput | EcritureComptableCreateManyCentreAnalytiqueInput[]
    skipDuplicates?: boolean
  }

  export type EcritureComptableUpsertWithWhereUniqueWithoutCentreAnalytiqueInput = {
    where: EcritureComptableWhereUniqueInput
    update: XOR<EcritureComptableUpdateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedUpdateWithoutCentreAnalytiqueInput>
    create: XOR<EcritureComptableCreateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedCreateWithoutCentreAnalytiqueInput>
  }

  export type EcritureComptableUpdateWithWhereUniqueWithoutCentreAnalytiqueInput = {
    where: EcritureComptableWhereUniqueInput
    data: XOR<EcritureComptableUpdateWithoutCentreAnalytiqueInput, EcritureComptableUncheckedUpdateWithoutCentreAnalytiqueInput>
  }

  export type EcritureComptableUpdateManyWithWhereWithoutCentreAnalytiqueInput = {
    where: EcritureComptableScalarWhereInput
    data: XOR<EcritureComptableUpdateManyMutationInput, EcritureComptableUncheckedUpdateManyWithoutCentreAnalytiqueInput>
  }

  export type ExerciceComptableCreateWithoutBudgetsInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableUncheckedCreateWithoutBudgetsInput = {
    id?: string
    annee: number
    dateDebut: Date | string
    dateFin: Date | string
    cloture?: boolean
    createdAt?: Date | string
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutExerciceInput
  }

  export type ExerciceComptableCreateOrConnectWithoutBudgetsInput = {
    where: ExerciceComptableWhereUniqueInput
    create: XOR<ExerciceComptableCreateWithoutBudgetsInput, ExerciceComptableUncheckedCreateWithoutBudgetsInput>
  }

  export type ExerciceComptableUpsertWithoutBudgetsInput = {
    update: XOR<ExerciceComptableUpdateWithoutBudgetsInput, ExerciceComptableUncheckedUpdateWithoutBudgetsInput>
    create: XOR<ExerciceComptableCreateWithoutBudgetsInput, ExerciceComptableUncheckedCreateWithoutBudgetsInput>
    where?: ExerciceComptableWhereInput
  }

  export type ExerciceComptableUpdateToOneWithWhereWithoutBudgetsInput = {
    where?: ExerciceComptableWhereInput
    data: XOR<ExerciceComptableUpdateWithoutBudgetsInput, ExerciceComptableUncheckedUpdateWithoutBudgetsInput>
  }

  export type ExerciceComptableUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUpdateManyWithoutExerciceNestedInput
  }

  export type ExerciceComptableUncheckedUpdateWithoutBudgetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    cloture?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutExerciceNestedInput
  }

  export type AntecedentCreateWithoutPatientInput = {
    id?: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
  }

  export type AntecedentUncheckedCreateWithoutPatientInput = {
    id?: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
  }

  export type AntecedentCreateOrConnectWithoutPatientInput = {
    where: AntecedentWhereUniqueInput
    create: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput>
  }

  export type AntecedentCreateManyPatientInputEnvelope = {
    data: AntecedentCreateManyPatientInput | AntecedentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AllergieCreateWithoutPatientInput = {
    id?: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
  }

  export type AllergieUncheckedCreateWithoutPatientInput = {
    id?: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
  }

  export type AllergieCreateOrConnectWithoutPatientInput = {
    where: AllergieWhereUniqueInput
    create: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput>
  }

  export type AllergieCreateManyPatientInputEnvelope = {
    data: AllergieCreateManyPatientInput | AllergieCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type VaccinationCreateWithoutPatientInput = {
    id?: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
  }

  export type VaccinationUncheckedCreateWithoutPatientInput = {
    id?: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput>
  }

  export type VaccinationCreateManyPatientInputEnvelope = {
    data: VaccinationCreateManyPatientInput | VaccinationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationCreateWithoutPatientInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    medecin: UserCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseCreateNestedManyWithoutConsultationInput
    facture?: FactureCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationUncheckedCreateWithoutPatientInput = {
    id?: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationCreateManyPatientInputEnvelope = {
    data: ConsultationCreateManyPatientInput | ConsultationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type RendezVousCreateWithoutPatientInput = {
    id?: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medecin: UserCreateNestedOneWithoutRendezvousInput
  }

  export type RendezVousUncheckedCreateWithoutPatientInput = {
    id?: string
    medecinId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousCreateOrConnectWithoutPatientInput = {
    where: RendezVousWhereUniqueInput
    create: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput>
  }

  export type RendezVousCreateManyPatientInputEnvelope = {
    data: RendezVousCreateManyPatientInput | RendezVousCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type FactureCreateWithoutPatientInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneFactureCreateNestedManyWithoutFactureInput
    paiements?: PaiementCreateNestedManyWithoutFactureInput
    consultations?: ConsultationCreateNestedManyWithoutFactureInput
  }

  export type FactureUncheckedCreateWithoutPatientInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneFactureUncheckedCreateNestedManyWithoutFactureInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutFactureInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureCreateOrConnectWithoutPatientInput = {
    where: FactureWhereUniqueInput
    create: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput>
  }

  export type FactureCreateManyPatientInputEnvelope = {
    data: FactureCreateManyPatientInput | FactureCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DispensationCreateWithoutPatientInput = {
    id?: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
    medicament: MedicamentCreateNestedOneWithoutDispensationsInput
  }

  export type DispensationUncheckedCreateWithoutPatientInput = {
    id?: string
    medicamentId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type DispensationCreateOrConnectWithoutPatientInput = {
    where: DispensationWhereUniqueInput
    create: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput>
  }

  export type DispensationCreateManyPatientInputEnvelope = {
    data: DispensationCreateManyPatientInput | DispensationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type HospitalisationCreateWithoutPatientInput = {
    id?: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lit: LitCreateNestedOneWithoutHospitalisationsInput
    observations?: ObservationInfirmierCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationUncheckedCreateWithoutPatientInput = {
    id?: string
    litId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationInfirmierUncheckedCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationCreateOrConnectWithoutPatientInput = {
    where: HospitalisationWhereUniqueInput
    create: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput>
  }

  export type HospitalisationCreateManyPatientInputEnvelope = {
    data: HospitalisationCreateManyPatientInput | HospitalisationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutPatientInput = {
    id?: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
    chirurgien: UserCreateNestedOneWithoutChirurgiesInput
    anesthesiste?: UserCreateNestedOneWithoutAnesthesiesInput
  }

  export type InterventionUncheckedCreateWithoutPatientInput = {
    id?: string
    chirurgienId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionCreateOrConnectWithoutPatientInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput>
  }

  export type InterventionCreateManyPatientInputEnvelope = {
    data: InterventionCreateManyPatientInput | InterventionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DossierMaterniteCreateWithoutPatientInput = {
    id?: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    nouveauNes?: NouveauNeCreateNestedManyWithoutDossierMaterniteInput
  }

  export type DossierMaterniteUncheckedCreateWithoutPatientInput = {
    id?: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    nouveauNes?: NouveauNeUncheckedCreateNestedManyWithoutDossierMaterniteInput
  }

  export type DossierMaterniteCreateOrConnectWithoutPatientInput = {
    where: DossierMaterniteWhereUniqueInput
    create: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput>
  }

  export type DossierMaterniteCreateManyPatientInputEnvelope = {
    data: DossierMaterniteCreateManyPatientInput | DossierMaterniteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DocumentGEDCreateWithoutPatientInput = {
    id?: string
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentGEDUncheckedCreateWithoutPatientInput = {
    id?: string
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentGEDCreateOrConnectWithoutPatientInput = {
    where: DocumentGEDWhereUniqueInput
    create: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput>
  }

  export type DocumentGEDCreateManyPatientInputEnvelope = {
    data: DocumentGEDCreateManyPatientInput | DocumentGEDCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AntecedentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AntecedentWhereUniqueInput
    update: XOR<AntecedentUpdateWithoutPatientInput, AntecedentUncheckedUpdateWithoutPatientInput>
    create: XOR<AntecedentCreateWithoutPatientInput, AntecedentUncheckedCreateWithoutPatientInput>
  }

  export type AntecedentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AntecedentWhereUniqueInput
    data: XOR<AntecedentUpdateWithoutPatientInput, AntecedentUncheckedUpdateWithoutPatientInput>
  }

  export type AntecedentUpdateManyWithWhereWithoutPatientInput = {
    where: AntecedentScalarWhereInput
    data: XOR<AntecedentUpdateManyMutationInput, AntecedentUncheckedUpdateManyWithoutPatientInput>
  }

  export type AntecedentScalarWhereInput = {
    AND?: AntecedentScalarWhereInput | AntecedentScalarWhereInput[]
    OR?: AntecedentScalarWhereInput[]
    NOT?: AntecedentScalarWhereInput | AntecedentScalarWhereInput[]
    id?: StringFilter<"Antecedent"> | string
    patientId?: StringFilter<"Antecedent"> | string
    type?: StringFilter<"Antecedent"> | string
    description?: StringFilter<"Antecedent"> | string
    date?: DateTimeNullableFilter<"Antecedent"> | Date | string | null
    createdAt?: DateTimeFilter<"Antecedent"> | Date | string
  }

  export type AllergieUpsertWithWhereUniqueWithoutPatientInput = {
    where: AllergieWhereUniqueInput
    update: XOR<AllergieUpdateWithoutPatientInput, AllergieUncheckedUpdateWithoutPatientInput>
    create: XOR<AllergieCreateWithoutPatientInput, AllergieUncheckedCreateWithoutPatientInput>
  }

  export type AllergieUpdateWithWhereUniqueWithoutPatientInput = {
    where: AllergieWhereUniqueInput
    data: XOR<AllergieUpdateWithoutPatientInput, AllergieUncheckedUpdateWithoutPatientInput>
  }

  export type AllergieUpdateManyWithWhereWithoutPatientInput = {
    where: AllergieScalarWhereInput
    data: XOR<AllergieUpdateManyMutationInput, AllergieUncheckedUpdateManyWithoutPatientInput>
  }

  export type AllergieScalarWhereInput = {
    AND?: AllergieScalarWhereInput | AllergieScalarWhereInput[]
    OR?: AllergieScalarWhereInput[]
    NOT?: AllergieScalarWhereInput | AllergieScalarWhereInput[]
    id?: StringFilter<"Allergie"> | string
    patientId?: StringFilter<"Allergie"> | string
    type?: StringFilter<"Allergie"> | string
    allergene?: StringFilter<"Allergie"> | string
    severite?: StringFilter<"Allergie"> | string
    reaction?: StringNullableFilter<"Allergie"> | string | null
    createdAt?: DateTimeFilter<"Allergie"> | Date | string
  }

  export type VaccinationUpsertWithWhereUniqueWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutPatientInput, VaccinationUncheckedUpdateWithoutPatientInput>
    create: XOR<VaccinationCreateWithoutPatientInput, VaccinationUncheckedCreateWithoutPatientInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutPatientInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutPatientInput, VaccinationUncheckedUpdateWithoutPatientInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutPatientInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutPatientInput>
  }

  export type VaccinationScalarWhereInput = {
    AND?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    OR?: VaccinationScalarWhereInput[]
    NOT?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    id?: StringFilter<"Vaccination"> | string
    patientId?: StringFilter<"Vaccination"> | string
    vaccin?: StringFilter<"Vaccination"> | string
    dateVaccin?: DateTimeFilter<"Vaccination"> | Date | string
    rappel?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    lot?: StringNullableFilter<"Vaccination"> | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
  }

  export type ConsultationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
    create: XOR<ConsultationCreateWithoutPatientInput, ConsultationUncheckedCreateWithoutPatientInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutPatientInput, ConsultationUncheckedUpdateWithoutPatientInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutPatientInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutPatientInput>
  }

  export type RendezVousUpsertWithWhereUniqueWithoutPatientInput = {
    where: RendezVousWhereUniqueInput
    update: XOR<RendezVousUpdateWithoutPatientInput, RendezVousUncheckedUpdateWithoutPatientInput>
    create: XOR<RendezVousCreateWithoutPatientInput, RendezVousUncheckedCreateWithoutPatientInput>
  }

  export type RendezVousUpdateWithWhereUniqueWithoutPatientInput = {
    where: RendezVousWhereUniqueInput
    data: XOR<RendezVousUpdateWithoutPatientInput, RendezVousUncheckedUpdateWithoutPatientInput>
  }

  export type RendezVousUpdateManyWithWhereWithoutPatientInput = {
    where: RendezVousScalarWhereInput
    data: XOR<RendezVousUpdateManyMutationInput, RendezVousUncheckedUpdateManyWithoutPatientInput>
  }

  export type FactureUpsertWithWhereUniqueWithoutPatientInput = {
    where: FactureWhereUniqueInput
    update: XOR<FactureUpdateWithoutPatientInput, FactureUncheckedUpdateWithoutPatientInput>
    create: XOR<FactureCreateWithoutPatientInput, FactureUncheckedCreateWithoutPatientInput>
  }

  export type FactureUpdateWithWhereUniqueWithoutPatientInput = {
    where: FactureWhereUniqueInput
    data: XOR<FactureUpdateWithoutPatientInput, FactureUncheckedUpdateWithoutPatientInput>
  }

  export type FactureUpdateManyWithWhereWithoutPatientInput = {
    where: FactureScalarWhereInput
    data: XOR<FactureUpdateManyMutationInput, FactureUncheckedUpdateManyWithoutPatientInput>
  }

  export type FactureScalarWhereInput = {
    AND?: FactureScalarWhereInput | FactureScalarWhereInput[]
    OR?: FactureScalarWhereInput[]
    NOT?: FactureScalarWhereInput | FactureScalarWhereInput[]
    id?: StringFilter<"Facture"> | string
    numeroFacture?: StringFilter<"Facture"> | string
    patientId?: StringFilter<"Facture"> | string
    dateFacture?: DateTimeFilter<"Facture"> | Date | string
    dateEcheance?: DateTimeFilter<"Facture"> | Date | string
    montantHT?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFilter<"Facture"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"Facture"> | string
    ecritureComptableId?: StringNullableFilter<"Facture"> | string | null
    createdAt?: DateTimeFilter<"Facture"> | Date | string
    updatedAt?: DateTimeFilter<"Facture"> | Date | string
  }

  export type DispensationUpsertWithWhereUniqueWithoutPatientInput = {
    where: DispensationWhereUniqueInput
    update: XOR<DispensationUpdateWithoutPatientInput, DispensationUncheckedUpdateWithoutPatientInput>
    create: XOR<DispensationCreateWithoutPatientInput, DispensationUncheckedCreateWithoutPatientInput>
  }

  export type DispensationUpdateWithWhereUniqueWithoutPatientInput = {
    where: DispensationWhereUniqueInput
    data: XOR<DispensationUpdateWithoutPatientInput, DispensationUncheckedUpdateWithoutPatientInput>
  }

  export type DispensationUpdateManyWithWhereWithoutPatientInput = {
    where: DispensationScalarWhereInput
    data: XOR<DispensationUpdateManyMutationInput, DispensationUncheckedUpdateManyWithoutPatientInput>
  }

  export type DispensationScalarWhereInput = {
    AND?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
    OR?: DispensationScalarWhereInput[]
    NOT?: DispensationScalarWhereInput | DispensationScalarWhereInput[]
    id?: StringFilter<"Dispensation"> | string
    medicamentId?: StringFilter<"Dispensation"> | string
    patientId?: StringFilter<"Dispensation"> | string
    quantite?: IntFilter<"Dispensation"> | number
    prescription?: StringNullableFilter<"Dispensation"> | string | null
    pharmacien?: StringFilter<"Dispensation"> | string
    createdAt?: DateTimeFilter<"Dispensation"> | Date | string
  }

  export type HospitalisationUpsertWithWhereUniqueWithoutPatientInput = {
    where: HospitalisationWhereUniqueInput
    update: XOR<HospitalisationUpdateWithoutPatientInput, HospitalisationUncheckedUpdateWithoutPatientInput>
    create: XOR<HospitalisationCreateWithoutPatientInput, HospitalisationUncheckedCreateWithoutPatientInput>
  }

  export type HospitalisationUpdateWithWhereUniqueWithoutPatientInput = {
    where: HospitalisationWhereUniqueInput
    data: XOR<HospitalisationUpdateWithoutPatientInput, HospitalisationUncheckedUpdateWithoutPatientInput>
  }

  export type HospitalisationUpdateManyWithWhereWithoutPatientInput = {
    where: HospitalisationScalarWhereInput
    data: XOR<HospitalisationUpdateManyMutationInput, HospitalisationUncheckedUpdateManyWithoutPatientInput>
  }

  export type HospitalisationScalarWhereInput = {
    AND?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
    OR?: HospitalisationScalarWhereInput[]
    NOT?: HospitalisationScalarWhereInput | HospitalisationScalarWhereInput[]
    id?: StringFilter<"Hospitalisation"> | string
    patientId?: StringFilter<"Hospitalisation"> | string
    litId?: StringFilter<"Hospitalisation"> | string
    dateEntree?: DateTimeFilter<"Hospitalisation"> | Date | string
    dateSortie?: DateTimeNullableFilter<"Hospitalisation"> | Date | string | null
    motif?: StringFilter<"Hospitalisation"> | string
    diagnosticEntree?: StringNullableFilter<"Hospitalisation"> | string | null
    diagnosticSortie?: StringNullableFilter<"Hospitalisation"> | string | null
    statut?: StringFilter<"Hospitalisation"> | string
    createdAt?: DateTimeFilter<"Hospitalisation"> | Date | string
    updatedAt?: DateTimeFilter<"Hospitalisation"> | Date | string
  }

  export type InterventionUpsertWithWhereUniqueWithoutPatientInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutPatientInput, InterventionUncheckedUpdateWithoutPatientInput>
    create: XOR<InterventionCreateWithoutPatientInput, InterventionUncheckedCreateWithoutPatientInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutPatientInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutPatientInput, InterventionUncheckedUpdateWithoutPatientInput>
  }

  export type InterventionUpdateManyWithWhereWithoutPatientInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutPatientInput>
  }

  export type DossierMaterniteUpsertWithWhereUniqueWithoutPatientInput = {
    where: DossierMaterniteWhereUniqueInput
    update: XOR<DossierMaterniteUpdateWithoutPatientInput, DossierMaterniteUncheckedUpdateWithoutPatientInput>
    create: XOR<DossierMaterniteCreateWithoutPatientInput, DossierMaterniteUncheckedCreateWithoutPatientInput>
  }

  export type DossierMaterniteUpdateWithWhereUniqueWithoutPatientInput = {
    where: DossierMaterniteWhereUniqueInput
    data: XOR<DossierMaterniteUpdateWithoutPatientInput, DossierMaterniteUncheckedUpdateWithoutPatientInput>
  }

  export type DossierMaterniteUpdateManyWithWhereWithoutPatientInput = {
    where: DossierMaterniteScalarWhereInput
    data: XOR<DossierMaterniteUpdateManyMutationInput, DossierMaterniteUncheckedUpdateManyWithoutPatientInput>
  }

  export type DossierMaterniteScalarWhereInput = {
    AND?: DossierMaterniteScalarWhereInput | DossierMaterniteScalarWhereInput[]
    OR?: DossierMaterniteScalarWhereInput[]
    NOT?: DossierMaterniteScalarWhereInput | DossierMaterniteScalarWhereInput[]
    id?: StringFilter<"DossierMaternite"> | string
    patientId?: StringFilter<"DossierMaternite"> | string
    dateDebutGrossesse?: DateTimeFilter<"DossierMaternite"> | Date | string
    parite?: IntFilter<"DossierMaternite"> | number
    gestite?: IntFilter<"DossierMaternite"> | number
    groupageRhesus?: StringFilter<"DossierMaternite"> | string
    examensPrenataux?: JsonNullableFilter<"DossierMaternite">
    accouchement?: JsonNullableFilter<"DossierMaternite">
    createdAt?: DateTimeFilter<"DossierMaternite"> | Date | string
  }

  export type DocumentGEDUpsertWithWhereUniqueWithoutPatientInput = {
    where: DocumentGEDWhereUniqueInput
    update: XOR<DocumentGEDUpdateWithoutPatientInput, DocumentGEDUncheckedUpdateWithoutPatientInput>
    create: XOR<DocumentGEDCreateWithoutPatientInput, DocumentGEDUncheckedCreateWithoutPatientInput>
  }

  export type DocumentGEDUpdateWithWhereUniqueWithoutPatientInput = {
    where: DocumentGEDWhereUniqueInput
    data: XOR<DocumentGEDUpdateWithoutPatientInput, DocumentGEDUncheckedUpdateWithoutPatientInput>
  }

  export type DocumentGEDUpdateManyWithWhereWithoutPatientInput = {
    where: DocumentGEDScalarWhereInput
    data: XOR<DocumentGEDUpdateManyMutationInput, DocumentGEDUncheckedUpdateManyWithoutPatientInput>
  }

  export type DocumentGEDScalarWhereInput = {
    AND?: DocumentGEDScalarWhereInput | DocumentGEDScalarWhereInput[]
    OR?: DocumentGEDScalarWhereInput[]
    NOT?: DocumentGEDScalarWhereInput | DocumentGEDScalarWhereInput[]
    id?: StringFilter<"DocumentGED"> | string
    patientId?: StringNullableFilter<"DocumentGED"> | string | null
    titre?: StringFilter<"DocumentGED"> | string
    type?: StringFilter<"DocumentGED"> | string
    url?: StringFilter<"DocumentGED"> | string
    module?: StringFilter<"DocumentGED"> | string
    metadata?: JsonNullableFilter<"DocumentGED">
    createdAt?: DateTimeFilter<"DocumentGED"> | Date | string
  }

  export type PatientCreateWithoutAntecedentsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAntecedentsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAntecedentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAntecedentsInput, PatientUncheckedCreateWithoutAntecedentsInput>
  }

  export type PatientUpsertWithoutAntecedentsInput = {
    update: XOR<PatientUpdateWithoutAntecedentsInput, PatientUncheckedUpdateWithoutAntecedentsInput>
    create: XOR<PatientCreateWithoutAntecedentsInput, PatientUncheckedCreateWithoutAntecedentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAntecedentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAntecedentsInput, PatientUncheckedUpdateWithoutAntecedentsInput>
  }

  export type PatientUpdateWithoutAntecedentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAntecedentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutAllergiesInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAllergiesInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAllergiesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
  }

  export type PatientUpsertWithoutAllergiesInput = {
    update: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
    create: XOR<PatientCreateWithoutAllergiesInput, PatientUncheckedCreateWithoutAllergiesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAllergiesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAllergiesInput, PatientUncheckedUpdateWithoutAllergiesInput>
  }

  export type PatientUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAllergiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutVaccinationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutVaccinationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutVaccinationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
  }

  export type PatientUpsertWithoutVaccinationsInput = {
    update: XOR<PatientUpdateWithoutVaccinationsInput, PatientUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<PatientCreateWithoutVaccinationsInput, PatientUncheckedCreateWithoutVaccinationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutVaccinationsInput, PatientUncheckedUpdateWithoutVaccinationsInput>
  }

  export type PatientUpdateWithoutVaccinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutVaccinationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutRendezvousInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutRendezvousInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutRendezvousInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutRendezvousInput, PatientUncheckedCreateWithoutRendezvousInput>
  }

  export type UserCreateWithoutRendezvousInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRendezvousInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRendezvousInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRendezvousInput, UserUncheckedCreateWithoutRendezvousInput>
  }

  export type PatientUpsertWithoutRendezvousInput = {
    update: XOR<PatientUpdateWithoutRendezvousInput, PatientUncheckedUpdateWithoutRendezvousInput>
    create: XOR<PatientCreateWithoutRendezvousInput, PatientUncheckedCreateWithoutRendezvousInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutRendezvousInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutRendezvousInput, PatientUncheckedUpdateWithoutRendezvousInput>
  }

  export type PatientUpdateWithoutRendezvousInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutRendezvousInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutRendezvousInput = {
    update: XOR<UserUpdateWithoutRendezvousInput, UserUncheckedUpdateWithoutRendezvousInput>
    create: XOR<UserCreateWithoutRendezvousInput, UserUncheckedCreateWithoutRendezvousInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRendezvousInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRendezvousInput, UserUncheckedUpdateWithoutRendezvousInput>
  }

  export type UserUpdateWithoutRendezvousInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRendezvousInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PatientCreateWithoutConsultationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutConsultationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutConsultationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
  }

  export type UserCreateWithoutConsultationsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsultationsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsultationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
  }

  export type PrescriptionCreateWithoutConsultationInput = {
    id?: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
  }

  export type PrescriptionUncheckedCreateWithoutConsultationInput = {
    id?: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
  }

  export type PrescriptionCreateOrConnectWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput>
  }

  export type PrescriptionCreateManyConsultationInputEnvelope = {
    data: PrescriptionCreateManyConsultationInput | PrescriptionCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type ActeRealiseCreateWithoutConsultationInput = {
    id?: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    acte: NomenclatureActeCreateNestedOneWithoutActesInput
    resultat?: ResultatExamenCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseUncheckedCreateWithoutConsultationInput = {
    id?: string
    acteId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    resultat?: ResultatExamenUncheckedCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseCreateOrConnectWithoutConsultationInput = {
    where: ActeRealiseWhereUniqueInput
    create: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput>
  }

  export type ActeRealiseCreateManyConsultationInputEnvelope = {
    data: ActeRealiseCreateManyConsultationInput | ActeRealiseCreateManyConsultationInput[]
    skipDuplicates?: boolean
  }

  export type FactureCreateWithoutConsultationsInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFacturesInput
    lignes?: LigneFactureCreateNestedManyWithoutFactureInput
    paiements?: PaiementCreateNestedManyWithoutFactureInput
  }

  export type FactureUncheckedCreateWithoutConsultationsInput = {
    id?: string
    numeroFacture: string
    patientId: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneFactureUncheckedCreateNestedManyWithoutFactureInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureCreateOrConnectWithoutConsultationsInput = {
    where: FactureWhereUniqueInput
    create: XOR<FactureCreateWithoutConsultationsInput, FactureUncheckedCreateWithoutConsultationsInput>
  }

  export type PatientUpsertWithoutConsultationsInput = {
    update: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
    create: XOR<PatientCreateWithoutConsultationsInput, PatientUncheckedCreateWithoutConsultationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutConsultationsInput, PatientUncheckedUpdateWithoutConsultationsInput>
  }

  export type PatientUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutConsultationsInput = {
    update: XOR<UserUpdateWithoutConsultationsInput, UserUncheckedUpdateWithoutConsultationsInput>
    create: XOR<UserCreateWithoutConsultationsInput, UserUncheckedCreateWithoutConsultationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsultationsInput, UserUncheckedUpdateWithoutConsultationsInput>
  }

  export type UserUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutConsultationInput, PrescriptionUncheckedUpdateWithoutConsultationInput>
    create: XOR<PrescriptionCreateWithoutConsultationInput, PrescriptionUncheckedCreateWithoutConsultationInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutConsultationInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutConsultationInput, PrescriptionUncheckedUpdateWithoutConsultationInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutConsultationInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutConsultationInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    consultationId?: StringFilter<"Prescription"> | string
    medicament?: StringFilter<"Prescription"> | string
    dosage?: StringFilter<"Prescription"> | string
    forme?: StringFilter<"Prescription"> | string
    posologie?: StringFilter<"Prescription"> | string
    duree?: StringFilter<"Prescription"> | string
    quantite?: IntFilter<"Prescription"> | number
    instructions?: StringNullableFilter<"Prescription"> | string | null
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
  }

  export type ActeRealiseUpsertWithWhereUniqueWithoutConsultationInput = {
    where: ActeRealiseWhereUniqueInput
    update: XOR<ActeRealiseUpdateWithoutConsultationInput, ActeRealiseUncheckedUpdateWithoutConsultationInput>
    create: XOR<ActeRealiseCreateWithoutConsultationInput, ActeRealiseUncheckedCreateWithoutConsultationInput>
  }

  export type ActeRealiseUpdateWithWhereUniqueWithoutConsultationInput = {
    where: ActeRealiseWhereUniqueInput
    data: XOR<ActeRealiseUpdateWithoutConsultationInput, ActeRealiseUncheckedUpdateWithoutConsultationInput>
  }

  export type ActeRealiseUpdateManyWithWhereWithoutConsultationInput = {
    where: ActeRealiseScalarWhereInput
    data: XOR<ActeRealiseUpdateManyMutationInput, ActeRealiseUncheckedUpdateManyWithoutConsultationInput>
  }

  export type ActeRealiseScalarWhereInput = {
    AND?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
    OR?: ActeRealiseScalarWhereInput[]
    NOT?: ActeRealiseScalarWhereInput | ActeRealiseScalarWhereInput[]
    id?: StringFilter<"ActeRealise"> | string
    consultationId?: StringFilter<"ActeRealise"> | string
    acteId?: StringFilter<"ActeRealise"> | string
    quantite?: IntFilter<"ActeRealise"> | number
    tarif?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"ActeRealise"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"ActeRealise"> | string | null
    createdAt?: DateTimeFilter<"ActeRealise"> | Date | string
  }

  export type FactureUpsertWithoutConsultationsInput = {
    update: XOR<FactureUpdateWithoutConsultationsInput, FactureUncheckedUpdateWithoutConsultationsInput>
    create: XOR<FactureCreateWithoutConsultationsInput, FactureUncheckedCreateWithoutConsultationsInput>
    where?: FactureWhereInput
  }

  export type FactureUpdateToOneWithWhereWithoutConsultationsInput = {
    where?: FactureWhereInput
    data: XOR<FactureUpdateWithoutConsultationsInput, FactureUncheckedUpdateWithoutConsultationsInput>
  }

  export type FactureUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFacturesNestedInput
    lignes?: LigneFactureUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateWithoutConsultationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneFactureUncheckedUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type ConsultationCreateWithoutPrescriptionsInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    medecin: UserCreateNestedOneWithoutConsultationsInput
    actesRealises?: ActeRealiseCreateNestedManyWithoutConsultationInput
    facture?: FactureCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actesRealises?: ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutPrescriptionsInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
  }

  export type ConsultationUpsertWithoutPrescriptionsInput = {
    update: XOR<ConsultationUpdateWithoutPrescriptionsInput, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<ConsultationCreateWithoutPrescriptionsInput, ConsultationUncheckedCreateWithoutPrescriptionsInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutPrescriptionsInput, ConsultationUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type ConsultationUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    medecin?: UserUpdateOneRequiredWithoutConsultationsNestedInput
    actesRealises?: ActeRealiseUpdateManyWithoutConsultationNestedInput
    facture?: FactureUpdateOneWithoutConsultationsNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actesRealises?: ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ActeRealiseCreateWithoutActeInput = {
    id?: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    consultation: ConsultationCreateNestedOneWithoutActesRealisesInput
    resultat?: ResultatExamenCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseUncheckedCreateWithoutActeInput = {
    id?: string
    consultationId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    resultat?: ResultatExamenUncheckedCreateNestedOneWithoutActeRealiseInput
  }

  export type ActeRealiseCreateOrConnectWithoutActeInput = {
    where: ActeRealiseWhereUniqueInput
    create: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput>
  }

  export type ActeRealiseCreateManyActeInputEnvelope = {
    data: ActeRealiseCreateManyActeInput | ActeRealiseCreateManyActeInput[]
    skipDuplicates?: boolean
  }

  export type ActeRealiseUpsertWithWhereUniqueWithoutActeInput = {
    where: ActeRealiseWhereUniqueInput
    update: XOR<ActeRealiseUpdateWithoutActeInput, ActeRealiseUncheckedUpdateWithoutActeInput>
    create: XOR<ActeRealiseCreateWithoutActeInput, ActeRealiseUncheckedCreateWithoutActeInput>
  }

  export type ActeRealiseUpdateWithWhereUniqueWithoutActeInput = {
    where: ActeRealiseWhereUniqueInput
    data: XOR<ActeRealiseUpdateWithoutActeInput, ActeRealiseUncheckedUpdateWithoutActeInput>
  }

  export type ActeRealiseUpdateManyWithWhereWithoutActeInput = {
    where: ActeRealiseScalarWhereInput
    data: XOR<ActeRealiseUpdateManyMutationInput, ActeRealiseUncheckedUpdateManyWithoutActeInput>
  }

  export type ConsultationCreateWithoutActesRealisesInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    medecin: UserCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
    facture?: FactureCreateNestedOneWithoutConsultationsInput
  }

  export type ConsultationUncheckedCreateWithoutActesRealisesInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutActesRealisesInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutActesRealisesInput, ConsultationUncheckedCreateWithoutActesRealisesInput>
  }

  export type NomenclatureActeCreateWithoutActesInput = {
    id?: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal | DecimalJsLike | number | string
    duree?: number | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type NomenclatureActeUncheckedCreateWithoutActesInput = {
    id?: string
    code: string
    libelle: string
    specialite: string
    tarif: Decimal | DecimalJsLike | number | string
    duree?: number | null
    actif?: boolean
    createdAt?: Date | string
  }

  export type NomenclatureActeCreateOrConnectWithoutActesInput = {
    where: NomenclatureActeWhereUniqueInput
    create: XOR<NomenclatureActeCreateWithoutActesInput, NomenclatureActeUncheckedCreateWithoutActesInput>
  }

  export type ResultatExamenCreateWithoutActeRealiseInput = {
    id?: string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: string | null
    compteRendu?: string | null
    images?: ResultatExamenCreateimagesInput | string[]
    dateExamen?: Date | string
    validePar?: string | null
    dateValidation?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatExamenUncheckedCreateWithoutActeRealiseInput = {
    id?: string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: string | null
    compteRendu?: string | null
    images?: ResultatExamenCreateimagesInput | string[]
    dateExamen?: Date | string
    validePar?: string | null
    dateValidation?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatExamenCreateOrConnectWithoutActeRealiseInput = {
    where: ResultatExamenWhereUniqueInput
    create: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
  }

  export type ConsultationUpsertWithoutActesRealisesInput = {
    update: XOR<ConsultationUpdateWithoutActesRealisesInput, ConsultationUncheckedUpdateWithoutActesRealisesInput>
    create: XOR<ConsultationCreateWithoutActesRealisesInput, ConsultationUncheckedCreateWithoutActesRealisesInput>
    where?: ConsultationWhereInput
  }

  export type ConsultationUpdateToOneWithWhereWithoutActesRealisesInput = {
    where?: ConsultationWhereInput
    data: XOR<ConsultationUpdateWithoutActesRealisesInput, ConsultationUncheckedUpdateWithoutActesRealisesInput>
  }

  export type ConsultationUpdateWithoutActesRealisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    medecin?: UserUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
    facture?: FactureUpdateOneWithoutConsultationsNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutActesRealisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type NomenclatureActeUpsertWithoutActesInput = {
    update: XOR<NomenclatureActeUpdateWithoutActesInput, NomenclatureActeUncheckedUpdateWithoutActesInput>
    create: XOR<NomenclatureActeCreateWithoutActesInput, NomenclatureActeUncheckedCreateWithoutActesInput>
    where?: NomenclatureActeWhereInput
  }

  export type NomenclatureActeUpdateToOneWithWhereWithoutActesInput = {
    where?: NomenclatureActeWhereInput
    data: XOR<NomenclatureActeUpdateWithoutActesInput, NomenclatureActeUncheckedUpdateWithoutActesInput>
  }

  export type NomenclatureActeUpdateWithoutActesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NomenclatureActeUncheckedUpdateWithoutActesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    specialite?: StringFieldUpdateOperationsInput | string
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatExamenUpsertWithoutActeRealiseInput = {
    update: XOR<ResultatExamenUpdateWithoutActeRealiseInput, ResultatExamenUncheckedUpdateWithoutActeRealiseInput>
    create: XOR<ResultatExamenCreateWithoutActeRealiseInput, ResultatExamenUncheckedCreateWithoutActeRealiseInput>
    where?: ResultatExamenWhereInput
  }

  export type ResultatExamenUpdateToOneWithWhereWithoutActeRealiseInput = {
    where?: ResultatExamenWhereInput
    data: XOR<ResultatExamenUpdateWithoutActeRealiseInput, ResultatExamenUncheckedUpdateWithoutActeRealiseInput>
  }

  export type ResultatExamenUpdateWithoutActeRealiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatExamenUncheckedUpdateWithoutActeRealiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    valeurs?: NullableJsonNullValueInput | InputJsonValue
    conclusion?: NullableStringFieldUpdateOperationsInput | string | null
    compteRendu?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ResultatExamenUpdateimagesInput | string[]
    dateExamen?: DateTimeFieldUpdateOperationsInput | Date | string
    validePar?: NullableStringFieldUpdateOperationsInput | string | null
    dateValidation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActeRealiseCreateWithoutResultatInput = {
    id?: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
    consultation: ConsultationCreateNestedOneWithoutActesRealisesInput
    acte: NomenclatureActeCreateNestedOneWithoutActesInput
  }

  export type ActeRealiseUncheckedCreateWithoutResultatInput = {
    id?: string
    consultationId: string
    acteId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ActeRealiseCreateOrConnectWithoutResultatInput = {
    where: ActeRealiseWhereUniqueInput
    create: XOR<ActeRealiseCreateWithoutResultatInput, ActeRealiseUncheckedCreateWithoutResultatInput>
  }

  export type ActeRealiseUpsertWithoutResultatInput = {
    update: XOR<ActeRealiseUpdateWithoutResultatInput, ActeRealiseUncheckedUpdateWithoutResultatInput>
    create: XOR<ActeRealiseCreateWithoutResultatInput, ActeRealiseUncheckedCreateWithoutResultatInput>
    where?: ActeRealiseWhereInput
  }

  export type ActeRealiseUpdateToOneWithWhereWithoutResultatInput = {
    where?: ActeRealiseWhereInput
    data: XOR<ActeRealiseUpdateWithoutResultatInput, ActeRealiseUncheckedUpdateWithoutResultatInput>
  }

  export type ActeRealiseUpdateWithoutResultatInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneRequiredWithoutActesRealisesNestedInput
    acte?: NomenclatureActeUpdateOneRequiredWithoutActesNestedInput
  }

  export type ActeRealiseUncheckedUpdateWithoutResultatInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    acteId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateWithoutMedicamentInput = {
    id?: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockUncheckedCreateWithoutMedicamentInput = {
    id?: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockCreateOrConnectWithoutMedicamentInput = {
    where: StockWhereUniqueInput
    create: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput>
  }

  export type StockCreateManyMedicamentInputEnvelope = {
    data: StockCreateManyMedicamentInput | StockCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type MouvementStockCreateWithoutMedicamentInput = {
    id?: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementStockUncheckedCreateWithoutMedicamentInput = {
    id?: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementStockCreateOrConnectWithoutMedicamentInput = {
    where: MouvementStockWhereUniqueInput
    create: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput>
  }

  export type MouvementStockCreateManyMedicamentInputEnvelope = {
    data: MouvementStockCreateManyMedicamentInput | MouvementStockCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type DispensationCreateWithoutMedicamentInput = {
    id?: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutDispensationsInput
  }

  export type DispensationUncheckedCreateWithoutMedicamentInput = {
    id?: string
    patientId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type DispensationCreateOrConnectWithoutMedicamentInput = {
    where: DispensationWhereUniqueInput
    create: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput>
  }

  export type DispensationCreateManyMedicamentInputEnvelope = {
    data: DispensationCreateManyMedicamentInput | DispensationCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type LigneCommandePharmacieCreateWithoutMedicamentInput = {
    id?: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    commande: CommandePharmacieCreateNestedOneWithoutLignesInput
  }

  export type LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput = {
    id?: string
    commandeId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieCreateOrConnectWithoutMedicamentInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    create: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput>
  }

  export type LigneCommandePharmacieCreateManyMedicamentInputEnvelope = {
    data: LigneCommandePharmacieCreateManyMedicamentInput | LigneCommandePharmacieCreateManyMedicamentInput[]
    skipDuplicates?: boolean
  }

  export type StockUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: StockWhereUniqueInput
    update: XOR<StockUpdateWithoutMedicamentInput, StockUncheckedUpdateWithoutMedicamentInput>
    create: XOR<StockCreateWithoutMedicamentInput, StockUncheckedCreateWithoutMedicamentInput>
  }

  export type StockUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: StockWhereUniqueInput
    data: XOR<StockUpdateWithoutMedicamentInput, StockUncheckedUpdateWithoutMedicamentInput>
  }

  export type StockUpdateManyWithWhereWithoutMedicamentInput = {
    where: StockScalarWhereInput
    data: XOR<StockUpdateManyMutationInput, StockUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type StockScalarWhereInput = {
    AND?: StockScalarWhereInput | StockScalarWhereInput[]
    OR?: StockScalarWhereInput[]
    NOT?: StockScalarWhereInput | StockScalarWhereInput[]
    id?: StringFilter<"Stock"> | string
    medicamentId?: StringFilter<"Stock"> | string
    lot?: StringFilter<"Stock"> | string
    datePeremption?: DateTimeFilter<"Stock"> | Date | string
    quantite?: IntFilter<"Stock"> | number
    emplacement?: StringNullableFilter<"Stock"> | string | null
    createdAt?: DateTimeFilter<"Stock"> | Date | string
    updatedAt?: DateTimeFilter<"Stock"> | Date | string
  }

  export type MouvementStockUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: MouvementStockWhereUniqueInput
    update: XOR<MouvementStockUpdateWithoutMedicamentInput, MouvementStockUncheckedUpdateWithoutMedicamentInput>
    create: XOR<MouvementStockCreateWithoutMedicamentInput, MouvementStockUncheckedCreateWithoutMedicamentInput>
  }

  export type MouvementStockUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: MouvementStockWhereUniqueInput
    data: XOR<MouvementStockUpdateWithoutMedicamentInput, MouvementStockUncheckedUpdateWithoutMedicamentInput>
  }

  export type MouvementStockUpdateManyWithWhereWithoutMedicamentInput = {
    where: MouvementStockScalarWhereInput
    data: XOR<MouvementStockUpdateManyMutationInput, MouvementStockUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type MouvementStockScalarWhereInput = {
    AND?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
    OR?: MouvementStockScalarWhereInput[]
    NOT?: MouvementStockScalarWhereInput | MouvementStockScalarWhereInput[]
    id?: StringFilter<"MouvementStock"> | string
    medicamentId?: StringFilter<"MouvementStock"> | string
    type?: StringFilter<"MouvementStock"> | string
    quantite?: IntFilter<"MouvementStock"> | number
    motif?: StringFilter<"MouvementStock"> | string
    reference?: StringNullableFilter<"MouvementStock"> | string | null
    utilisateur?: StringFilter<"MouvementStock"> | string
    createdAt?: DateTimeFilter<"MouvementStock"> | Date | string
  }

  export type DispensationUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: DispensationWhereUniqueInput
    update: XOR<DispensationUpdateWithoutMedicamentInput, DispensationUncheckedUpdateWithoutMedicamentInput>
    create: XOR<DispensationCreateWithoutMedicamentInput, DispensationUncheckedCreateWithoutMedicamentInput>
  }

  export type DispensationUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: DispensationWhereUniqueInput
    data: XOR<DispensationUpdateWithoutMedicamentInput, DispensationUncheckedUpdateWithoutMedicamentInput>
  }

  export type DispensationUpdateManyWithWhereWithoutMedicamentInput = {
    where: DispensationScalarWhereInput
    data: XOR<DispensationUpdateManyMutationInput, DispensationUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type LigneCommandePharmacieUpsertWithWhereUniqueWithoutMedicamentInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    update: XOR<LigneCommandePharmacieUpdateWithoutMedicamentInput, LigneCommandePharmacieUncheckedUpdateWithoutMedicamentInput>
    create: XOR<LigneCommandePharmacieCreateWithoutMedicamentInput, LigneCommandePharmacieUncheckedCreateWithoutMedicamentInput>
  }

  export type LigneCommandePharmacieUpdateWithWhereUniqueWithoutMedicamentInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    data: XOR<LigneCommandePharmacieUpdateWithoutMedicamentInput, LigneCommandePharmacieUncheckedUpdateWithoutMedicamentInput>
  }

  export type LigneCommandePharmacieUpdateManyWithWhereWithoutMedicamentInput = {
    where: LigneCommandePharmacieScalarWhereInput
    data: XOR<LigneCommandePharmacieUpdateManyMutationInput, LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentInput>
  }

  export type LigneCommandePharmacieScalarWhereInput = {
    AND?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
    OR?: LigneCommandePharmacieScalarWhereInput[]
    NOT?: LigneCommandePharmacieScalarWhereInput | LigneCommandePharmacieScalarWhereInput[]
    id?: StringFilter<"LigneCommandePharmacie"> | string
    commandeId?: StringFilter<"LigneCommandePharmacie"> | string
    medicamentId?: StringFilter<"LigneCommandePharmacie"> | string
    quantiteCommandee?: IntFilter<"LigneCommandePharmacie"> | number
    quantiteRecue?: IntFilter<"LigneCommandePharmacie"> | number
    prixUnitaire?: DecimalFilter<"LigneCommandePharmacie"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneCommandePharmacie"> | Date | string
  }

  export type CommandePharmacieCreateWithoutFournisseurInput = {
    id?: string
    numeroCommande: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandePharmacieCreateNestedManyWithoutCommandeInput
  }

  export type CommandePharmacieUncheckedCreateWithoutFournisseurInput = {
    id?: string
    numeroCommande: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandePharmacieCreateOrConnectWithoutFournisseurInput = {
    where: CommandePharmacieWhereUniqueInput
    create: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandePharmacieCreateManyFournisseurInputEnvelope = {
    data: CommandePharmacieCreateManyFournisseurInput | CommandePharmacieCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type CommandePharmacieUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: CommandePharmacieWhereUniqueInput
    update: XOR<CommandePharmacieUpdateWithoutFournisseurInput, CommandePharmacieUncheckedUpdateWithoutFournisseurInput>
    create: XOR<CommandePharmacieCreateWithoutFournisseurInput, CommandePharmacieUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandePharmacieUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: CommandePharmacieWhereUniqueInput
    data: XOR<CommandePharmacieUpdateWithoutFournisseurInput, CommandePharmacieUncheckedUpdateWithoutFournisseurInput>
  }

  export type CommandePharmacieUpdateManyWithWhereWithoutFournisseurInput = {
    where: CommandePharmacieScalarWhereInput
    data: XOR<CommandePharmacieUpdateManyMutationInput, CommandePharmacieUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type CommandePharmacieScalarWhereInput = {
    AND?: CommandePharmacieScalarWhereInput | CommandePharmacieScalarWhereInput[]
    OR?: CommandePharmacieScalarWhereInput[]
    NOT?: CommandePharmacieScalarWhereInput | CommandePharmacieScalarWhereInput[]
    id?: StringFilter<"CommandePharmacie"> | string
    numeroCommande?: StringFilter<"CommandePharmacie"> | string
    fournisseurId?: StringFilter<"CommandePharmacie"> | string
    dateCommande?: DateTimeFilter<"CommandePharmacie"> | Date | string
    dateLivraison?: DateTimeNullableFilter<"CommandePharmacie"> | Date | string | null
    montantTotal?: DecimalFilter<"CommandePharmacie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"CommandePharmacie"> | string
    createdAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
    updatedAt?: DateTimeFilter<"CommandePharmacie"> | Date | string
  }

  export type FournisseurCreateWithoutCommandesInput = {
    id?: string
    nom: string
    code?: string | null
    contact?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    ninea?: string | null
    rccm?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FournisseurUncheckedCreateWithoutCommandesInput = {
    id?: string
    nom: string
    code?: string | null
    contact?: string | null
    email?: string | null
    telephone?: string | null
    adresse?: string | null
    ninea?: string | null
    rccm?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FournisseurCreateOrConnectWithoutCommandesInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
  }

  export type LigneCommandePharmacieCreateWithoutCommandeInput = {
    id?: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    medicament: MedicamentCreateNestedOneWithoutCommandesInput
  }

  export type LigneCommandePharmacieUncheckedCreateWithoutCommandeInput = {
    id?: string
    medicamentId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieCreateOrConnectWithoutCommandeInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    create: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput>
  }

  export type LigneCommandePharmacieCreateManyCommandeInputEnvelope = {
    data: LigneCommandePharmacieCreateManyCommandeInput | LigneCommandePharmacieCreateManyCommandeInput[]
    skipDuplicates?: boolean
  }

  export type FournisseurUpsertWithoutCommandesInput = {
    update: XOR<FournisseurUpdateWithoutCommandesInput, FournisseurUncheckedUpdateWithoutCommandesInput>
    create: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutCommandesInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutCommandesInput, FournisseurUncheckedUpdateWithoutCommandesInput>
  }

  export type FournisseurUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurUncheckedUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ninea?: NullableStringFieldUpdateOperationsInput | string | null
    rccm?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieUpsertWithWhereUniqueWithoutCommandeInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    update: XOR<LigneCommandePharmacieUpdateWithoutCommandeInput, LigneCommandePharmacieUncheckedUpdateWithoutCommandeInput>
    create: XOR<LigneCommandePharmacieCreateWithoutCommandeInput, LigneCommandePharmacieUncheckedCreateWithoutCommandeInput>
  }

  export type LigneCommandePharmacieUpdateWithWhereUniqueWithoutCommandeInput = {
    where: LigneCommandePharmacieWhereUniqueInput
    data: XOR<LigneCommandePharmacieUpdateWithoutCommandeInput, LigneCommandePharmacieUncheckedUpdateWithoutCommandeInput>
  }

  export type LigneCommandePharmacieUpdateManyWithWhereWithoutCommandeInput = {
    where: LigneCommandePharmacieScalarWhereInput
    data: XOR<LigneCommandePharmacieUpdateManyMutationInput, LigneCommandePharmacieUncheckedUpdateManyWithoutCommandeInput>
  }

  export type CommandePharmacieCreateWithoutLignesInput = {
    id?: string
    numeroCommande: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur: FournisseurCreateNestedOneWithoutCommandesInput
  }

  export type CommandePharmacieUncheckedCreateWithoutLignesInput = {
    id?: string
    numeroCommande: string
    fournisseurId: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandePharmacieCreateOrConnectWithoutLignesInput = {
    where: CommandePharmacieWhereUniqueInput
    create: XOR<CommandePharmacieCreateWithoutLignesInput, CommandePharmacieUncheckedCreateWithoutLignesInput>
  }

  export type MedicamentCreateWithoutCommandesInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutCommandesInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockUncheckedCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutCommandesInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutCommandesInput, MedicamentUncheckedCreateWithoutCommandesInput>
  }

  export type CommandePharmacieUpsertWithoutLignesInput = {
    update: XOR<CommandePharmacieUpdateWithoutLignesInput, CommandePharmacieUncheckedUpdateWithoutLignesInput>
    create: XOR<CommandePharmacieCreateWithoutLignesInput, CommandePharmacieUncheckedCreateWithoutLignesInput>
    where?: CommandePharmacieWhereInput
  }

  export type CommandePharmacieUpdateToOneWithWhereWithoutLignesInput = {
    where?: CommandePharmacieWhereInput
    data: XOR<CommandePharmacieUpdateWithoutLignesInput, CommandePharmacieUncheckedUpdateWithoutLignesInput>
  }

  export type CommandePharmacieUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneRequiredWithoutCommandesNestedInput
  }

  export type CommandePharmacieUncheckedUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    fournisseurId?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicamentUpsertWithoutCommandesInput = {
    update: XOR<MedicamentUpdateWithoutCommandesInput, MedicamentUncheckedUpdateWithoutCommandesInput>
    create: XOR<MedicamentCreateWithoutCommandesInput, MedicamentUncheckedCreateWithoutCommandesInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutCommandesInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutCommandesInput, MedicamentUncheckedUpdateWithoutCommandesInput>
  }

  export type MedicamentUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutCommandesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUncheckedUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUncheckedUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentCreateWithoutStocksInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutStocksInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutStocksInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutStocksInput, MedicamentUncheckedCreateWithoutStocksInput>
  }

  export type MedicamentUpsertWithoutStocksInput = {
    update: XOR<MedicamentUpdateWithoutStocksInput, MedicamentUncheckedUpdateWithoutStocksInput>
    create: XOR<MedicamentCreateWithoutStocksInput, MedicamentUncheckedCreateWithoutStocksInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutStocksInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutStocksInput, MedicamentUncheckedUpdateWithoutStocksInput>
  }

  export type MedicamentUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutStocksInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvements?: MouvementStockUncheckedUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentCreateWithoutMouvementsInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutMouvementsInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockUncheckedCreateNestedManyWithoutMedicamentInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutMouvementsInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutMouvementsInput, MedicamentUncheckedCreateWithoutMouvementsInput>
  }

  export type MedicamentUpsertWithoutMouvementsInput = {
    update: XOR<MedicamentUpdateWithoutMouvementsInput, MedicamentUncheckedUpdateWithoutMouvementsInput>
    create: XOR<MedicamentCreateWithoutMouvementsInput, MedicamentUncheckedCreateWithoutMouvementsInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutMouvementsInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutMouvementsInput, MedicamentUncheckedUpdateWithoutMouvementsInput>
  }

  export type MedicamentUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUncheckedUpdateManyWithoutMedicamentNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentCreateWithoutDispensationsInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentUncheckedCreateWithoutDispensationsInput = {
    id?: string
    codeANIS?: string | null
    dci: string
    nomCommercial: string
    forme: string
    dosage: string
    fabricant?: string | null
    prixAchat: Decimal | DecimalJsLike | number | string
    prixVente: Decimal | DecimalJsLike | number | string
    stockMinimum?: number
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stocks?: StockUncheckedCreateNestedManyWithoutMedicamentInput
    mouvements?: MouvementStockUncheckedCreateNestedManyWithoutMedicamentInput
    commandes?: LigneCommandePharmacieUncheckedCreateNestedManyWithoutMedicamentInput
  }

  export type MedicamentCreateOrConnectWithoutDispensationsInput = {
    where: MedicamentWhereUniqueInput
    create: XOR<MedicamentCreateWithoutDispensationsInput, MedicamentUncheckedCreateWithoutDispensationsInput>
  }

  export type PatientCreateWithoutDispensationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDispensationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDispensationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDispensationsInput, PatientUncheckedCreateWithoutDispensationsInput>
  }

  export type MedicamentUpsertWithoutDispensationsInput = {
    update: XOR<MedicamentUpdateWithoutDispensationsInput, MedicamentUncheckedUpdateWithoutDispensationsInput>
    create: XOR<MedicamentCreateWithoutDispensationsInput, MedicamentUncheckedCreateWithoutDispensationsInput>
    where?: MedicamentWhereInput
  }

  export type MedicamentUpdateToOneWithWhereWithoutDispensationsInput = {
    where?: MedicamentWhereInput
    data: XOR<MedicamentUpdateWithoutDispensationsInput, MedicamentUncheckedUpdateWithoutDispensationsInput>
  }

  export type MedicamentUpdateWithoutDispensationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUpdateManyWithoutMedicamentNestedInput
  }

  export type MedicamentUncheckedUpdateWithoutDispensationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    codeANIS?: NullableStringFieldUpdateOperationsInput | string | null
    dci?: StringFieldUpdateOperationsInput | string
    nomCommercial?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    fabricant?: NullableStringFieldUpdateOperationsInput | string | null
    prixAchat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prixVente?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    stockMinimum?: IntFieldUpdateOperationsInput | number
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stocks?: StockUncheckedUpdateManyWithoutMedicamentNestedInput
    mouvements?: MouvementStockUncheckedUpdateManyWithoutMedicamentNestedInput
    commandes?: LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentNestedInput
  }

  export type PatientUpsertWithoutDispensationsInput = {
    update: XOR<PatientUpdateWithoutDispensationsInput, PatientUncheckedUpdateWithoutDispensationsInput>
    create: XOR<PatientCreateWithoutDispensationsInput, PatientUncheckedCreateWithoutDispensationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDispensationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDispensationsInput, PatientUncheckedUpdateWithoutDispensationsInput>
  }

  export type PatientUpdateWithoutDispensationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDispensationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutFacturesInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutFacturesInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutFacturesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutFacturesInput, PatientUncheckedCreateWithoutFacturesInput>
  }

  export type LigneFactureCreateWithoutFactureInput = {
    id?: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneFactureUncheckedCreateWithoutFactureInput = {
    id?: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneFactureCreateOrConnectWithoutFactureInput = {
    where: LigneFactureWhereUniqueInput
    create: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput>
  }

  export type LigneFactureCreateManyFactureInputEnvelope = {
    data: LigneFactureCreateManyFactureInput | LigneFactureCreateManyFactureInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutFactureInput = {
    id?: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutFactureInput = {
    id?: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutFactureInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput>
  }

  export type PaiementCreateManyFactureInputEnvelope = {
    data: PaiementCreateManyFactureInput | PaiementCreateManyFactureInput[]
    skipDuplicates?: boolean
  }

  export type ConsultationCreateWithoutFactureInput = {
    id?: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutConsultationsInput
    medecin: UserCreateNestedOneWithoutConsultationsInput
    prescriptions?: PrescriptionCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationUncheckedCreateWithoutFactureInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutConsultationInput
    actesRealises?: ActeRealiseUncheckedCreateNestedManyWithoutConsultationInput
  }

  export type ConsultationCreateOrConnectWithoutFactureInput = {
    where: ConsultationWhereUniqueInput
    create: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput>
  }

  export type ConsultationCreateManyFactureInputEnvelope = {
    data: ConsultationCreateManyFactureInput | ConsultationCreateManyFactureInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutFacturesInput = {
    update: XOR<PatientUpdateWithoutFacturesInput, PatientUncheckedUpdateWithoutFacturesInput>
    create: XOR<PatientCreateWithoutFacturesInput, PatientUncheckedCreateWithoutFacturesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutFacturesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutFacturesInput, PatientUncheckedUpdateWithoutFacturesInput>
  }

  export type PatientUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutFacturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LigneFactureUpsertWithWhereUniqueWithoutFactureInput = {
    where: LigneFactureWhereUniqueInput
    update: XOR<LigneFactureUpdateWithoutFactureInput, LigneFactureUncheckedUpdateWithoutFactureInput>
    create: XOR<LigneFactureCreateWithoutFactureInput, LigneFactureUncheckedCreateWithoutFactureInput>
  }

  export type LigneFactureUpdateWithWhereUniqueWithoutFactureInput = {
    where: LigneFactureWhereUniqueInput
    data: XOR<LigneFactureUpdateWithoutFactureInput, LigneFactureUncheckedUpdateWithoutFactureInput>
  }

  export type LigneFactureUpdateManyWithWhereWithoutFactureInput = {
    where: LigneFactureScalarWhereInput
    data: XOR<LigneFactureUpdateManyMutationInput, LigneFactureUncheckedUpdateManyWithoutFactureInput>
  }

  export type LigneFactureScalarWhereInput = {
    AND?: LigneFactureScalarWhereInput | LigneFactureScalarWhereInput[]
    OR?: LigneFactureScalarWhereInput[]
    NOT?: LigneFactureScalarWhereInput | LigneFactureScalarWhereInput[]
    id?: StringFilter<"LigneFacture"> | string
    factureId?: StringFilter<"LigneFacture"> | string
    designation?: StringFilter<"LigneFacture"> | string
    quantite?: IntFilter<"LigneFacture"> | number
    prixUnitaire?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    montant?: DecimalFilter<"LigneFacture"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"LigneFacture"> | Date | string
  }

  export type PaiementUpsertWithWhereUniqueWithoutFactureInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutFactureInput, PaiementUncheckedUpdateWithoutFactureInput>
    create: XOR<PaiementCreateWithoutFactureInput, PaiementUncheckedCreateWithoutFactureInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutFactureInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutFactureInput, PaiementUncheckedUpdateWithoutFactureInput>
  }

  export type PaiementUpdateManyWithWhereWithoutFactureInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutFactureInput>
  }

  export type ConsultationUpsertWithWhereUniqueWithoutFactureInput = {
    where: ConsultationWhereUniqueInput
    update: XOR<ConsultationUpdateWithoutFactureInput, ConsultationUncheckedUpdateWithoutFactureInput>
    create: XOR<ConsultationCreateWithoutFactureInput, ConsultationUncheckedCreateWithoutFactureInput>
  }

  export type ConsultationUpdateWithWhereUniqueWithoutFactureInput = {
    where: ConsultationWhereUniqueInput
    data: XOR<ConsultationUpdateWithoutFactureInput, ConsultationUncheckedUpdateWithoutFactureInput>
  }

  export type ConsultationUpdateManyWithWhereWithoutFactureInput = {
    where: ConsultationScalarWhereInput
    data: XOR<ConsultationUpdateManyMutationInput, ConsultationUncheckedUpdateManyWithoutFactureInput>
  }

  export type FactureCreateWithoutLignesInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFacturesInput
    paiements?: PaiementCreateNestedManyWithoutFactureInput
    consultations?: ConsultationCreateNestedManyWithoutFactureInput
  }

  export type FactureUncheckedCreateWithoutLignesInput = {
    id?: string
    numeroFacture: string
    patientId: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutFactureInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureCreateOrConnectWithoutLignesInput = {
    where: FactureWhereUniqueInput
    create: XOR<FactureCreateWithoutLignesInput, FactureUncheckedCreateWithoutLignesInput>
  }

  export type FactureUpsertWithoutLignesInput = {
    update: XOR<FactureUpdateWithoutLignesInput, FactureUncheckedUpdateWithoutLignesInput>
    create: XOR<FactureCreateWithoutLignesInput, FactureUncheckedCreateWithoutLignesInput>
    where?: FactureWhereInput
  }

  export type FactureUpdateToOneWithWhereWithoutLignesInput = {
    where?: FactureWhereInput
    data: XOR<FactureUpdateWithoutLignesInput, FactureUncheckedUpdateWithoutLignesInput>
  }

  export type FactureUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFacturesNestedInput
    paiements?: PaiementUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureCreateWithoutPaiementsInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutFacturesInput
    lignes?: LigneFactureCreateNestedManyWithoutFactureInput
    consultations?: ConsultationCreateNestedManyWithoutFactureInput
  }

  export type FactureUncheckedCreateWithoutPaiementsInput = {
    id?: string
    numeroFacture: string
    patientId: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lignes?: LigneFactureUncheckedCreateNestedManyWithoutFactureInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutFactureInput
  }

  export type FactureCreateOrConnectWithoutPaiementsInput = {
    where: FactureWhereUniqueInput
    create: XOR<FactureCreateWithoutPaiementsInput, FactureUncheckedCreateWithoutPaiementsInput>
  }

  export type UserCreateWithoutPaiementsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaiementsInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaiementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaiementsInput, UserUncheckedCreateWithoutPaiementsInput>
  }

  export type FactureUpsertWithoutPaiementsInput = {
    update: XOR<FactureUpdateWithoutPaiementsInput, FactureUncheckedUpdateWithoutPaiementsInput>
    create: XOR<FactureCreateWithoutPaiementsInput, FactureUncheckedCreateWithoutPaiementsInput>
    where?: FactureWhereInput
  }

  export type FactureUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: FactureWhereInput
    data: XOR<FactureUpdateWithoutPaiementsInput, FactureUncheckedUpdateWithoutPaiementsInput>
  }

  export type FactureUpdateWithoutPaiementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutFacturesNestedInput
    lignes?: LigneFactureUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateWithoutPaiementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneFactureUncheckedUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type UserUpsertWithoutPaiementsInput = {
    update: XOR<UserUpdateWithoutPaiementsInput, UserUncheckedUpdateWithoutPaiementsInput>
    create: XOR<UserCreateWithoutPaiementsInput, UserUncheckedCreateWithoutPaiementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaiementsInput, UserUncheckedUpdateWithoutPaiementsInput>
  }

  export type UserUpdateWithoutPaiementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaiementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type HospitalisationCreateWithoutLitInput = {
    id?: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutHospitalisationsInput
    observations?: ObservationInfirmierCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationUncheckedCreateWithoutLitInput = {
    id?: string
    patientId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationInfirmierUncheckedCreateNestedManyWithoutHospitalisationInput
  }

  export type HospitalisationCreateOrConnectWithoutLitInput = {
    where: HospitalisationWhereUniqueInput
    create: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput>
  }

  export type HospitalisationCreateManyLitInputEnvelope = {
    data: HospitalisationCreateManyLitInput | HospitalisationCreateManyLitInput[]
    skipDuplicates?: boolean
  }

  export type HospitalisationUpsertWithWhereUniqueWithoutLitInput = {
    where: HospitalisationWhereUniqueInput
    update: XOR<HospitalisationUpdateWithoutLitInput, HospitalisationUncheckedUpdateWithoutLitInput>
    create: XOR<HospitalisationCreateWithoutLitInput, HospitalisationUncheckedCreateWithoutLitInput>
  }

  export type HospitalisationUpdateWithWhereUniqueWithoutLitInput = {
    where: HospitalisationWhereUniqueInput
    data: XOR<HospitalisationUpdateWithoutLitInput, HospitalisationUncheckedUpdateWithoutLitInput>
  }

  export type HospitalisationUpdateManyWithWhereWithoutLitInput = {
    where: HospitalisationScalarWhereInput
    data: XOR<HospitalisationUpdateManyMutationInput, HospitalisationUncheckedUpdateManyWithoutLitInput>
  }

  export type PatientCreateWithoutHospitalisationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutHospitalisationsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutHospitalisationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutHospitalisationsInput, PatientUncheckedCreateWithoutHospitalisationsInput>
  }

  export type LitCreateWithoutHospitalisationsInput = {
    id?: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal | DecimalJsLike | number | string
    occupe?: boolean
    createdAt?: Date | string
  }

  export type LitUncheckedCreateWithoutHospitalisationsInput = {
    id?: string
    numero: string
    chambre: string
    service: string
    categorie: string
    prixJournalier: Decimal | DecimalJsLike | number | string
    occupe?: boolean
    createdAt?: Date | string
  }

  export type LitCreateOrConnectWithoutHospitalisationsInput = {
    where: LitWhereUniqueInput
    create: XOR<LitCreateWithoutHospitalisationsInput, LitUncheckedCreateWithoutHospitalisationsInput>
  }

  export type ObservationInfirmierCreateWithoutHospitalisationInput = {
    id?: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
    infirmier: UserCreateNestedOneWithoutObservationsCreesInput
  }

  export type ObservationInfirmierUncheckedCreateWithoutHospitalisationInput = {
    id?: string
    infirmierId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type ObservationInfirmierCreateOrConnectWithoutHospitalisationInput = {
    where: ObservationInfirmierWhereUniqueInput
    create: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput>
  }

  export type ObservationInfirmierCreateManyHospitalisationInputEnvelope = {
    data: ObservationInfirmierCreateManyHospitalisationInput | ObservationInfirmierCreateManyHospitalisationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutHospitalisationsInput = {
    update: XOR<PatientUpdateWithoutHospitalisationsInput, PatientUncheckedUpdateWithoutHospitalisationsInput>
    create: XOR<PatientCreateWithoutHospitalisationsInput, PatientUncheckedCreateWithoutHospitalisationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutHospitalisationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutHospitalisationsInput, PatientUncheckedUpdateWithoutHospitalisationsInput>
  }

  export type PatientUpdateWithoutHospitalisationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutHospitalisationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type LitUpsertWithoutHospitalisationsInput = {
    update: XOR<LitUpdateWithoutHospitalisationsInput, LitUncheckedUpdateWithoutHospitalisationsInput>
    create: XOR<LitCreateWithoutHospitalisationsInput, LitUncheckedCreateWithoutHospitalisationsInput>
    where?: LitWhereInput
  }

  export type LitUpdateToOneWithWhereWithoutHospitalisationsInput = {
    where?: LitWhereInput
    data: XOR<LitUpdateWithoutHospitalisationsInput, LitUncheckedUpdateWithoutHospitalisationsInput>
  }

  export type LitUpdateWithoutHospitalisationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LitUncheckedUpdateWithoutHospitalisationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    chambre?: StringFieldUpdateOperationsInput | string
    service?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    prixJournalier?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    occupe?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierUpsertWithWhereUniqueWithoutHospitalisationInput = {
    where: ObservationInfirmierWhereUniqueInput
    update: XOR<ObservationInfirmierUpdateWithoutHospitalisationInput, ObservationInfirmierUncheckedUpdateWithoutHospitalisationInput>
    create: XOR<ObservationInfirmierCreateWithoutHospitalisationInput, ObservationInfirmierUncheckedCreateWithoutHospitalisationInput>
  }

  export type ObservationInfirmierUpdateWithWhereUniqueWithoutHospitalisationInput = {
    where: ObservationInfirmierWhereUniqueInput
    data: XOR<ObservationInfirmierUpdateWithoutHospitalisationInput, ObservationInfirmierUncheckedUpdateWithoutHospitalisationInput>
  }

  export type ObservationInfirmierUpdateManyWithWhereWithoutHospitalisationInput = {
    where: ObservationInfirmierScalarWhereInput
    data: XOR<ObservationInfirmierUpdateManyMutationInput, ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationInput>
  }

  export type HospitalisationCreateWithoutObservationsInput = {
    id?: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutHospitalisationsInput
    lit: LitCreateNestedOneWithoutHospitalisationsInput
  }

  export type HospitalisationUncheckedCreateWithoutObservationsInput = {
    id?: string
    patientId: string
    litId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalisationCreateOrConnectWithoutObservationsInput = {
    where: HospitalisationWhereUniqueInput
    create: XOR<HospitalisationCreateWithoutObservationsInput, HospitalisationUncheckedCreateWithoutObservationsInput>
  }

  export type UserCreateWithoutObservationsCreesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutObservationsCreesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutObservationsCreesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutObservationsCreesInput, UserUncheckedCreateWithoutObservationsCreesInput>
  }

  export type HospitalisationUpsertWithoutObservationsInput = {
    update: XOR<HospitalisationUpdateWithoutObservationsInput, HospitalisationUncheckedUpdateWithoutObservationsInput>
    create: XOR<HospitalisationCreateWithoutObservationsInput, HospitalisationUncheckedCreateWithoutObservationsInput>
    where?: HospitalisationWhereInput
  }

  export type HospitalisationUpdateToOneWithWhereWithoutObservationsInput = {
    where?: HospitalisationWhereInput
    data: XOR<HospitalisationUpdateWithoutObservationsInput, HospitalisationUncheckedUpdateWithoutObservationsInput>
  }

  export type HospitalisationUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutHospitalisationsNestedInput
    lit?: LitUpdateOneRequiredWithoutHospitalisationsNestedInput
  }

  export type HospitalisationUncheckedUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    litId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutObservationsCreesInput = {
    update: XOR<UserUpdateWithoutObservationsCreesInput, UserUncheckedUpdateWithoutObservationsCreesInput>
    create: XOR<UserCreateWithoutObservationsCreesInput, UserUncheckedCreateWithoutObservationsCreesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutObservationsCreesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutObservationsCreesInput, UserUncheckedUpdateWithoutObservationsCreesInput>
  }

  export type UserUpdateWithoutObservationsCreesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutObservationsCreesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PatientCreateWithoutInterventionsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInterventionsInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInterventionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInterventionsInput, PatientUncheckedCreateWithoutInterventionsInput>
  }

  export type UserCreateWithoutChirurgiesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChirurgiesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChirurgiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChirurgiesInput, UserUncheckedCreateWithoutChirurgiesInput>
  }

  export type UserCreateWithoutAnesthesiesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    employe?: EmployeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnesthesiesInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    employe?: EmployeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnesthesiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnesthesiesInput, UserUncheckedCreateWithoutAnesthesiesInput>
  }

  export type PatientUpsertWithoutInterventionsInput = {
    update: XOR<PatientUpdateWithoutInterventionsInput, PatientUncheckedUpdateWithoutInterventionsInput>
    create: XOR<PatientCreateWithoutInterventionsInput, PatientUncheckedCreateWithoutInterventionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInterventionsInput, PatientUncheckedUpdateWithoutInterventionsInput>
  }

  export type PatientUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutChirurgiesInput = {
    update: XOR<UserUpdateWithoutChirurgiesInput, UserUncheckedUpdateWithoutChirurgiesInput>
    create: XOR<UserCreateWithoutChirurgiesInput, UserUncheckedCreateWithoutChirurgiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChirurgiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChirurgiesInput, UserUncheckedUpdateWithoutChirurgiesInput>
  }

  export type UserUpdateWithoutChirurgiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChirurgiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUpsertWithoutAnesthesiesInput = {
    update: XOR<UserUpdateWithoutAnesthesiesInput, UserUncheckedUpdateWithoutAnesthesiesInput>
    create: XOR<UserCreateWithoutAnesthesiesInput, UserUncheckedCreateWithoutAnesthesiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnesthesiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnesthesiesInput, UserUncheckedUpdateWithoutAnesthesiesInput>
  }

  export type UserUpdateWithoutAnesthesiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnesthesiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type PatientCreateWithoutDossiersMaterniteInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDossiersMaterniteInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    documentsGED?: DocumentGEDUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDossiersMaterniteInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDossiersMaterniteInput, PatientUncheckedCreateWithoutDossiersMaterniteInput>
  }

  export type NouveauNeCreateWithoutDossierMaterniteInput = {
    id?: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
  }

  export type NouveauNeUncheckedCreateWithoutDossierMaterniteInput = {
    id?: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
  }

  export type NouveauNeCreateOrConnectWithoutDossierMaterniteInput = {
    where: NouveauNeWhereUniqueInput
    create: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput>
  }

  export type NouveauNeCreateManyDossierMaterniteInputEnvelope = {
    data: NouveauNeCreateManyDossierMaterniteInput | NouveauNeCreateManyDossierMaterniteInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutDossiersMaterniteInput = {
    update: XOR<PatientUpdateWithoutDossiersMaterniteInput, PatientUncheckedUpdateWithoutDossiersMaterniteInput>
    create: XOR<PatientCreateWithoutDossiersMaterniteInput, PatientUncheckedCreateWithoutDossiersMaterniteInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDossiersMaterniteInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDossiersMaterniteInput, PatientUncheckedUpdateWithoutDossiersMaterniteInput>
  }

  export type PatientUpdateWithoutDossiersMaterniteInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDossiersMaterniteInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    documentsGED?: DocumentGEDUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type NouveauNeUpsertWithWhereUniqueWithoutDossierMaterniteInput = {
    where: NouveauNeWhereUniqueInput
    update: XOR<NouveauNeUpdateWithoutDossierMaterniteInput, NouveauNeUncheckedUpdateWithoutDossierMaterniteInput>
    create: XOR<NouveauNeCreateWithoutDossierMaterniteInput, NouveauNeUncheckedCreateWithoutDossierMaterniteInput>
  }

  export type NouveauNeUpdateWithWhereUniqueWithoutDossierMaterniteInput = {
    where: NouveauNeWhereUniqueInput
    data: XOR<NouveauNeUpdateWithoutDossierMaterniteInput, NouveauNeUncheckedUpdateWithoutDossierMaterniteInput>
  }

  export type NouveauNeUpdateManyWithWhereWithoutDossierMaterniteInput = {
    where: NouveauNeScalarWhereInput
    data: XOR<NouveauNeUpdateManyMutationInput, NouveauNeUncheckedUpdateManyWithoutDossierMaterniteInput>
  }

  export type NouveauNeScalarWhereInput = {
    AND?: NouveauNeScalarWhereInput | NouveauNeScalarWhereInput[]
    OR?: NouveauNeScalarWhereInput[]
    NOT?: NouveauNeScalarWhereInput | NouveauNeScalarWhereInput[]
    id?: StringFilter<"NouveauNe"> | string
    dossierMaterniteId?: StringFilter<"NouveauNe"> | string
    nom?: StringFilter<"NouveauNe"> | string
    prenom?: StringFilter<"NouveauNe"> | string
    dateHeureNaissance?: DateTimeFilter<"NouveauNe"> | Date | string
    sexe?: StringFilter<"NouveauNe"> | string
    poids?: DecimalFilter<"NouveauNe"> | Decimal | DecimalJsLike | number | string
    scoreApgar?: IntNullableFilter<"NouveauNe"> | number | null
    createdAt?: DateTimeFilter<"NouveauNe"> | Date | string
  }

  export type DossierMaterniteCreateWithoutNouveauNesInput = {
    id?: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutDossiersMaterniteInput
  }

  export type DossierMaterniteUncheckedCreateWithoutNouveauNesInput = {
    id?: string
    patientId: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DossierMaterniteCreateOrConnectWithoutNouveauNesInput = {
    where: DossierMaterniteWhereUniqueInput
    create: XOR<DossierMaterniteCreateWithoutNouveauNesInput, DossierMaterniteUncheckedCreateWithoutNouveauNesInput>
  }

  export type DossierMaterniteUpsertWithoutNouveauNesInput = {
    update: XOR<DossierMaterniteUpdateWithoutNouveauNesInput, DossierMaterniteUncheckedUpdateWithoutNouveauNesInput>
    create: XOR<DossierMaterniteCreateWithoutNouveauNesInput, DossierMaterniteUncheckedCreateWithoutNouveauNesInput>
    where?: DossierMaterniteWhereInput
  }

  export type DossierMaterniteUpdateToOneWithWhereWithoutNouveauNesInput = {
    where?: DossierMaterniteWhereInput
    data: XOR<DossierMaterniteUpdateWithoutNouveauNesInput, DossierMaterniteUncheckedUpdateWithoutNouveauNesInput>
  }

  export type DossierMaterniteUpdateWithoutNouveauNesInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDossiersMaterniteNestedInput
  }

  export type DossierMaterniteUncheckedUpdateWithoutNouveauNesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueCreateWithoutArticleInput = {
    id?: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementLogistiqueUncheckedCreateWithoutArticleInput = {
    id?: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementLogistiqueCreateOrConnectWithoutArticleInput = {
    where: MouvementLogistiqueWhereUniqueInput
    create: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput>
  }

  export type MouvementLogistiqueCreateManyArticleInputEnvelope = {
    data: MouvementLogistiqueCreateManyArticleInput | MouvementLogistiqueCreateManyArticleInput[]
    skipDuplicates?: boolean
  }

  export type MouvementLogistiqueUpsertWithWhereUniqueWithoutArticleInput = {
    where: MouvementLogistiqueWhereUniqueInput
    update: XOR<MouvementLogistiqueUpdateWithoutArticleInput, MouvementLogistiqueUncheckedUpdateWithoutArticleInput>
    create: XOR<MouvementLogistiqueCreateWithoutArticleInput, MouvementLogistiqueUncheckedCreateWithoutArticleInput>
  }

  export type MouvementLogistiqueUpdateWithWhereUniqueWithoutArticleInput = {
    where: MouvementLogistiqueWhereUniqueInput
    data: XOR<MouvementLogistiqueUpdateWithoutArticleInput, MouvementLogistiqueUncheckedUpdateWithoutArticleInput>
  }

  export type MouvementLogistiqueUpdateManyWithWhereWithoutArticleInput = {
    where: MouvementLogistiqueScalarWhereInput
    data: XOR<MouvementLogistiqueUpdateManyMutationInput, MouvementLogistiqueUncheckedUpdateManyWithoutArticleInput>
  }

  export type MouvementLogistiqueScalarWhereInput = {
    AND?: MouvementLogistiqueScalarWhereInput | MouvementLogistiqueScalarWhereInput[]
    OR?: MouvementLogistiqueScalarWhereInput[]
    NOT?: MouvementLogistiqueScalarWhereInput | MouvementLogistiqueScalarWhereInput[]
    id?: StringFilter<"MouvementLogistique"> | string
    articleId?: StringFilter<"MouvementLogistique"> | string
    type?: StringFilter<"MouvementLogistique"> | string
    quantite?: IntFilter<"MouvementLogistique"> | number
    serviceDestinataire?: StringNullableFilter<"MouvementLogistique"> | string | null
    motif?: StringNullableFilter<"MouvementLogistique"> | string | null
    utilisateur?: StringFilter<"MouvementLogistique"> | string
    createdAt?: DateTimeFilter<"MouvementLogistique"> | Date | string
  }

  export type ArticleLogistiqueCreateWithoutMouvementsInput = {
    id?: string
    designation: string
    categorie: string
    famille?: string | null
    uniteMesure: string
    stockAlerte?: number
    stockActuel?: number
    createdAt?: Date | string
  }

  export type ArticleLogistiqueUncheckedCreateWithoutMouvementsInput = {
    id?: string
    designation: string
    categorie: string
    famille?: string | null
    uniteMesure: string
    stockAlerte?: number
    stockActuel?: number
    createdAt?: Date | string
  }

  export type ArticleLogistiqueCreateOrConnectWithoutMouvementsInput = {
    where: ArticleLogistiqueWhereUniqueInput
    create: XOR<ArticleLogistiqueCreateWithoutMouvementsInput, ArticleLogistiqueUncheckedCreateWithoutMouvementsInput>
  }

  export type ArticleLogistiqueUpsertWithoutMouvementsInput = {
    update: XOR<ArticleLogistiqueUpdateWithoutMouvementsInput, ArticleLogistiqueUncheckedUpdateWithoutMouvementsInput>
    create: XOR<ArticleLogistiqueCreateWithoutMouvementsInput, ArticleLogistiqueUncheckedCreateWithoutMouvementsInput>
    where?: ArticleLogistiqueWhereInput
  }

  export type ArticleLogistiqueUpdateToOneWithWhereWithoutMouvementsInput = {
    where?: ArticleLogistiqueWhereInput
    data: XOR<ArticleLogistiqueUpdateWithoutMouvementsInput, ArticleLogistiqueUncheckedUpdateWithoutMouvementsInput>
  }

  export type ArticleLogistiqueUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleLogistiqueUncheckedUpdateWithoutMouvementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    categorie?: StringFieldUpdateOperationsInput | string
    famille?: NullableStringFieldUpdateOperationsInput | string | null
    uniteMesure?: StringFieldUpdateOperationsInput | string
    stockAlerte?: IntFieldUpdateOperationsInput | number
    stockActuel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutDocumentsGEDInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentCreateNestedManyWithoutPatientInput
    allergies?: AllergieCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationCreateNestedManyWithoutPatientInput
    consultations?: ConsultationCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousCreateNestedManyWithoutPatientInput
    factures?: FactureCreateNestedManyWithoutPatientInput
    dispensations?: DispensationCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationCreateNestedManyWithoutPatientInput
    interventions?: InterventionCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDocumentsGEDInput = {
    id?: string
    numeroPatient: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    ville?: string | null
    profession?: string | null
    situationMatrimoniale?: string | null
    assureur?: string | null
    numeroAssure?: string | null
    tauxCouverture?: Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: string | null
    contactUrgenceTel?: string | null
    contactUrgenceLien?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    antecedents?: AntecedentUncheckedCreateNestedManyWithoutPatientInput
    allergies?: AllergieUncheckedCreateNestedManyWithoutPatientInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutPatientInput
    consultations?: ConsultationUncheckedCreateNestedManyWithoutPatientInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutPatientInput
    factures?: FactureUncheckedCreateNestedManyWithoutPatientInput
    dispensations?: DispensationUncheckedCreateNestedManyWithoutPatientInput
    hospitalisations?: HospitalisationUncheckedCreateNestedManyWithoutPatientInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPatientInput
    dossiersMaternite?: DossierMaterniteUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDocumentsGEDInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDocumentsGEDInput, PatientUncheckedCreateWithoutDocumentsGEDInput>
  }

  export type PatientUpsertWithoutDocumentsGEDInput = {
    update: XOR<PatientUpdateWithoutDocumentsGEDInput, PatientUncheckedUpdateWithoutDocumentsGEDInput>
    create: XOR<PatientCreateWithoutDocumentsGEDInput, PatientUncheckedCreateWithoutDocumentsGEDInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDocumentsGEDInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDocumentsGEDInput, PatientUncheckedUpdateWithoutDocumentsGEDInput>
  }

  export type PatientUpdateWithoutDocumentsGEDInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUpdateManyWithoutPatientNestedInput
    factures?: FactureUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDocumentsGEDInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroPatient?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    situationMatrimoniale?: NullableStringFieldUpdateOperationsInput | string | null
    assureur?: NullableStringFieldUpdateOperationsInput | string | null
    numeroAssure?: NullableStringFieldUpdateOperationsInput | string | null
    tauxCouverture?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contactUrgenceNom?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceTel?: NullableStringFieldUpdateOperationsInput | string | null
    contactUrgenceLien?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    antecedents?: AntecedentUncheckedUpdateManyWithoutPatientNestedInput
    allergies?: AllergieUncheckedUpdateManyWithoutPatientNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutPatientNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutPatientNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutPatientNestedInput
    factures?: FactureUncheckedUpdateManyWithoutPatientNestedInput
    dispensations?: DispensationUncheckedUpdateManyWithoutPatientNestedInput
    hospitalisations?: HospitalisationUncheckedUpdateManyWithoutPatientNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPatientNestedInput
    dossiersMaternite?: DossierMaterniteUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserCreateWithoutEmployeInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    consultations?: ConsultationCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionCreateNestedManyWithoutAnesthesisteInput
  }

  export type UserUncheckedCreateWithoutEmployeInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    roleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    consultations?: ConsultationUncheckedCreateNestedManyWithoutMedecinInput
    rendezvous?: RendezVousUncheckedCreateNestedManyWithoutMedecinInput
    ecritures?: EcritureComptableUncheckedCreateNestedManyWithoutCreatedByInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    observationsCrees?: ObservationInfirmierUncheckedCreateNestedManyWithoutInfirmierInput
    chirurgies?: InterventionUncheckedCreateNestedManyWithoutChirurgienInput
    anesthesies?: InterventionUncheckedCreateNestedManyWithoutAnesthesisteInput
  }

  export type UserCreateOrConnectWithoutEmployeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeInput, UserUncheckedCreateWithoutEmployeInput>
  }

  export type CongeCreateWithoutEmployeInput = {
    id?: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
  }

  export type CongeUncheckedCreateWithoutEmployeInput = {
    id?: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
  }

  export type CongeCreateOrConnectWithoutEmployeInput = {
    where: CongeWhereUniqueInput
    create: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput>
  }

  export type CongeCreateManyEmployeInputEnvelope = {
    data: CongeCreateManyEmployeInput | CongeCreateManyEmployeInput[]
    skipDuplicates?: boolean
  }

  export type PlanningCreateWithoutEmployeInput = {
    id?: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
  }

  export type PlanningUncheckedCreateWithoutEmployeInput = {
    id?: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
  }

  export type PlanningCreateOrConnectWithoutEmployeInput = {
    where: PlanningWhereUniqueInput
    create: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput>
  }

  export type PlanningCreateManyEmployeInputEnvelope = {
    data: PlanningCreateManyEmployeInput | PlanningCreateManyEmployeInput[]
    skipDuplicates?: boolean
  }

  export type BulletinPaieCreateWithoutEmployeInput = {
    id?: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
    lignes?: LigneBulletinCreateNestedManyWithoutBulletinInput
  }

  export type BulletinPaieUncheckedCreateWithoutEmployeInput = {
    id?: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
    lignes?: LigneBulletinUncheckedCreateNestedManyWithoutBulletinInput
  }

  export type BulletinPaieCreateOrConnectWithoutEmployeInput = {
    where: BulletinPaieWhereUniqueInput
    create: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput>
  }

  export type BulletinPaieCreateManyEmployeInputEnvelope = {
    data: BulletinPaieCreateManyEmployeInput | BulletinPaieCreateManyEmployeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeInput = {
    update: XOR<UserUpdateWithoutEmployeInput, UserUncheckedUpdateWithoutEmployeInput>
    create: XOR<UserCreateWithoutEmployeInput, UserUncheckedCreateWithoutEmployeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeInput, UserUncheckedUpdateWithoutEmployeInput>
  }

  export type UserUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
  }

  export type CongeUpsertWithWhereUniqueWithoutEmployeInput = {
    where: CongeWhereUniqueInput
    update: XOR<CongeUpdateWithoutEmployeInput, CongeUncheckedUpdateWithoutEmployeInput>
    create: XOR<CongeCreateWithoutEmployeInput, CongeUncheckedCreateWithoutEmployeInput>
  }

  export type CongeUpdateWithWhereUniqueWithoutEmployeInput = {
    where: CongeWhereUniqueInput
    data: XOR<CongeUpdateWithoutEmployeInput, CongeUncheckedUpdateWithoutEmployeInput>
  }

  export type CongeUpdateManyWithWhereWithoutEmployeInput = {
    where: CongeScalarWhereInput
    data: XOR<CongeUpdateManyMutationInput, CongeUncheckedUpdateManyWithoutEmployeInput>
  }

  export type CongeScalarWhereInput = {
    AND?: CongeScalarWhereInput | CongeScalarWhereInput[]
    OR?: CongeScalarWhereInput[]
    NOT?: CongeScalarWhereInput | CongeScalarWhereInput[]
    id?: StringFilter<"Conge"> | string
    employeId?: StringFilter<"Conge"> | string
    type?: StringFilter<"Conge"> | string
    dateDebut?: DateTimeFilter<"Conge"> | Date | string
    dateFin?: DateTimeFilter<"Conge"> | Date | string
    nbJours?: IntFilter<"Conge"> | number
    motif?: StringNullableFilter<"Conge"> | string | null
    statut?: StringFilter<"Conge"> | string
    createdAt?: DateTimeFilter<"Conge"> | Date | string
  }

  export type PlanningUpsertWithWhereUniqueWithoutEmployeInput = {
    where: PlanningWhereUniqueInput
    update: XOR<PlanningUpdateWithoutEmployeInput, PlanningUncheckedUpdateWithoutEmployeInput>
    create: XOR<PlanningCreateWithoutEmployeInput, PlanningUncheckedCreateWithoutEmployeInput>
  }

  export type PlanningUpdateWithWhereUniqueWithoutEmployeInput = {
    where: PlanningWhereUniqueInput
    data: XOR<PlanningUpdateWithoutEmployeInput, PlanningUncheckedUpdateWithoutEmployeInput>
  }

  export type PlanningUpdateManyWithWhereWithoutEmployeInput = {
    where: PlanningScalarWhereInput
    data: XOR<PlanningUpdateManyMutationInput, PlanningUncheckedUpdateManyWithoutEmployeInput>
  }

  export type PlanningScalarWhereInput = {
    AND?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    OR?: PlanningScalarWhereInput[]
    NOT?: PlanningScalarWhereInput | PlanningScalarWhereInput[]
    id?: StringFilter<"Planning"> | string
    employeId?: StringFilter<"Planning"> | string
    date?: DateTimeFilter<"Planning"> | Date | string
    heureDebut?: StringFilter<"Planning"> | string
    heureFin?: StringFilter<"Planning"> | string
    type?: StringFilter<"Planning"> | string
    createdAt?: DateTimeFilter<"Planning"> | Date | string
  }

  export type BulletinPaieUpsertWithWhereUniqueWithoutEmployeInput = {
    where: BulletinPaieWhereUniqueInput
    update: XOR<BulletinPaieUpdateWithoutEmployeInput, BulletinPaieUncheckedUpdateWithoutEmployeInput>
    create: XOR<BulletinPaieCreateWithoutEmployeInput, BulletinPaieUncheckedCreateWithoutEmployeInput>
  }

  export type BulletinPaieUpdateWithWhereUniqueWithoutEmployeInput = {
    where: BulletinPaieWhereUniqueInput
    data: XOR<BulletinPaieUpdateWithoutEmployeInput, BulletinPaieUncheckedUpdateWithoutEmployeInput>
  }

  export type BulletinPaieUpdateManyWithWhereWithoutEmployeInput = {
    where: BulletinPaieScalarWhereInput
    data: XOR<BulletinPaieUpdateManyMutationInput, BulletinPaieUncheckedUpdateManyWithoutEmployeInput>
  }

  export type BulletinPaieScalarWhereInput = {
    AND?: BulletinPaieScalarWhereInput | BulletinPaieScalarWhereInput[]
    OR?: BulletinPaieScalarWhereInput[]
    NOT?: BulletinPaieScalarWhereInput | BulletinPaieScalarWhereInput[]
    id?: StringFilter<"BulletinPaie"> | string
    employeId?: StringFilter<"BulletinPaie"> | string
    periode?: StringFilter<"BulletinPaie"> | string
    dateEmission?: DateTimeFilter<"BulletinPaie"> | Date | string
    salaireBase?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFilter<"BulletinPaie"> | Decimal | DecimalJsLike | number | string
    statut?: StringFilter<"BulletinPaie"> | string
  }

  export type EmployeCreateWithoutCongesInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeInput
    plannings?: PlanningCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUncheckedCreateWithoutCongesInput = {
    id?: string
    userId?: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plannings?: PlanningUncheckedCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeCreateOrConnectWithoutCongesInput = {
    where: EmployeWhereUniqueInput
    create: XOR<EmployeCreateWithoutCongesInput, EmployeUncheckedCreateWithoutCongesInput>
  }

  export type EmployeUpsertWithoutCongesInput = {
    update: XOR<EmployeUpdateWithoutCongesInput, EmployeUncheckedUpdateWithoutCongesInput>
    create: XOR<EmployeCreateWithoutCongesInput, EmployeUncheckedCreateWithoutCongesInput>
    where?: EmployeWhereInput
  }

  export type EmployeUpdateToOneWithWhereWithoutCongesInput = {
    where?: EmployeWhereInput
    data: XOR<EmployeUpdateWithoutCongesInput, EmployeUncheckedUpdateWithoutCongesInput>
  }

  export type EmployeUpdateWithoutCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeNestedInput
    plannings?: PlanningUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeUncheckedUpdateWithoutCongesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plannings?: PlanningUncheckedUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeCreateWithoutBulletinsInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeInput
    conges?: CongeCreateNestedManyWithoutEmployeInput
    plannings?: PlanningCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUncheckedCreateWithoutBulletinsInput = {
    id?: string
    userId?: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conges?: CongeUncheckedCreateNestedManyWithoutEmployeInput
    plannings?: PlanningUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeCreateOrConnectWithoutBulletinsInput = {
    where: EmployeWhereUniqueInput
    create: XOR<EmployeCreateWithoutBulletinsInput, EmployeUncheckedCreateWithoutBulletinsInput>
  }

  export type LigneBulletinCreateWithoutBulletinInput = {
    id?: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUncheckedCreateWithoutBulletinInput = {
    id?: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinCreateOrConnectWithoutBulletinInput = {
    where: LigneBulletinWhereUniqueInput
    create: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput>
  }

  export type LigneBulletinCreateManyBulletinInputEnvelope = {
    data: LigneBulletinCreateManyBulletinInput | LigneBulletinCreateManyBulletinInput[]
    skipDuplicates?: boolean
  }

  export type EmployeUpsertWithoutBulletinsInput = {
    update: XOR<EmployeUpdateWithoutBulletinsInput, EmployeUncheckedUpdateWithoutBulletinsInput>
    create: XOR<EmployeCreateWithoutBulletinsInput, EmployeUncheckedCreateWithoutBulletinsInput>
    where?: EmployeWhereInput
  }

  export type EmployeUpdateToOneWithWhereWithoutBulletinsInput = {
    where?: EmployeWhereInput
    data: XOR<EmployeUpdateWithoutBulletinsInput, EmployeUncheckedUpdateWithoutBulletinsInput>
  }

  export type EmployeUpdateWithoutBulletinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeNestedInput
    conges?: CongeUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeUncheckedUpdateWithoutBulletinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conges?: CongeUncheckedUpdateManyWithoutEmployeNestedInput
    plannings?: PlanningUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type LigneBulletinUpsertWithWhereUniqueWithoutBulletinInput = {
    where: LigneBulletinWhereUniqueInput
    update: XOR<LigneBulletinUpdateWithoutBulletinInput, LigneBulletinUncheckedUpdateWithoutBulletinInput>
    create: XOR<LigneBulletinCreateWithoutBulletinInput, LigneBulletinUncheckedCreateWithoutBulletinInput>
  }

  export type LigneBulletinUpdateWithWhereUniqueWithoutBulletinInput = {
    where: LigneBulletinWhereUniqueInput
    data: XOR<LigneBulletinUpdateWithoutBulletinInput, LigneBulletinUncheckedUpdateWithoutBulletinInput>
  }

  export type LigneBulletinUpdateManyWithWhereWithoutBulletinInput = {
    where: LigneBulletinScalarWhereInput
    data: XOR<LigneBulletinUpdateManyMutationInput, LigneBulletinUncheckedUpdateManyWithoutBulletinInput>
  }

  export type LigneBulletinScalarWhereInput = {
    AND?: LigneBulletinScalarWhereInput | LigneBulletinScalarWhereInput[]
    OR?: LigneBulletinScalarWhereInput[]
    NOT?: LigneBulletinScalarWhereInput | LigneBulletinScalarWhereInput[]
    id?: StringFilter<"LigneBulletin"> | string
    bulletinId?: StringFilter<"LigneBulletin"> | string
    libelle?: StringFilter<"LigneBulletin"> | string
    type?: StringFilter<"LigneBulletin"> | string
    base?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    taux?: DecimalNullableFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFilter<"LigneBulletin"> | Decimal | DecimalJsLike | number | string
  }

  export type BulletinPaieCreateWithoutLignesInput = {
    id?: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
    employe: EmployeCreateNestedOneWithoutBulletinsInput
  }

  export type BulletinPaieUncheckedCreateWithoutLignesInput = {
    id?: string
    employeId: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
  }

  export type BulletinPaieCreateOrConnectWithoutLignesInput = {
    where: BulletinPaieWhereUniqueInput
    create: XOR<BulletinPaieCreateWithoutLignesInput, BulletinPaieUncheckedCreateWithoutLignesInput>
  }

  export type BulletinPaieUpsertWithoutLignesInput = {
    update: XOR<BulletinPaieUpdateWithoutLignesInput, BulletinPaieUncheckedUpdateWithoutLignesInput>
    create: XOR<BulletinPaieCreateWithoutLignesInput, BulletinPaieUncheckedCreateWithoutLignesInput>
    where?: BulletinPaieWhereInput
  }

  export type BulletinPaieUpdateToOneWithWhereWithoutLignesInput = {
    where?: BulletinPaieWhereInput
    data: XOR<BulletinPaieUpdateWithoutLignesInput, BulletinPaieUncheckedUpdateWithoutLignesInput>
  }

  export type BulletinPaieUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    employe?: EmployeUpdateOneRequiredWithoutBulletinsNestedInput
  }

  export type BulletinPaieUncheckedUpdateWithoutLignesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeId?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeCreateWithoutPlanningsInput = {
    id?: string
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeInput
    conges?: CongeCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieCreateNestedManyWithoutEmployeInput
  }

  export type EmployeUncheckedCreateWithoutPlanningsInput = {
    id?: string
    userId?: string | null
    matricule: string
    nom: string
    prenom: string
    dateNaissance: Date | string
    sexe: string
    telephone: string
    email?: string | null
    adresse?: string | null
    categorie: string
    fonction: string
    specialite?: string | null
    dateEmbauche: Date | string
    typeContrat: string
    salaireBrut: Decimal | DecimalJsLike | number | string
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    conges?: CongeUncheckedCreateNestedManyWithoutEmployeInput
    bulletins?: BulletinPaieUncheckedCreateNestedManyWithoutEmployeInput
  }

  export type EmployeCreateOrConnectWithoutPlanningsInput = {
    where: EmployeWhereUniqueInput
    create: XOR<EmployeCreateWithoutPlanningsInput, EmployeUncheckedCreateWithoutPlanningsInput>
  }

  export type EmployeUpsertWithoutPlanningsInput = {
    update: XOR<EmployeUpdateWithoutPlanningsInput, EmployeUncheckedUpdateWithoutPlanningsInput>
    create: XOR<EmployeCreateWithoutPlanningsInput, EmployeUncheckedCreateWithoutPlanningsInput>
    where?: EmployeWhereInput
  }

  export type EmployeUpdateToOneWithWhereWithoutPlanningsInput = {
    where?: EmployeWhereInput
    data: XOR<EmployeUpdateWithoutPlanningsInput, EmployeUncheckedUpdateWithoutPlanningsInput>
  }

  export type EmployeUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeNestedInput
    conges?: CongeUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUpdateManyWithoutEmployeNestedInput
  }

  export type EmployeUncheckedUpdateWithoutPlanningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    matricule?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    telephone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: NullableStringFieldUpdateOperationsInput | string | null
    categorie?: StringFieldUpdateOperationsInput | string
    fonction?: StringFieldUpdateOperationsInput | string
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    dateEmbauche?: DateTimeFieldUpdateOperationsInput | Date | string
    typeContrat?: StringFieldUpdateOperationsInput | string
    salaireBrut?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conges?: CongeUncheckedUpdateManyWithoutEmployeNestedInput
    bulletins?: BulletinPaieUncheckedUpdateManyWithoutEmployeNestedInput
  }

  export type TicketMaintenanceCreateWithoutEquipementInput = {
    id?: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMaintenanceUncheckedCreateWithoutEquipementInput = {
    id?: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMaintenanceCreateOrConnectWithoutEquipementInput = {
    where: TicketMaintenanceWhereUniqueInput
    create: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput>
  }

  export type TicketMaintenanceCreateManyEquipementInputEnvelope = {
    data: TicketMaintenanceCreateManyEquipementInput | TicketMaintenanceCreateManyEquipementInput[]
    skipDuplicates?: boolean
  }

  export type TicketMaintenanceUpsertWithWhereUniqueWithoutEquipementInput = {
    where: TicketMaintenanceWhereUniqueInput
    update: XOR<TicketMaintenanceUpdateWithoutEquipementInput, TicketMaintenanceUncheckedUpdateWithoutEquipementInput>
    create: XOR<TicketMaintenanceCreateWithoutEquipementInput, TicketMaintenanceUncheckedCreateWithoutEquipementInput>
  }

  export type TicketMaintenanceUpdateWithWhereUniqueWithoutEquipementInput = {
    where: TicketMaintenanceWhereUniqueInput
    data: XOR<TicketMaintenanceUpdateWithoutEquipementInput, TicketMaintenanceUncheckedUpdateWithoutEquipementInput>
  }

  export type TicketMaintenanceUpdateManyWithWhereWithoutEquipementInput = {
    where: TicketMaintenanceScalarWhereInput
    data: XOR<TicketMaintenanceUpdateManyMutationInput, TicketMaintenanceUncheckedUpdateManyWithoutEquipementInput>
  }

  export type TicketMaintenanceScalarWhereInput = {
    AND?: TicketMaintenanceScalarWhereInput | TicketMaintenanceScalarWhereInput[]
    OR?: TicketMaintenanceScalarWhereInput[]
    NOT?: TicketMaintenanceScalarWhereInput | TicketMaintenanceScalarWhereInput[]
    id?: StringFilter<"TicketMaintenance"> | string
    equipementId?: StringFilter<"TicketMaintenance"> | string
    type?: StringFilter<"TicketMaintenance"> | string
    priorite?: StringFilter<"TicketMaintenance"> | string
    objet?: StringFilter<"TicketMaintenance"> | string
    description?: StringFilter<"TicketMaintenance"> | string
    statut?: StringFilter<"TicketMaintenance"> | string
    intervenant?: StringNullableFilter<"TicketMaintenance"> | string | null
    dateResolution?: DateTimeNullableFilter<"TicketMaintenance"> | Date | string | null
    coutEstime?: DecimalNullableFilter<"TicketMaintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
    updatedAt?: DateTimeFilter<"TicketMaintenance"> | Date | string
  }

  export type EquipementCreateWithoutTicketsInput = {
    id?: string
    code: string
    nom: string
    type: string
    marque?: string | null
    modele?: string | null
    serie?: string | null
    dateAchat?: Date | string | null
    dateDerniereMaintenace?: Date | string | null
    dateProchaineMaintenance?: Date | string | null
    statut?: string
    localisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementUncheckedCreateWithoutTicketsInput = {
    id?: string
    code: string
    nom: string
    type: string
    marque?: string | null
    modele?: string | null
    serie?: string | null
    dateAchat?: Date | string | null
    dateDerniereMaintenace?: Date | string | null
    dateProchaineMaintenance?: Date | string | null
    statut?: string
    localisation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipementCreateOrConnectWithoutTicketsInput = {
    where: EquipementWhereUniqueInput
    create: XOR<EquipementCreateWithoutTicketsInput, EquipementUncheckedCreateWithoutTicketsInput>
  }

  export type EquipementUpsertWithoutTicketsInput = {
    update: XOR<EquipementUpdateWithoutTicketsInput, EquipementUncheckedUpdateWithoutTicketsInput>
    create: XOR<EquipementCreateWithoutTicketsInput, EquipementUncheckedCreateWithoutTicketsInput>
    where?: EquipementWhereInput
  }

  export type EquipementUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EquipementWhereInput
    data: XOR<EquipementUpdateWithoutTicketsInput, EquipementUncheckedUpdateWithoutTicketsInput>
  }

  export type EquipementUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipementUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    marque?: NullableStringFieldUpdateOperationsInput | string | null
    modele?: NullableStringFieldUpdateOperationsInput | string | null
    serie?: NullableStringFieldUpdateOperationsInput | string | null
    dateAchat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDerniereMaintenace?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateProchaineMaintenance?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statut?: StringFieldUpdateOperationsInput | string
    localisation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationCreateManyMedecinInput = {
    id?: string
    patientId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousCreateManyMedecinInput = {
    id?: string
    patientId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableCreateManyCreatedByInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateManyCreatedByInput = {
    id?: string
    factureId: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    module: string
    entityType: string
    entityId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ObservationInfirmierCreateManyInfirmierInput = {
    id?: string
    hospitalisationId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type InterventionCreateManyChirurgienInput = {
    id?: string
    patientId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type InterventionCreateManyAnesthesisteInput = {
    id?: string
    patientId: string
    chirurgienId: string
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type ConsultationUpdateWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUpdateManyWithoutConsultationNestedInput
    facture?: FactureUpdateOneWithoutConsultationsNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousUpdateWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutRendezvousNestedInput
  }

  export type RendezVousUncheckedUpdateWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousUncheckedUpdateManyWithoutMedecinInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneRequiredWithoutEcrituresNestedInput
    compte?: CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput
    exercice?: ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput
    centreAnalytique?: CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    facture?: FactureUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    factureId?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierUpdateWithoutInfirmierInput = {
    id?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    hospitalisation?: HospitalisationUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationInfirmierUncheckedUpdateWithoutInfirmierInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalisationId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierUncheckedUpdateManyWithoutInfirmierInput = {
    id?: StringFieldUpdateOperationsInput | string
    hospitalisationId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUpdateWithoutChirurgienInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInterventionsNestedInput
    anesthesiste?: UserUpdateOneWithoutAnesthesiesNestedInput
  }

  export type InterventionUncheckedUpdateWithoutChirurgienInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyWithoutChirurgienInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUpdateWithoutAnesthesisteInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutInterventionsNestedInput
    chirurgien?: UserUpdateOneRequiredWithoutChirurgiesNestedInput
  }

  export type InterventionUncheckedUpdateWithoutAnesthesisteInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyWithoutAnesthesisteInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    password: string
    nom: string
    prenom: string
    telephone?: string | null
    photo?: string | null
    actif?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    module?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultations?: ConsultationUncheckedUpdateManyWithoutMedecinNestedInput
    rendezvous?: RendezVousUncheckedUpdateManyWithoutMedecinNestedInput
    ecritures?: EcritureComptableUncheckedUpdateManyWithoutCreatedByNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    observationsCrees?: ObservationInfirmierUncheckedUpdateManyWithoutInfirmierNestedInput
    chirurgies?: InterventionUncheckedUpdateManyWithoutChirurgienNestedInput
    anesthesies?: InterventionUncheckedUpdateManyWithoutAnesthesisteNestedInput
    employe?: EmployeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    actif?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateManyCompteInput = {
    id?: string
    journalId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneRequiredWithoutEcrituresNestedInput
    exercice?: ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput
    centreAnalytique?: CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCompteInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateManyJournalInput = {
    id?: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    compte?: CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput
    exercice?: ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput
    centreAnalytique?: CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyWithoutJournalInput = {
    id?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateManyExerciceInput = {
    id?: string
    journalId: string
    compteId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    centreAnalytiqueId?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BudgetCreateManyExerciceInput = {
    id?: string
    compte: string
    libelle: string
    montant: Decimal | DecimalJsLike | number | string
    type: string
    mois?: number | null
    createdAt?: Date | string
  }

  export type EcritureComptableUpdateWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneRequiredWithoutEcrituresNestedInput
    compte?: CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput
    centreAnalytique?: CentreAnalytiqueUpdateOneWithoutEcrituresNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    centreAnalytiqueId?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUpdateWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BudgetUncheckedUpdateManyWithoutExerciceInput = {
    id?: StringFieldUpdateOperationsInput | string
    compte?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableCreateManyCentreAnalytiqueInput = {
    id?: string
    journalId: string
    compteId: string
    exerciceId: string
    dateEcriture: Date | string
    libelle: string
    debit?: Decimal | DecimalJsLike | number | string
    credit?: Decimal | DecimalJsLike | number | string
    pieceRef?: string | null
    valide?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EcritureComptableUpdateWithoutCentreAnalytiqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journal?: JournalUpdateOneRequiredWithoutEcrituresNestedInput
    compte?: CompteComptableUpdateOneRequiredWithoutEcrituresNestedInput
    exercice?: ExerciceComptableUpdateOneRequiredWithoutEcrituresNestedInput
    createdBy?: UserUpdateOneRequiredWithoutEcrituresNestedInput
  }

  export type EcritureComptableUncheckedUpdateWithoutCentreAnalytiqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EcritureComptableUncheckedUpdateManyWithoutCentreAnalytiqueInput = {
    id?: StringFieldUpdateOperationsInput | string
    journalId?: StringFieldUpdateOperationsInput | string
    compteId?: StringFieldUpdateOperationsInput | string
    exerciceId?: StringFieldUpdateOperationsInput | string
    dateEcriture?: DateTimeFieldUpdateOperationsInput | Date | string
    libelle?: StringFieldUpdateOperationsInput | string
    debit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    credit?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pieceRef?: NullableStringFieldUpdateOperationsInput | string | null
    valide?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentCreateManyPatientInput = {
    id?: string
    type: string
    description: string
    date?: Date | string | null
    createdAt?: Date | string
  }

  export type AllergieCreateManyPatientInput = {
    id?: string
    type: string
    allergene: string
    severite: string
    reaction?: string | null
    createdAt?: Date | string
  }

  export type VaccinationCreateManyPatientInput = {
    id?: string
    vaccin: string
    dateVaccin: Date | string
    rappel?: Date | string | null
    lot?: string | null
    createdAt?: Date | string
  }

  export type ConsultationCreateManyPatientInput = {
    id?: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RendezVousCreateManyPatientInput = {
    id?: string
    medecinId: string
    dateHeure: Date | string
    duree?: number
    motif: string
    statut?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FactureCreateManyPatientInput = {
    id?: string
    numeroFacture: string
    dateFacture?: Date | string
    dateEcheance: Date | string
    montantHT: Decimal | DecimalJsLike | number | string
    montantTVA?: Decimal | DecimalJsLike | number | string
    montantTTC: Decimal | DecimalJsLike | number | string
    partAssurance?: Decimal | DecimalJsLike | number | string
    partPatient: Decimal | DecimalJsLike | number | string
    statut?: string
    ecritureComptableId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DispensationCreateManyPatientInput = {
    id?: string
    medicamentId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type HospitalisationCreateManyPatientInput = {
    id?: string
    litId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterventionCreateManyPatientInput = {
    id?: string
    chirurgienId: string
    anesthesisteId?: string | null
    typeIntervention: string
    dateHeure: Date | string
    salle: string
    statut?: string
    protocoleOp?: string | null
    typeAnesthesie?: string | null
    duree?: number | null
    createdAt?: Date | string
  }

  export type DossierMaterniteCreateManyPatientInput = {
    id?: string
    dateDebutGrossesse: Date | string
    parite: number
    gestite: number
    groupageRhesus: string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentGEDCreateManyPatientInput = {
    id?: string
    titre: string
    type: string
    url: string
    module: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AntecedentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AntecedentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AllergieUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    allergene?: StringFieldUpdateOperationsInput | string
    severite?: StringFieldUpdateOperationsInput | string
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccin?: StringFieldUpdateOperationsInput | string
    dateVaccin?: DateTimeFieldUpdateOperationsInput | Date | string
    rappel?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lot?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medecin?: UserUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUpdateManyWithoutConsultationNestedInput
    facture?: FactureUpdateOneWithoutConsultationsNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    factureId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medecin?: UserUpdateOneRequiredWithoutRendezvousNestedInput
  }

  export type RendezVousUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RendezVousUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    duree?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FactureUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneFactureUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneFactureUncheckedUpdateManyWithoutFactureNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutFactureNestedInput
    consultations?: ConsultationUncheckedUpdateManyWithoutFactureNestedInput
  }

  export type FactureUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroFacture?: StringFieldUpdateOperationsInput | string
    dateFacture?: DateTimeFieldUpdateOperationsInput | Date | string
    dateEcheance?: DateTimeFieldUpdateOperationsInput | Date | string
    montantHT?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTVA?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montantTTC?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partAssurance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    partPatient?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    ecritureComptableId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicament?: MedicamentUpdateOneRequiredWithoutDispensationsNestedInput
  }

  export type DispensationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalisationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lit?: LitUpdateOneRequiredWithoutHospitalisationsNestedInput
    observations?: ObservationInfirmierUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    litId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    litId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chirurgien?: UserUpdateOneRequiredWithoutChirurgiesNestedInput
    anesthesiste?: UserUpdateOneWithoutAnesthesiesNestedInput
  }

  export type InterventionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    chirurgienId?: StringFieldUpdateOperationsInput | string
    anesthesisteId?: NullableStringFieldUpdateOperationsInput | string | null
    typeIntervention?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    salle?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    protocoleOp?: NullableStringFieldUpdateOperationsInput | string | null
    typeAnesthesie?: NullableStringFieldUpdateOperationsInput | string | null
    duree?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DossierMaterniteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nouveauNes?: NouveauNeUpdateManyWithoutDossierMaterniteNestedInput
  }

  export type DossierMaterniteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nouveauNes?: NouveauNeUncheckedUpdateManyWithoutDossierMaterniteNestedInput
  }

  export type DossierMaterniteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebutGrossesse?: DateTimeFieldUpdateOperationsInput | Date | string
    parite?: IntFieldUpdateOperationsInput | number
    gestite?: IntFieldUpdateOperationsInput | number
    groupageRhesus?: StringFieldUpdateOperationsInput | string
    examensPrenataux?: NullableJsonNullValueInput | InputJsonValue
    accouchement?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentGEDUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    module?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateManyConsultationInput = {
    id?: string
    medicament: string
    dosage: string
    forme: string
    posologie: string
    duree: string
    quantite: number
    instructions?: string | null
    createdAt?: Date | string
  }

  export type ActeRealiseCreateManyConsultationInput = {
    id?: string
    acteId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type PrescriptionUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicament?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    forme?: StringFieldUpdateOperationsInput | string
    posologie?: StringFieldUpdateOperationsInput | string
    duree?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActeRealiseUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acte?: NomenclatureActeUpdateOneRequiredWithoutActesNestedInput
    resultat?: ResultatExamenUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseUncheckedUpdateWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acteId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultat?: ResultatExamenUncheckedUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseUncheckedUpdateManyWithoutConsultationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acteId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActeRealiseCreateManyActeInput = {
    id?: string
    consultationId: string
    quantite?: number
    tarif: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ActeRealiseUpdateWithoutActeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    consultation?: ConsultationUpdateOneRequiredWithoutActesRealisesNestedInput
    resultat?: ResultatExamenUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseUncheckedUpdateWithoutActeInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultat?: ResultatExamenUncheckedUpdateOneWithoutActeRealiseNestedInput
  }

  export type ActeRealiseUncheckedUpdateManyWithoutActeInput = {
    id?: StringFieldUpdateOperationsInput | string
    consultationId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    tarif?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockCreateManyMedicamentInput = {
    id?: string
    lot: string
    datePeremption: Date | string
    quantite: number
    emplacement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementStockCreateManyMedicamentInput = {
    id?: string
    type: string
    quantite: number
    motif: string
    reference?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type DispensationCreateManyMedicamentInput = {
    id?: string
    patientId: string
    quantite: number
    prescription?: string | null
    pharmacien: string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieCreateManyMedicamentInput = {
    id?: string
    commandeId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type StockUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockUncheckedUpdateManyWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lot?: StringFieldUpdateOperationsInput | string
    datePeremption?: DateTimeFieldUpdateOperationsInput | Date | string
    quantite?: IntFieldUpdateOperationsInput | number
    emplacement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementStockUncheckedUpdateManyWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    motif?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDispensationsNestedInput
  }

  export type DispensationUncheckedUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DispensationUncheckedUpdateManyWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prescription?: NullableStringFieldUpdateOperationsInput | string | null
    pharmacien?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commande?: CommandePharmacieUpdateOneRequiredWithoutLignesNestedInput
  }

  export type LigneCommandePharmacieUncheckedUpdateWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandeId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieUncheckedUpdateManyWithoutMedicamentInput = {
    id?: StringFieldUpdateOperationsInput | string
    commandeId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandePharmacieCreateManyFournisseurInput = {
    id?: string
    numeroCommande: string
    dateCommande?: Date | string
    dateLivraison?: Date | string | null
    montantTotal: Decimal | DecimalJsLike | number | string
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandePharmacieUpdateWithoutFournisseurInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandePharmacieUpdateManyWithoutCommandeNestedInput
  }

  export type CommandePharmacieUncheckedUpdateWithoutFournisseurInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lignes?: LigneCommandePharmacieUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandePharmacieUncheckedUpdateManyWithoutFournisseurInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroCommande?: StringFieldUpdateOperationsInput | string
    dateCommande?: DateTimeFieldUpdateOperationsInput | Date | string
    dateLivraison?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    montantTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieCreateManyCommandeInput = {
    id?: string
    medicamentId: string
    quantiteCommandee: number
    quantiteRecue?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type LigneCommandePharmacieUpdateWithoutCommandeInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicament?: MedicamentUpdateOneRequiredWithoutCommandesNestedInput
  }

  export type LigneCommandePharmacieUncheckedUpdateWithoutCommandeInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneCommandePharmacieUncheckedUpdateManyWithoutCommandeInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicamentId?: StringFieldUpdateOperationsInput | string
    quantiteCommandee?: IntFieldUpdateOperationsInput | number
    quantiteRecue?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureCreateManyFactureInput = {
    id?: string
    designation: string
    quantite?: number
    prixUnitaire: Decimal | DecimalJsLike | number | string
    montant: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type PaiementCreateManyFactureInput = {
    id?: string
    datePaiement?: Date | string
    montant: Decimal | DecimalJsLike | number | string
    modePaiement: string
    reference?: string | null
    notes?: string | null
    createdById: string
    createdAt?: Date | string
  }

  export type ConsultationCreateManyFactureInput = {
    id?: string
    patientId: string
    medecinId: string
    dateConsultation?: Date | string
    motifConsultation: string
    anamnese?: string | null
    examenClinique?: string | null
    diagnostic?: string | null
    planTraitement?: string | null
    poids?: Decimal | DecimalJsLike | number | string | null
    taille?: Decimal | DecimalJsLike | number | string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: number | null
    tensionDiastolique?: number | null
    frequenceCardiaque?: number | null
    saturationOxygene?: number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LigneFactureUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureUncheckedUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LigneFactureUncheckedUpdateManyWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    datePaiement?: DateTimeFieldUpdateOperationsInput | Date | string
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    modePaiement?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConsultationUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutConsultationsNestedInput
    medecin?: UserUpdateOneRequiredWithoutConsultationsNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutConsultationNestedInput
    actesRealises?: ActeRealiseUncheckedUpdateManyWithoutConsultationNestedInput
  }

  export type ConsultationUncheckedUpdateManyWithoutFactureInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    medecinId?: StringFieldUpdateOperationsInput | string
    dateConsultation?: DateTimeFieldUpdateOperationsInput | Date | string
    motifConsultation?: StringFieldUpdateOperationsInput | string
    anamnese?: NullableStringFieldUpdateOperationsInput | string | null
    examenClinique?: NullableStringFieldUpdateOperationsInput | string | null
    diagnostic?: NullableStringFieldUpdateOperationsInput | string | null
    planTraitement?: NullableStringFieldUpdateOperationsInput | string | null
    poids?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taille?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    tensionSystolique?: NullableIntFieldUpdateOperationsInput | number | null
    tensionDiastolique?: NullableIntFieldUpdateOperationsInput | number | null
    frequenceCardiaque?: NullableIntFieldUpdateOperationsInput | number | null
    saturationOxygene?: NullableIntFieldUpdateOperationsInput | number | null
    donneesSpecialite?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HospitalisationCreateManyLitInput = {
    id?: string
    patientId: string
    dateEntree?: Date | string
    dateSortie?: Date | string | null
    motif: string
    diagnosticEntree?: string | null
    diagnosticSortie?: string | null
    statut?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HospitalisationUpdateWithoutLitInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutHospitalisationsNestedInput
    observations?: ObservationInfirmierUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationUncheckedUpdateWithoutLitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationNestedInput
  }

  export type HospitalisationUncheckedUpdateManyWithoutLitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    dateEntree?: DateTimeFieldUpdateOperationsInput | Date | string
    dateSortie?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motif?: StringFieldUpdateOperationsInput | string
    diagnosticEntree?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosticSortie?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierCreateManyHospitalisationInput = {
    id?: string
    infirmierId: string
    pressionArterielle?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    note: string
    dateHeure?: Date | string
  }

  export type ObservationInfirmierUpdateWithoutHospitalisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
    infirmier?: UserUpdateOneRequiredWithoutObservationsCreesNestedInput
  }

  export type ObservationInfirmierUncheckedUpdateWithoutHospitalisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    infirmierId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationInfirmierUncheckedUpdateManyWithoutHospitalisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    infirmierId?: StringFieldUpdateOperationsInput | string
    pressionArterielle?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    note?: StringFieldUpdateOperationsInput | string
    dateHeure?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeCreateManyDossierMaterniteInput = {
    id?: string
    nom: string
    prenom: string
    dateHeureNaissance: Date | string
    sexe: string
    poids: Decimal | DecimalJsLike | number | string
    scoreApgar?: number | null
    createdAt?: Date | string
  }

  export type NouveauNeUpdateWithoutDossierMaterniteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeUncheckedUpdateWithoutDossierMaterniteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NouveauNeUncheckedUpdateManyWithoutDossierMaterniteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    dateHeureNaissance?: DateTimeFieldUpdateOperationsInput | Date | string
    sexe?: StringFieldUpdateOperationsInput | string
    poids?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    scoreApgar?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueCreateManyArticleInput = {
    id?: string
    type: string
    quantite: number
    serviceDestinataire?: string | null
    motif?: string | null
    utilisateur: string
    createdAt?: Date | string
  }

  export type MouvementLogistiqueUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementLogistiqueUncheckedUpdateManyWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantite?: IntFieldUpdateOperationsInput | number
    serviceDestinataire?: NullableStringFieldUpdateOperationsInput | string | null
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeCreateManyEmployeInput = {
    id?: string
    type: string
    dateDebut: Date | string
    dateFin: Date | string
    nbJours: number
    motif?: string | null
    statut?: string
    createdAt?: Date | string
  }

  export type PlanningCreateManyEmployeInput = {
    id?: string
    date: Date | string
    heureDebut: string
    heureFin: string
    type: string
    createdAt?: Date | string
  }

  export type BulletinPaieCreateManyEmployeInput = {
    id?: string
    periode: string
    dateEmission?: Date | string
    salaireBase: Decimal | DecimalJsLike | number | string
    totalPrimes: Decimal | DecimalJsLike | number | string
    totalRetenues: Decimal | DecimalJsLike | number | string
    salaireNet: Decimal | DecimalJsLike | number | string
    statut?: string
  }

  export type CongeUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeUncheckedUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CongeUncheckedUpdateManyWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    nbJours?: IntFieldUpdateOperationsInput | number
    motif?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUncheckedUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanningUncheckedUpdateManyWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BulletinPaieUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    lignes?: LigneBulletinUpdateManyWithoutBulletinNestedInput
  }

  export type BulletinPaieUncheckedUpdateWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
    lignes?: LigneBulletinUncheckedUpdateManyWithoutBulletinNestedInput
  }

  export type BulletinPaieUncheckedUpdateManyWithoutEmployeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periode?: StringFieldUpdateOperationsInput | string
    dateEmission?: DateTimeFieldUpdateOperationsInput | Date | string
    salaireBase?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrimes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalRetenues?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salaireNet?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    statut?: StringFieldUpdateOperationsInput | string
  }

  export type LigneBulletinCreateManyBulletinInput = {
    id?: string
    libelle: string
    type: string
    base?: Decimal | DecimalJsLike | number | string | null
    taux?: Decimal | DecimalJsLike | number | string | null
    montant: Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUpdateWithoutBulletinInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUncheckedUpdateWithoutBulletinInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type LigneBulletinUncheckedUpdateManyWithoutBulletinInput = {
    id?: StringFieldUpdateOperationsInput | string
    libelle?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    base?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    taux?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    montant?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TicketMaintenanceCreateManyEquipementInput = {
    id?: string
    type: string
    priorite: string
    objet: string
    description: string
    statut?: string
    intervenant?: string | null
    dateResolution?: Date | string | null
    coutEstime?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketMaintenanceUpdateWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMaintenanceUncheckedUpdateWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketMaintenanceUncheckedUpdateManyWithoutEquipementInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priorite?: StringFieldUpdateOperationsInput | string
    objet?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    statut?: StringFieldUpdateOperationsInput | string
    intervenant?: NullableStringFieldUpdateOperationsInput | string | null
    dateResolution?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coutEstime?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}